[
  {
    "chunk_id": 1,
    "source": "pydantic_llms_data",
    "content": "========================\nCODE SNIPPETS\n========================\nTITLE: Install Pydantic from GitHub repository (uv)\nDESCRIPTION: Installs the Pydantic library directly from its main branch on GitHub using uv. This is useful for installing the latest development version. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nuv add 'git+https://github.com/pydantic/pydantic@main'\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic from GitHub repository with extras (uv)\nDESCRIPTION: Installs Pydantic from its GitHub repository with specified extra dependencies (e.g., 'email', 'timezone') using uv. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nuv add 'git+https://github.com/pydantic/pydantic@main#egg=pydantic[email,timezone]'\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic from GitHub repository (pip)\nDESCRIPTION: Installs the Pydantic library directly from its main branch on GitHub using pip. This is useful for installing the latest development version. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npip install 'git+https://github.com/pydantic/pydantic@main'\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic from GitHub repository with extras (pip)\nDESCRIPTION: Installs Pydantic from its GitHub repository with specified extra dependencies (e.g., 'email', 'timezone') using pip. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npip install 'git+https://github.com/pydantic/pydantic@main#egg=pydantic[email,timezone]'\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic with optional email support (uv)\nDESCRIPTION: Installs Pydantic with the 'email' extra dependency using uv, enabling email validation features. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nuv add 'pydantic[email]'\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic with uv\nDESCRIPTION: Installs the Pydantic library using the uv package manager. uv is a fast, modern Python package installer.",
    "chunk_length": 2278
  },
  {
    "chunk_id": 2,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuv add pydantic\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic with optional email support (pip)\nDESCRIPTION: Installs Pydantic with the 'email' extra dependency using pip, enabling email validation features. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install 'pydantic[email]'\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic with pip\nDESCRIPTION: Installs the Pydantic library using the pip package manager. This is the standard method for installing Python packages. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pydantic\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic with optional email and timezone support (uv)\nDESCRIPTION: Installs Pydantic with both 'email' and 'timezone' extra dependencies using uv, providing full support for email validation and timezone handling. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nuv add 'pydantic[email,timezone]'\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic and Dependencies\nDESCRIPTION: This command installs Pydantic, its dependencies, test dependencies, and documentation dependencies using the project's Makefile. It sets up the complete development environment. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmake install\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic with optional email and timezone support (pip)\nDESCRIPTION: Installs Pydantic with both 'email' and 'timezone' extra dependencies using pip, providing full support for email validation and timezone handling. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npip install 'pydantic[email,timezone]'\n```\n\n----------------------------------------\n\nTITLE: Update Documentation Examples with Pytest\nDESCRIPTION: Command to run Pydantic's documentation tests and automatically update any outdated code examples found within the documentation files.",
    "chunk_length": 2317
  },
  {
    "chunk_id": 3,
    "source": "pydantic_llms_data",
    "content": "This ensures examples remain accurate and runnable. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n# Run tests and update code examples\npytest tests/test_docs.py --update-examples\n```\n\n----------------------------------------\n\nTITLE: Install Development Tools\nDESCRIPTION: Commands to install essential development tools like uv (a Python package installer and virtual environment manager) and pre-commit (a framework for managing and automating pre-commit hooks). SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npipx install uv\npipx install pre-commit\n```\n\n----------------------------------------\n\nTITLE: Install Bump Pydantic Tool\nDESCRIPTION: Installs the 'bump-pydantic' tool, a beta utility designed to help automate code transformations for Pydantic V1 to V2 migration. It's installed via pip. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install bump-pydantic\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic with conda\nDESCRIPTION: Installs the Pydantic library from the conda-forge channel using the conda package manager. This method is suitable for users within the Anaconda ecosystem. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nconda install pydantic -c conda-forge\n```\n\n----------------------------------------\n\nTITLE: Configure Mypy with Pydantic Plugin (pyproject.toml)\nDESCRIPTION: Example configuration for pyproject.toml to enable the pydantic plugin and set various mypy and pydantic-mypy specific strictness flags. This setup enhances type checking for Pydantic models. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[tool.mypy]\nplugins = [\"pydantic.mypy\"]\n\nfollow_imports = \"silent\"\nwarn_redundant_casts = true\nwarn_unused_ignores = true\ndisallow_any_generics = true\nno_implicit_reexport = true\ndisallow_untyped_defs = true\n\n[tool.pydantic-mypy]\ninit_forbid_extra = true\ninit_typed = true\nwarn_required_dynamic_aliases = true\n```\n\n----------------------------------------\n\nTITLE: Install datamodel-code-generator\nDESCRIPTION: Installs the datamodel-code-generator library using pip.",
    "chunk_length": 2363
  },
  {
    "chunk_id": 4,
    "source": "pydantic_llms_data",
    "content": "This is the initial step required to utilize the tool for generating Pydantic models from data schemas. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/datamodel_code_generator.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install datamodel-code-generator\n```\n\n----------------------------------------\n\nTITLE: Configure Mypy with Pydantic Plugin (mypy.ini)\nDESCRIPTION: Example configuration for mypy.ini to enable the pydantic plugin and set various mypy and pydantic-mypy specific strictness flags. This setup enhances type checking for Pydantic models. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\nplugins = pydantic.mypy\n\nfollow_imports = silent\nwarn_redundant_casts = True\nwarn_unused_ignores = True\ndisallow_any_generics = True\nno_implicit_reexport = True\ndisallow_untyped_defs = True\n\n[pydantic-mypy]\ninit_forbid_extra = True\ninit_typed = True\nwarn_required_dynamic_aliases = True\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic V2\nDESCRIPTION: Installs the latest production release of Pydantic V2 using pip. This command ensures you have the most up-to-date version for new projects or upgrades. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U pydantic\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic V1\nDESCRIPTION: Installs a specific version of Pydantic V1 using pip. This is useful if you need to maintain compatibility with Pydantic V1 for existing projects or specific features. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install \"pydantic==1.*\n\"\n```\n\n----------------------------------------\n\nTITLE: Pydantic with ARQ Job Queue Example\nDESCRIPTION: Demonstrates defining a Pydantic model for job data, serializing it for enqueueing, and validating/deserializing it during job processing with ARQ. Requires Redis and ARQ installed. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/queues.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom typing import Any\n\nfrom arq import create_pool\nfrom arq.connections import RedisSettings\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nREDIS_SETTINGS = RedisSettings()\n\n\nasync def process_user(ctx: dict[str, Any], user_data: dict[str, Any]) -> None:\n    user = User.model_validate(user_data)\n    print(f'Processing user: {repr(user)}')\n\n\nasync def enqueue_jobs(redis):\n    user1 = User(id=1, name='John Doe', email='john@example.com')\n    user2 = User(id=2, name='Jane Doe', email='jane@example.com')\n\n    await redis.enqueue_job('process_user', user1.model_dump())\n    print(f'Enqueued user: {repr(user1)}')\n\n    await redis.enqueue_job('process_user', user2.model_dump())\n    print(f'Enqueued user: {repr(user2)}')\n\n\nclass WorkerSettings:\n    functions = [process_user]\n    redis_settings = REDIS_SETTINGS\n\n\nasync def main():\n    redis = await create_pool(REDIS_SETTINGS)\n    await enqueue_jobs(redis)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Install flake8-pydantic Plugin\nDESCRIPTION: Installs the flake8-pydantic plugin using pip.",
    "chunk_length": 3351
  },
  {
    "chunk_id": 5,
    "source": "pydantic_llms_data",
    "content": "This plugin provides linting capabilities for Pydantic models within your project. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/linting.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install flake8-pydantic\n```\n\n----------------------------------------\n\nTITLE: Mypy Configuration File Example\nDESCRIPTION: An example of a Mypy configuration file (`.ini` format) used by the test suite. These files specify Mypy settings and plugins to be applied during type checking for specific test cases. SOURCE: https://github.com/pydantic/pydantic/blob/main/tests/mypy/README.md#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\nplugins = pydantic.mypy\n\n[mypy \"test_mypy.py\"]\nignore_missing_imports = true\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Example\nDESCRIPTION: Demonstrates a Pydantic BaseModel with various field types and potential validation issues. This snippet is used to illustrate the benefits of the Pydantic mypy plugin. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: Optional[str] = None\n    signup_ts: Optional[datetime] = None\n    list_of_ints: list[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field! Model()  # will raise a validation error for age and list_of_ints\n```\n\n----------------------------------------\n\nTITLE: Python Docstring Example: Function\nDESCRIPTION: Illustrates the Google-style docstring format for a Python function, detailing arguments and return values. This adheres to PEP 257 and is checked by pydocstyle for consistency. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef bar(self, baz: int) -> str:\n    \"\"\"A function docstring. Args:\n        baz: A description of `baz`. Returns:\n        A description of the return value.",
    "chunk_length": 2059
  },
  {
    "chunk_id": 6,
    "source": "pydantic_llms_data",
    "content": "\"\"\"\n\n    return 'bar'\n```\n\n----------------------------------------\n\nTITLE: Pydantic BaseModel Example\nDESCRIPTION: Demonstrates creating a Pydantic model with type hints for validation and serialization. Shows data coercion and model dumping. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/index.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, PositiveInt\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime | None\n    tastes: dict[str, PositiveInt]\n\n\nexternal_data = {\n    'id': 123,\n    'signup_ts': '2019-06-01 12:22',\n    'tastes': {\n        'wine': 9,\n        b'cheese': 7,\n        'cabbage': '1',\n    },\n}\n\nuser = User(**external_data)\n\nprint(user.id)\nprint(user.model_dump())\n```\n\n----------------------------------------\n\nTITLE: Pydantic Data Model Example (Python)\nDESCRIPTION: Demonstrates creating a Pydantic BaseModel for user data. It shows how to define fields with type hints, default values, and optional types. The example validates external data, converting types and handling missing values. SOURCE: https://github.com/pydantic/pydantic/blob/main/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n    friends: list[int] = []\n\nexternal_data = {'id': '123', 'signup_ts': '2017-06-01 12:22', 'friends': [1, '2', b'3']}\nuser = User(**external_data)\nprint(user)\n#> User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]\nprint(user.id)\n#> 123\n```\n\n----------------------------------------\n\nTITLE: Install Pydantic for AWS Lambda\nDESCRIPTION: Installs the Pydantic library for AWS Lambda functions using pip. This command specifies platform compatibility (manylinux2014_x86_64), a target directory for packaging, the CPython implementation, a compatible Python version (3.10), and ensures pre-built binary wheels are used.",
    "chunk_length": 2072
  },
  {
    "chunk_id": 7,
    "source": "pydantic_llms_data",
    "content": "This is crucial for ensuring compatibility between your local development environment and the AWS Lambda runtime. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/aws_lambda.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install \\\n    --platform manylinux2014_x86_64 \\  # (1)! --target=<your_package_dir> \\  # (2)! --implementation cp \\  # (3)! --python-version 3.10 \\  # (4)! --only-binary=:all: \\  # (5)! --upgrade pydantic  # (6)! ```\n\n----------------------------------------\n\nTITLE: Get Pydantic Version String\nDESCRIPTION: Access the primary version string of the Pydantic library. This is typically a simple string representation of the installed version. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/version.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pydantic\n\nprint(pydantic.__version__)\n```\n\n----------------------------------------\n\nTITLE: Python Docstring Example: Class\nDESCRIPTION: Demonstrates the correct Google-style docstring format for a Python class, including documentation for class attributes. This follows PEP 257 guidelines and is linted by pydocstyle. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    \"\"\"A class docstring. Attributes:\n        bar: A description of bar. Defaults to \"bar\". \"\"\"\n\n    bar: str = 'bar'\n```\n\n----------------------------------------\n\nTITLE: Get Pydantic Version (pre-v2)\nDESCRIPTION: This command is used to get Pydantic version information for versions prior to v2.0. It's essential for users on older Pydantic versions when reporting issues. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pydantic.utils; print(pydantic.utils.version_info())\n```\n\n----------------------------------------\n\nTITLE: Pydantic `__pydantic_on_complete__()` Hook\nDESCRIPTION: Introduces a new hook, `__pydantic_on_complete__()`, which is executed once a Pydantic model is fully ready and all its fields are complete.",
    "chunk_length": 2050
  },
  {
    "chunk_id": 8,
    "source": "pydantic_llms_data",
    "content": "This hook is useful for performing final setup or validation steps after a model has been initialized. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass MyModel:\n    # ... model definition ... def __pydantic_on_complete__(self):\n        # This method is called after the model is fully ready\n        print(\"Model is complete and ready to use!\")\n\n```\n\n----------------------------------------\n\nTITLE: BaseModel Instantiated Directly: Python Example\nDESCRIPTION: This error occurs when `BaseModel` is instantiated directly without inheriting from it. The example shows how to catch this specific PydanticUserError. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n    BaseModel()\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'base-model-instantiated'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Documentation Syntax Highlighting\nDESCRIPTION: Fixes local syntax highlighting issues within the documentation extensions. This ensures that code examples in the documentation are displayed correctly. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_161\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Documentation Syntax Highlighting:\n\nUpdated docs extensions to fix local syntax highlighting. ```\n\n----------------------------------------\n\nTITLE: Config and model_config Both Defined: Python Example\nDESCRIPTION: This error occurs when both the legacy `class Config` and the modern `model_config` are defined within the same Pydantic model. The example illustrates catching this conflict. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        model_config = ConfigDict(from_attributes=True)\n\n        a: str\n\n        class Config:\n            from_attributes = True\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'config-both'\n```\n\n----------------------------------------\n\nTITLE: Basic Pydantic Logging with Logfire\nDESCRIPTION: Demonstrates how to configure Logfire and log a Pydantic BaseModel instance.",
    "chunk_length": 2341
  },
  {
    "chunk_id": 9,
    "source": "pydantic_llms_data",
    "content": "This snippet shows the basic setup for sending Pydantic model data to Logfire for observability. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/logfire.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()  # (1)! class User(BaseModel):\n    name: str\n    country_code: str\n    dob: date\n\n\nuser = User(name='Anne', country_code='USA', dob='2000-01-01')\nlogfire.info('user processed: {user!r}', user=user)  # (2)! ```\n\n----------------------------------------\n\nTITLE: Use Bump Pydantic Tool\nDESCRIPTION: Demonstrates the command-line usage of the 'bump-pydantic' tool. Navigate to your project's root directory and specify the package name to initiate the migration process. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd /path/to/repo_folder\nbump-pydantic my_package\n```\n\n----------------------------------------\n\nTITLE: Pydantic JSON Schema Generation Example\nDESCRIPTION: Illustrates how to generate a JSON Schema from a Pydantic model, which is useful for self-documenting APIs and integrating with tools that support the JSON Schema format. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    zipcode: str\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: Address\n    why: str = 'No idea'\n\n\nprint(Meeting.model_json_schema())\n\"\"\"\n{\n    '$defs': {\n        'Address': {\n            'properties': {\n                'street': {'title': 'Street', 'type': 'string'},\n                'city': {'title': 'City', 'type': 'string'},\n                'zipcode': {'title': 'Zipcode', 'type': 'string'},\n            },\n            'required': ['street', 'city', 'zipcode'],\n            'title': 'Address',\n            'type': 'object',\n        }\n    },\n    'properties': {\n        'when': {'format': 'date-time', 'title': 'When', 'type': 'string'},\n        'where': {'$ref': '#/$defs/Address'},\n        'why': {'default': 'No idea', 'title': 'Why', 'type': 'string'},\n    },\n    'required': ['when', 'where'],\n    'title': 'Meeting',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Undefined Annotation: Python Example\nDESCRIPTION: This error is raised when Pydantic encounters an undefined annotation during schema generation.",
    "chunk_length": 2510
  },
  {
    "chunk_id": 10,
    "source": "pydantic_llms_data",
    "content": "The example shows how to catch `PydanticUndefinedAnnotation` for a forward-referenced type. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUndefinedAnnotation\n\n\nclass Model(BaseModel):\n    a: 'B'  # noqa F821\n\n\ntry:\n    Model.model_rebuild()\nexcept PydanticUndefinedAnnotation as exc_info:\n    assert exc_info.code == 'undefined-annotation'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Time Parsing Example\nDESCRIPTION: Demonstrates Pydantic's capability to parse time strings into Python's datetime.time objects. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import time\n\nfrom pydantic import BaseModel\n\n\nclass Meeting(BaseModel):\n    t: time = None\n\n\nm = Meeting(t=time(4, 8, 16))\n\nprint(m.model_dump())\n#> {'t': datetime.time(4, 8, 16)}\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Data Conversion Example\nDESCRIPTION: Demonstrates how Pydantic automatically casts input data to conform to model field types, potentially leading to information loss. Includes an example of using strict mode for type enforcement. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n    b: float\n    c: str\n\n\nprint(Model(a=3.000, b='2.72', c=b'binary data').model_dump())\n#> {'a': 3, 'b': 2.72, 'c': 'binary data'}\n\n\nclass ModelWithList(BaseModel):\n    items: list[int]\n\n\nprint(ModelWithList(items=(1, 2, 3)))\n#> items=[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Pydantic BaseModel Example for Mypy Testing\nDESCRIPTION: Illustrates a Pydantic `BaseModel` definition and its instantiation with an extra keyword argument. This serves as a typical input file for the Mypy test suite, demonstrating a scenario that Mypy would analyze for type checking errors. SOURCE: https://github.com/pydantic/pydantic/blob/main/tests/mypy/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n\n\nmodel = Model(a=1, b=2)\n```\n\n----------------------------------------\n\nTITLE: Pydantic Strict Mode and Data Coercion Example\nDESCRIPTION: Shows how Pydantic handles data validation, contrasting default type coercion with strict mode, and demonstrates parsing JSON data with type conversion.",
    "chunk_length": 2520
  },
  {
    "chunk_id": 11,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: bytes\n\n\nm = Meeting.model_validate({'when': '2020-01-01T12:00', 'where': 'home'})\nprint(m)\n#> when=datetime.datetime(2020, 1, 1, 12, 0) where=b'home'\ntry:\n    m = Meeting.model_validate(\n        {'when': '2020-01-01T12:00', 'where': 'home'},\n        strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n2 validation errors for Meeting\nwhen\n  Input should be a valid datetime [type=datetime_type, input_value='2020-01-01T12:00', input_type=str]\nwhere\n  Input should be a valid bytes [type=bytes_type, input_value='home', input_type=str]\n\"\"\"\n\nm_json = Meeting.model_validate_json(\n    '{\"when\": \"2020-01-01T12:00\", \"where\": \"home\"}'\n)\nprint(m_json)\n#> when=datetime.datetime(2020, 1, 1, 12, 0) where=b'home'\n```\n\n----------------------------------------\n\nTITLE: Clone Pydantic Repository\nDESCRIPTION: Instructions to clone your fork of the Pydantic repository from GitHub and navigate into the project directory. This is the first step in setting up a local development environment. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:<your username>/pydantic.git\ncd pydantic\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Validation Examples\nDESCRIPTION: Demonstrates the usage of Pydantic's model_validate, model_validate_json, and model_validate_strings methods with various inputs, including successful validations and error handling for invalid data. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n\n\n# Example 1: model_validate with a dictionary\nm = User.model_validate({'id': 123, 'name': 'James'})\nprint(m)\n#> id=123 name='James' signup_ts=None\n\n# Example 2: model_validate with invalid input type\ntry:\n    User.model_validate(['not', 'a', 'dict'])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Input should be a valid dictionary or instance of User [type=model_type, input_value=['not', 'a', 'dict'], input_type=list]\n    \"\"\"\n\n# Example 3: model_validate_json with valid JSON string\nm = User.model_validate_json('{\"id\": 123, \"name\": \"James\"}')\nprint(m)\n#> id=123 name='James' signup_ts=None\n\n# Example 4: model_validate_json with invalid data type in JSON\ntry:\n    m = User.model_validate_json('{\"id\": 123, \"name\": 123}')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    \"\"\"\n\n# Example 5: model_validate_json with invalid JSON format\ntry:\n    m = User.model_validate_json('invalid JSON')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='invalid JSON', input_type=str]\n    \"\"\"\n\n# Example 6: model_validate_strings with string values\nm = User.model_validate_strings({'id': '123', 'name': 'James'})\nprint(m)\n#> id=123 name='James' signup_ts=None\n\n# Example 7: model_validate_strings with datetime string\nm = User.model_validate_strings(\n    {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01T12:00:00'}\n)\nprint(m)\n#> id=123 name='James' signup_ts=datetime.datetime(2024, 4, 1, 12, 0)\n\n# Example 8: model_validate_strings with strict=True and invalid datetime format\ntry:\n    m = User.model_validate_strings(\n        {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01'},\n        strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    signup_ts\n      Input should be a valid datetime, invalid datetime separator, expected `T`, `t`, `_` or space [type=datetime_parsing, input_value='2024-04-01', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Format Full Changelog Link for GitHub Release\nDESCRIPTION: Defines the format for the full changelog link to be included in the GitHub release body, comparing the previous and current versions.",
    "chunk_length": 4474
  },
  {
    "chunk_id": 12,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/release/README.md#_snippet_5\n\nLANGUAGE: Markdown\nCODE:\n```\nFull Changelog: https://github.com/pydantic/pydantic/compare/v{PREV_VERSION}...v{VERSION}/\n```\n\n----------------------------------------\n\nTITLE: Create GitHub Release Tag and Body\nDESCRIPTION: Creates a new release on GitHub. This involves setting the tag to `v{VERSION}`, the title to `v{VERSION} {DATE}`, and populating the body with the prepared `HISTORY.md` section and a full changelog link. SOURCE: https://github.com/pydantic/pydantic/blob/main/release/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngit tag v{VERSION}\ngit push origin v{VERSION}\n```\n\n----------------------------------------\n\nTITLE: Mapping validate_as to Validator Types\nDESCRIPTION: Shows how the `validate_as` method in the pipeline API maps to Pydantic's `BeforeValidator`, `AfterValidator`, and `WrapValidator`. It provides examples for pre-processing, post-processing, and wrapping validation logic. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic.experimental.pipeline import transform, validate_as\n\n# BeforeValidator\nAnnotated[int, validate_as(str).str_strip().validate_as(...)]  # (1)! # AfterValidator\nAnnotated[int, transform(lambda x: x * 2)]  # (2)! # WrapValidator\nAnnotated[\n    int,\n    validate_as(str)\n    .str_strip()\n    .validate_as(...)\n    .transform(lambda x: x * 2),  # (3)! ]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Serialization Examples\nDESCRIPTION: Demonstrates serializing a Pydantic model to a Python dict (with Python objects), a JSONable dict, and a JSON string, showcasing options like excluding unset or default fields. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: bytes\n    why: str = 'No idea'\n\n\nm = Meeting(when='2020-01-01T12:00', where='home')\nprint(m.model_dump(exclude_unset=True))\n#> {'when': datetime.datetime(2020, 1, 1, 12, 0), 'where': b'home'}\nprint(m.model_dump(exclude={'where'}, mode='json'))\n#> {'when': '2020-01-01T12:00:00', 'why': 'No idea'}\nprint(m.model_dump_json(exclude_defaults=True))\n#> {\"when\":\"2020-01-01T12:00:00\",\"where\":\"home\"}\n```\n\n----------------------------------------\n\nTITLE: Keyword Arguments Removed (regex): Python Example\nDESCRIPTION: This error indicates that certain keyword arguments, like `regex`, have been removed in Pydantic V2.",
    "chunk_length": 2630
  },
  {
    "chunk_id": 13,
    "source": "pydantic_llms_data",
    "content": "The example shows a V1-style usage that would trigger this error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        x: str = Field(regex='test')\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'removed-kwargs'\n```\n\n----------------------------------------\n\nTITLE: Instantiate and Print Model with Generic Owners\nDESCRIPTION: Provides an example of creating an instance of the `Model` class, populating it with `Owner` objects containing specific types (`Car`, `House`), and printing the resulting model. This demonstrates successful instantiation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nmodel = Model(\n    car_owner=Owner(name='John', item=Car(color='black')),\n    home_owner=Owner(name='James', item=House(rooms=3)),\n)\nprint(model)\n\n```\n\n----------------------------------------\n\nTITLE: datetime_past Pydantic Validation Example\nDESCRIPTION: Shows the 'datetime_past' error, triggered when a value assigned to a PastDatetime field is not in the past. The example creates a datetime object in the future. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime, timedelta\n\nfrom pydantic import BaseModel, PastDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: PastDatetime\n\n\ntry:\n    Model(x=datetime.now() + timedelta(100))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_past'\n```\n\n----------------------------------------\n\nTITLE: decimal_parsing Pydantic Validation Example\nDESCRIPTION: Demonstrates the 'decimal_parsing' error, which occurs when a value cannot be parsed into a Decimal number. The example attempts to parse the string 'test' into a Decimal field. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_parsing'\n```\n\n----------------------------------------\n\nTITLE: Prepare Release with Python Script\nDESCRIPTION: Runs the release preparation script from the repository root.",
    "chunk_length": 2556
  },
  {
    "chunk_id": 14,
    "source": "pydantic_llms_data",
    "content": "This script updates the version number in `version.py`, runs `uv lock`, and adds a new section to `HISTORY.md`. A `--dry-run` flag can be used to preview changes without modifying files. SOURCE: https://github.com/pydantic/pydantic/blob/main/release/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nuv run release/prepare.py {VERSION}\n```\n\n----------------------------------------\n\nTITLE: Validate INI Data with Pydantic\nDESCRIPTION: Shows how to load and validate data from an INI configuration file using Python's `configparser` module and a Pydantic `BaseModel`. The example defines a `Person` model and validates data from a specific section of the INI file. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#_snippet_12\n\nLANGUAGE: ini\nCODE:\n```\n[PERSON]\nname = John Doe\nage = 30\nemail = john@example.com\n```\n\nLANGUAGE: python\nCODE:\n```\nimport configparser\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nconfig = configparser.ConfigParser()\nconfig.read('person.ini')\nperson = Person.model_validate(config['PERSON'])\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```\n\n----------------------------------------\n\nTITLE: Model Field Overridden: Python Example\nDESCRIPTION: This error is raised when a field defined on a base class was overridden by a non-annotated attribute. The example demonstrates catching this specific PydanticUserError. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    a: float\n\n\ntry:\n\n    class Bar(Foo):\n        x: float = 12.3\n        a = 123.0\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-field-overridden'\n```\n\n----------------------------------------\n\nTITLE: Mypy Configuration for Pydantic Plugin\nDESCRIPTION: Shows how to enable the Pydantic mypy plugin by adding 'pydantic.mypy' to the plugins list in mypy configuration files.",
    "chunk_length": 2077
  },
  {
    "chunk_id": 15,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\nplugins = pydantic.mypy\n```\n\nLANGUAGE: toml\nCODE:\n```\n[tool.mypy]\nplugins = ['pydantic.mypy']\n```\n\n----------------------------------------\n\nTITLE: Pydantic init_typed Example\nDESCRIPTION: Demonstrates how Pydantic's default data conversion allows string input for integer fields. The `init_typed` plugin setting prevents this by synthesizing `__init__` with explicit type annotations for fields. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Model(BaseModel):\n    a: int\n\n\nModel(a='1')\n```\n\n----------------------------------------\n\nTITLE: Pydantic Date Parsing Example\nDESCRIPTION: Shows how Pydantic can convert Unix timestamps (integers or floats) and date strings into Python's datetime.date objects. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n\nclass Birthday(BaseModel):\n    d: date = None\n\n\nmy_birthday = Birthday(d=1679616000.0)\n\nprint(my_birthday.model_dump())\n#> {'d': datetime.date(2023, 3, 24)}\n\n```\n\n----------------------------------------\n\nTITLE: Build Documentation\nDESCRIPTION: Builds the project's documentation using mkdocs-material. This command is used to verify that any documentation changes you've made render correctly. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nmake docs\n```\n\n----------------------------------------\n\nTITLE: Pydantic: ContextVar for Model Instantiation with Context\nDESCRIPTION: Illustrates a workaround for passing context during direct Pydantic model instantiation using `ContextVar` and a custom `__init__`. This enables context-aware validation when creating model instances, requiring `pydantic`, `contextvars`, and `typing`. The example shows multiplying a number by a context-provided multiplier.",
    "chunk_length": 2066
  },
  {
    "chunk_id": 16,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom contextlib import contextmanager\nfrom contextvars import ContextVar\nfrom typing import Any, Generator\n\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n_init_context_var = ContextVar('_init_context_var', default=None)\n\n\n@contextmanager\ndef init_context(value: dict[str, Any]) -> Generator[None]:\n    token = _init_context_var.set(value)\n    try:\n        yield\n    finally:\n        _init_context_var.reset(token)\n\n\nclass Model(BaseModel):\n    my_number: int\n\n    def __init__(self, /, **data: Any) -> None:\n        self.__pydantic_validator__.validate_python(\n            data,\n            self_instance=self,\n            context=_init_context_var.get(),\n        )\n\n    @field_validator('my_number')\n    @classmethod\n    def multiply_with_context(cls, value: int, info: ValidationInfo) -> int:\n        if isinstance(info.context, dict):\n            multiplier = info.context.get('multiplier', 1)\n            value = value * multiplier\n        return value\n\n\nprint(Model(my_number=2))\n#> my_number=2\n\nwith init_context({'multiplier': 3}):\n    print(Model(my_number=2))\n    #> my_number=6\n\nprint(Model(my_number=2))\n#> my_number=2\n```\n\n----------------------------------------\n\nTITLE: Schema for Unknown Type: Python Example\nDESCRIPTION: This error occurs when Pydantic fails to generate a schema for an unknown or unsupported type. The example shows a model with an integer literal as a type annotation, triggering the error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        x: 43 = 123\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'schema-for-unknown-type'\n```\n\n----------------------------------------\n\nTITLE: Get Detailed Pydantic Version Info\nDESCRIPTION: Retrieve more detailed version information for Pydantic, which might include build numbers, commit hashes, or other version-related metadata.",
    "chunk_length": 2168
  },
  {
    "chunk_id": 17,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/version.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.version import version_info\n\nprint(version_info())\n```\n\n----------------------------------------\n\nTITLE: enum Pydantic Validation Example\nDESCRIPTION: Illustrates the 'enum' error, which occurs when an input value does not match any of the members in an Enum field. The example uses a string Enum and provides an invalid option. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom enum import Enum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyEnum(str, Enum):\n    option = 'option'\n\n\nclass Model(BaseModel):\n    x: MyEnum\n\n\ntry:\n    Model(x='other_option')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'enum'\n```\n\n----------------------------------------\n\nTITLE: Get Pydantic Version (v2+)\nDESCRIPTION: This command retrieves the Pydantic version information, which is crucial for reporting bugs or issues. It executes a Python script to print the version details. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pydantic.version; print(pydantic.version.version_info())\n```\n\n----------------------------------------\n\nTITLE: JSON Schema Invalid Type: Python Example\nDESCRIPTION: This error is raised when Pydantic encounters a type it cannot convert into a JSON schema, such as `ImportString` in this example. The code demonstrates triggering and catching this error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ImportString, PydanticUserError\n\n\nclass Model(BaseModel):\n    a: ImportString\n\n\ntry:\n    Model.model_json_schema()\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-for-json-schema'\n```\n\n----------------------------------------\n\nTITLE: dict_type Pydantic Validation Example\nDESCRIPTION: Demonstrates the 'dict_type' error, raised when the input value's type is not a dictionary for a dict field.",
    "chunk_length": 2173
  },
  {
    "chunk_id": 18,
    "source": "pydantic_llms_data",
    "content": "The example attempts to assign a list to a dictionary field. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: dict\n\n\ntry:\n    Model(x=['1', '2'])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'dict_type'\n```\n\n----------------------------------------\n\nTITLE: Check `pydantic_core` Files (Python)\nDESCRIPTION: This Python snippet uses `importlib.metadata` to list files within the `pydantic-core` package. It helps verify if the compiled library and type stubs, specifically `_pydantic_core`, are present, which is crucial for correct Pydantic installation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/aws_lambda.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom importlib.metadata import files\nprint([file for file in files('pydantic-core') if file.name.startswith('_pydantic_core')])\n\"\"\"\n[PackagePath('pydantic_core/_pydantic_core.pyi'), PackagePath('pydantic_core/_pydantic_core.cpython-312-x86_64-linux-gnu.so')]\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Pickling Support\nDESCRIPTION: Illustrates Pydantic models' support for efficient pickling and unpickling. This allows models to be serialized and deserialized, preserving their state. The example shows the process of pickling a model instance and then unpickling it. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport pickle\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel):\n    a: str\n    b: int\n\n\nm = FooBarModel(a='hello', b=123)\nprint(m)\n#> a='hello' b=123\ndata = pickle.dumps(m)\nprint(data[:20])\n#> b'\\x80\\x04\\x95\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main_'\nm2 = pickle.loads(data)\nprint(m2)\n#> a='hello' b=123\n```\n\n----------------------------------------\n\nTITLE: datetime_parsing Pydantic Validation Example\nDESCRIPTION: Illustrates the 'datetime_parsing' error, which occurs when a string value cannot be parsed into a datetime field.",
    "chunk_length": 2148
  },
  {
    "chunk_id": 19,
    "source": "pydantic_llms_data",
    "content": "The example uses a strict datetime field and invalid JSON input. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime = Field(strict=True)\n\n\ntry:\n    Model.model_validate_json(json.dumps({'x': 'not a datetime'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_parsing'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Configuration API\nDESCRIPTION: Documentation for Pydantic's configuration system, including ConfigDict, with_config, ExtraValues, and BaseConfig. This section details how to manage model configuration and settings. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/config.md#_snippet_0\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.config:\n  members:\n    - ConfigDict\n    - with_config\n    - ExtraValues\n    - BaseConfig\n  options:\n    group_by_category: false\n```\n\n----------------------------------------\n\nTITLE: `missing_keyword_only_argument` Validation Error Example (Python)\nDESCRIPTION: This error is raised when a required keyword-only argument is not provided to a function decorated with `validate_call`. The example defines a function `foo` with a keyword-only argument `a` and calls it without passing `a`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_60\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(*, a: int):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_keyword_only_argument'\n```\n\n----------------------------------------\n\nTITLE: decimal_whole_digits Pydantic Validation Example\nDESCRIPTION: Shows the 'decimal_whole_digits' error, triggered when a Decimal value has more digits before the decimal point than allowed by the combined max_digits and decimal_places constraints.",
    "chunk_length": 2070
  },
  {
    "chunk_id": 20,
    "source": "pydantic_llms_data",
    "content": "The example uses max_digits=6 and decimal_places=3. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(max_digits=6, decimal_places=3)\n\n\ntry:\n    Model(x='12345.6')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_whole_digits'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Boolean Validation Example\nDESCRIPTION: Demonstrates Pydantic's flexible boolean validation, accepting various string representations, integers 0/1, and standard booleans. It also shows how a ValidationError is raised for invalid inputs. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass BooleanModel(BaseModel):\n    bool_value: bool\n\n\nprint(BooleanModel(bool_value=False))\n#> bool_value=False\nprint(BooleanModel(bool_value='False'))\n#> bool_value=False\nprint(BooleanModel(bool_value=1))\n#> bool_value=True\ntry:\n    BooleanModel(bool_value=[])\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for BooleanModel\n    bool_value\n      Input should be a valid boolean [type=bool_type, input_value=[], input_type=list]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: decimal_max_digits Pydantic Validation Example\nDESCRIPTION: Illustrates the 'decimal_max_digits' error, which occurs when a Decimal value exceeds the specified maximum number of digits. The example sets max_digits to 3 and provides a value with more digits. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(max_digits=3)\n\n\ntry:\n    Model(x='42.1234')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_max_digits'\n```\n\n----------------------------------------\n\nTITLE: Validate YAML Data with Pydantic\nDESCRIPTION: Illustrates how to load and validate data from a YAML file using the `PyYAML` library and a Pydantic `BaseModel`.",
    "chunk_length": 2356
  },
  {
    "chunk_id": 21,
    "source": "pydantic_llms_data",
    "content": "The example defines a `Person` model and validates the loaded YAML data. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nname: John Doe\nage: 30\nemail: john@example.com\n```\n\nLANGUAGE: python\nCODE:\n```\nimport yaml\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.yaml') as f:\n    data = yaml.safe_load(f)\n\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```\n\n----------------------------------------\n\nTITLE: Generate JSON Schema for Boolean\nDESCRIPTION: Demonstrates the JSON Schema generated for a boolean type by Pydantic's GenerateJsonSchema class, starting from a core schema. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"type\": \"boolean\"\n}\n```\n\n----------------------------------------\n\nTITLE: `missing_positional_only_argument` Validation Error Example (Python)\nDESCRIPTION: This error occurs when a required positional-only argument is not passed to a function decorated with `validate_call`. The example defines a function `foo` with a positional-only argument `a` and calls it without providing `a`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_61\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int, /):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_positional_only_argument'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Timedelta Parsing Example\nDESCRIPTION: Illustrates Pydantic's support for parsing timedelta values from integers, floats (seconds), and various string formats including ISO 8601. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import timedelta\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    td: timedelta = None\n\n\nm = Model(td='P3DT12H30M5S')\n\nprint(m.model_dump())\n#> {'td': datetime.timedelta(days=3, seconds=45005)}\n\n```\n\n----------------------------------------\n\nTITLE: String Constraints with Pydantic\nDESCRIPTION: Demonstrates how to use Pydantic's Field to enforce minimum length, maximum length, and regular expression patterns on string fields within a BaseModel.",
    "chunk_length": 2528
  },
  {
    "chunk_id": 22,
    "source": "pydantic_llms_data",
    "content": "Includes an example of model instantiation and output. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    short: str = Field(min_length=3)\n    long: str = Field(max_length=10)\n    regex: str = Field(pattern=r'^\\d*$')  # (1)! foo = Foo(short='foo', long='foobarbaz', regex='123')\nprint(foo)\n#> short='foo' long='foobarbaz' regex='123'\n```\n\n----------------------------------------\n\nTITLE: Importing Experimental Features in Pydantic\nDESCRIPTION: Demonstrates how to import experimental features from the pydantic.experimental module and how to suppress the associated experimental warning. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/version-policy.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.experimental import feature_name\n```\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\n\nfrom pydantic import PydanticExperimentalWarning\n\nwarnings.filterwarnings('ignore', category=PydanticExperimentalWarning)\n```\n\n----------------------------------------\n\nTITLE: Pydantic User Data Readability\nDESCRIPTION: This Python snippet illustrates a Pydantic User object with nested Address details. It emphasizes Pydantic's ability to create more readable and maintainable data models compared to plain string representations. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/plugins/devtools_output.html#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nuser: User(\n    id=123,\n    name='John Doe',\n    signup_ts=datetime.datetime(2019, 6, 1, 12, 22),\n    friends=[ 1234, 4567, 7890, ],\n    address=Address(\n        street='Testing',\n        country='uk',\n        lat=51.5,\n        lng=0.0,\n    ),\n)\n```\n\n----------------------------------------\n\nTITLE: `missing_argument` Validation Error Example (Python)\nDESCRIPTION: This error occurs when a required positional-or-keyword argument is not passed to a function decorated with `validate_call`. The example defines a function `foo` requiring an argument `a` and calls it without any arguments.",
    "chunk_length": 2085
  },
  {
    "chunk_id": 23,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_59\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_argument'\n```\n\n----------------------------------------\n\nTITLE: decimal_max_places Pydantic Validation Example\nDESCRIPTION: Shows the 'decimal_max_places' error, raised when a Decimal value has more digits after the decimal point than allowed. The example sets decimal_places to 3 and provides a value with four decimal places. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x='42.1234')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_max_places'\n```\n\n----------------------------------------\n\nTITLE: SerializeAsAny Annotation Example\nDESCRIPTION: Demonstrates using the SerializeAsAny annotation to achieve duck typing serialization behavior for a Pydantic model field. This allows a field to be serialized as if its type hint was Any. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, SerializeAsAny\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    as_any: SerializeAsAny[User]\n    as_user: User\n\n\nuser = UserLogin(name='pydantic', password='password')\n\nprint(OuterModel(as_any=user, as_user=user).model_dump())\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Copying Example\nDESCRIPTION: Demonstrates how to duplicate Pydantic models using the `model_copy()` method, including options for updating fields and performing deep copies.",
    "chunk_length": 2054
  },
  {
    "chunk_id": 24,
    "source": "pydantic_llms_data",
    "content": "Shows how `deep=True` affects nested model references. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nprint(m.model_copy(update={'banana': 0}))\n#> banana=0 foo='hello' bar=BarModel(whatever=123)\n\n# normal copy gives the same object reference for bar:\nprint(id(m.bar) == id(m.model_copy().bar))\n#> True\n# deep copy gives a new object reference for `bar`:\nprint(id(m.bar) == id(m.model_copy(deep=True).bar))\n#> False\n```\n\n----------------------------------------\n\nTITLE: Pydantic UserIn/UserOut Data Transformation\nDESCRIPTION: This Python snippet defines Pydantic models `UserIn` and `UserOut` to handle data validation and transformation. It includes a function `my_api` that processes user input, converting a string representation of a number to an integer, and returns a validated output model. The example demonstrates idiomatic Python for data handling. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass UserIn(BaseModel):\n    favorite_number: int | str\n\n\nclass UserOut(BaseModel):\n    favorite_number: int\n\n\ndef my_api(user: UserIn) -> UserOut:\n    favorite_number = user.favorite_number\n    if isinstance(favorite_number, str):\n        favorite_number = int(user.favorite_number.strip())\n\n    return UserOut(favorite_number=favorite_number)\n\n\nassert my_api(UserIn(favorite_number=' 1 ')).favorite_number == 1\n```\n\n----------------------------------------\n\nTITLE: Pydantic Types API Reference\nDESCRIPTION: This section details the Pydantic types module and its documentation rendering options. It specifies how to display root headings and whether to merge initialization methods into class definitions for clarity.",
    "chunk_length": 2069
  },
  {
    "chunk_id": 25,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/types.md#_snippet_0\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.types\n  options:\n    show_root_heading: true\n    merge_init_into_class: false\n```\n\n----------------------------------------\n\nTITLE: AfterValidator Annotated Pattern (Mutate)\nDESCRIPTION: Example of using `AfterValidator` with the annotated pattern to mutate the validated value by doubling it. Requires `typing.Annotated` and `pydantic.AfterValidator`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel\n\n\ndef double_number(value: int) -> int:\n    return value * 2\n\n\nclass Model(BaseModel):\n    number: Annotated[int, AfterValidator(double_number)]\n\n\nprint(Model(number=2))\n\n```\n\n----------------------------------------\n\nTITLE: `missing` Validation Error Example (Python)\nDESCRIPTION: This error is raised when required fields are missing from the input value provided for a Pydantic model. The example shows a model with a required field 'x' and attempts to instantiate it without providing any arguments. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_58\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing'\n```\n\n----------------------------------------\n\nTITLE: Dataclass Constraints with Pydantic\nDESCRIPTION: Demonstrates using Pydantic's Field within dataclasses to control initialization behavior (`init`, `init_var`) and keyword-only arguments (`kw_only`). Includes an example of a nested model structure and its output. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    bar: str\n    baz: str = Field(init_var=True)\n    qux: str = Field(kw_only=True)\n\n\nclass Model(BaseModel):\n    foo: Foo\n\n\nmodel = Model(foo=Foo('bar', baz='baz', qux='qux'))\nprint(model.model_dump())  # (1)!",
    "chunk_length": 2250
  },
  {
    "chunk_id": 26,
    "source": "pydantic_llms_data",
    "content": "#> {'foo': {'bar': 'bar', 'qux': 'qux'}}\n```\n\n----------------------------------------\n\nTITLE: Model Field Missing Annotation: Python Example\nDESCRIPTION: This error occurs when a field within a Pydantic model lacks a type annotation. The example shows how to catch this error and demonstrates resolving it using ClassVar or ignored_types. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        a = Field('foobar')\n        b = None\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-field-missing-annotation'\n```\n\n----------------------------------------\n\nTITLE: Pydantic V2: Url Type Behavior Example\nDESCRIPTION: Demonstrates the behavior of Pydantic V2's Url types, which use Rust's Url crate and may append slashes to URLs without a path. It shows how to convert Url types to strings. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import AnyUrl\n\nassert str(AnyUrl(url='https://google.com')) == 'https://google.com/'\nassert str(AnyUrl(url='https://google.com/')) == 'https://google.com/'\nassert str(AnyUrl(url='https://google.com/api')) == 'https://google.com/api'\nassert str(AnyUrl(url='https://google.com/api/')) == 'https://google.com/api/'\n```\n\n----------------------------------------\n\nTITLE: Monitor Pydantic with Logfire\nDESCRIPTION: Demonstrates how to integrate Pydantic with Logfire to monitor data validations. Logfire records details of both successful and failed validations, providing insights into validation processes. This example shows setting up Logfire, instrumenting Pydantic, and performing validations on a Pydantic model. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/index.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()\nlogfire.instrument_pydantic()  # (1)!",
    "chunk_length": 2065
  },
  {
    "chunk_id": 27,
    "source": "pydantic_llms_data",
    "content": "class Delivery(BaseModel):\n    timestamp: datetime\n    dimensions: tuple[int, int]\n\n\n# this will record details of a successful validation to logfire\nm = Delivery(timestamp='2020-01-02T03:04:05Z', dimensions=['10', '20'])\nprint(repr(m.timestamp))\n#> datetime.datetime(2020, 1, 2, 3, 4, 5, tzinfo=TzInfo(UTC))\nprint(m.dimensions)\n#> (10, 20)\n\nDelivery(timestamp='2020-01-02T03:04:05Z', dimensions=['10'])  # (2)! ```\n\n----------------------------------------\n\nTITLE: Pydantic: Model Configuration via Class Arguments (Python)\nDESCRIPTION: Demonstrates setting Pydantic model configurations, specifically `frozen=True`, either through an internal `model_config` dictionary or directly as keyword arguments in the class definition. This affects instance immutability and enables editor-level error detection. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    model_config = dict(frozen=True)\n    title: str\n    age: int\n    color: str = 'blue'\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel, frozen=True):\n    title: str\n    age: int\n    color: str = 'blue'\n```\n\n----------------------------------------\n\nTITLE: `missing_sentinel_error` Validation Error Example (Python)\nDESCRIPTION: This error is raised when the experimental `MISSING` sentinel is the only allowed value for a field, and it is not provided during validation. The example defines a model field `f` that must be `MISSING` and attempts to validate with a different value. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_62\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\nfrom pydantic.experimental.missing_sentinel import MISSING\n\n\nclass Model(BaseModel):\n    f: MISSING\n\n\ntry:\n    Model(f=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'missing_sentinel_error'\n```\n\n----------------------------------------\n\nTITLE: `model_type` Validation Error Example (Python)\nDESCRIPTION: This error is raised when the input provided to a Pydantic model is neither an instance of the model itself nor a dictionary.",
    "chunk_length": 2262
  },
  {
    "chunk_id": 28,
    "source": "pydantic_llms_data",
    "content": "The example demonstrates successful validation with a dictionary and an existing model instance, followed by an error with a string input. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_64\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int\n\n\n# simply validating a dict\nm = Model.model_validate({'a': 1, 'b': 2})\nprint(m)\n#> a=1 b=2\n\n# validating an existing model instance\nprint(Model.model_validate(m))\n#> a=1 b=2\n\ntry:\n    Model.model_validate('not an object')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'model_type'\n```\n\n----------------------------------------\n\nTITLE: Pydantic BaseModel with dict json_schema_extra\nDESCRIPTION: Demonstrates using a dictionary with `json_schema_extra` in Pydantic's `ConfigDict` to add custom information, such as examples, to the generated JSON schema for a model. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    a: str\n\n    model_config = ConfigDict(json_schema_extra={'examples': [{'a': 'Foo'}]})\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n```\n\n----------------------------------------\n\nTITLE: Model Methods and Configuration\nDESCRIPTION: Details on new arguments for model methods like `.dict()` and `.json()`, and configuration options for `BaseSettings`. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_294\n\nLANGUAGE: APIDOC\nCODE:\n```\nModel Methods:\n  - Added `by_alias` argument to `.dict()` and `.json()` model methods. BaseSettings Configuration:\n  - Added `case_insensitive` option to `BaseSettings` `Config`. Model Copying:\n  - Added deep copy support for `BaseModel.copy()`. ```\n\n----------------------------------------\n\nTITLE: Decimal Constraints with Pydantic\nDESCRIPTION: Shows how to use Pydantic's Field to constrain Decimal types, specifying the maximum number of digits and decimal places allowed.",
    "chunk_length": 2116
  },
  {
    "chunk_id": 29,
    "source": "pydantic_llms_data",
    "content": "Includes a model definition and instantiation example. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    precise: Decimal = Field(max_digits=5, decimal_places=2)\n\n\nfoo = Foo(precise=Decimal('123.45'))\nprint(foo)\n#> precise=Decimal('123.45')\n```\n\n----------------------------------------\n\nTITLE: Dataclass Dumping to JSON Documentation\nDESCRIPTION: Adds documentation explaining how to dump Pydantic models that wrap or interact with Python dataclasses into JSON format. This guides users on serializing dataclass instances via Pydantic. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_235\n\nLANGUAGE: python\nCODE:\n```\n# Documentation update for serializing dataclasses with Pydantic. # Example scenario:\n# from dataclasses import dataclass\n# @dataclass\n# class MyData:\n#     value: int\n# \n# class ModelWithDataclass(BaseModel):\n#     data: MyData\n# \n# model = ModelWithDataclass(data=MyData(value=10))\n# print(model.json()) # Demonstrates how dataclass fields are handled\n```\n\n----------------------------------------\n\nTITLE: `multiple_of` Validation Error Example (Python)\nDESCRIPTION: This error is raised when an input value does not satisfy the `multiple_of` constraint defined for a field. The example defines a model with an integer field `x` that must be a multiple of 5, and attempts to validate it with the value 1. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_66\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(multiple_of=5)\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'multiple_of'\n```\n\n----------------------------------------\n\nTITLE: Pydantic init_forbid_extra Example\nDESCRIPTION: Illustrates Pydantic's default behavior of ignoring extra arguments passed to a model's constructor.",
    "chunk_length": 2075
  },
  {
    "chunk_id": 30,
    "source": "pydantic_llms_data",
    "content": "Setting `init_forbid_extra` to true, or configuring `extra='forbid'`, will cause an error for unexpected keyword arguments. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Model(BaseModel):\n    a: int = 1\n\n\nModel(unrelated=2)\n```\n\n----------------------------------------\n\nTITLE: Debug Pydantic Models with Python-devtools\nDESCRIPTION: This snippet demonstrates how to use the `debug()` function from the `python-devtools` library to inspect Pydantic `BaseModel` instances. It shows the difference in output compared to a standard `print()` statement, offering more detailed and readable debugging information. Requires `pydantic` and `python-devtools` to be installed. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/devtools.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom devtools import debug\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    street: str\n    country: str\n    lat: float\n    lng: float\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    signup_ts: datetime\n    friends: list[int]\n    address: Address\n\n\nuser = User(\n    id='123',\n    name='John Doe',\n    signup_ts='2019-06-01 12:22',\n    friends=[1234, 4567, 7890],\n    address=dict(street='Testing', country='uk', lat=51.5, lng=0),\n)\ndebug(user)\nprint('\\nshould be much easier read than:\\n')\nprint('user:', user)\n```\n\n----------------------------------------\n\nTITLE: `multiple_argument_values` Validation Error Example (Python)\nDESCRIPTION: This error occurs when multiple values are provided for a single argument when calling a function decorated with `validate_call`. The example defines a function `foo` that accepts argument `a` and attempts to call it with both a positional and a keyword argument for `a`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_65\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int):\n    return a\n\n\ntry:\n    foo(1, a=2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'multiple_argument_values'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Private Attributes Support\nDESCRIPTION: Adds support for private attributes (those starting with `__`) within Pydantic models.",
    "chunk_length": 2381
  },
  {
    "chunk_id": 31,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_212\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nclass PrivateAttrModel(BaseModel):\n    public_field: str\n    __private_field: int = 10\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        # Accessing private field after initialization\n        self._private_field_value = self.__private_field\n\n# model = PrivateAttrModel(public_field='hello', __private_field=20)\n# print(model.public_field)\n# print(model._private_field_value) # Accessing the stored private value\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Dataclass Field Validator Example\nDESCRIPTION: Demonstrates using `@field_validator` in a Pydantic dataclass to transform input data. It shows how to convert an integer to a zero-padded string for a product ID field before validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import field_validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass DemoDataclass:\n    product_id: str  # should be a five-digit string, may have leading zeros\n\n    @field_validator('product_id', mode='before')\n    @classmethod\n    def convert_int_serial(cls, v):\n        if isinstance(v, int):\n            v = str(v).zfill(5)\n        return v\n\n\nprint(DemoDataclass(product_id='01234'))\n#> DemoDataclass(product_id='01234')\nprint(DemoDataclass(product_id=2468))\n#> DemoDataclass(product_id='02468')\n```\n\n----------------------------------------\n\nTITLE: Pydantic Valid Model Serializer Signatures\nDESCRIPTION: Provides examples of valid signatures for Pydantic's model_serializer decorator, covering different modes ('plain', 'wrap') and argument inclusions (self, handler, info). SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import SerializerFunctionWrapHandler, SerializationInfo, model_serializer\n\n# an instance method with the default mode or `mode='plain'`\n@model_serializer  # or model_serializer(mode='plain')\ndef mod_ser(self, info: SerializationInfo): ...",
    "chunk_length": 2183
  },
  {
    "chunk_id": 32,
    "source": "pydantic_llms_data",
    "content": "# an instance method with `mode='wrap'`\n@model_serializer(mode='wrap')\ndef mod_ser(self, handler: SerializerFunctionWrapHandler, info: SerializationInfo): ... # For all of these, you can also choose to omit the `info` argument, for example:\n@model_serializer(mode='plain')\ndef mod_ser(self): ... @model_serializer(mode='wrap')\ndef mod_ser(self, handler: SerializerFunctionWrapHandler): ... ```\n\n----------------------------------------\n\nTITLE: Instantiate and Validate Pydantic Model\nDESCRIPTION: Shows how to create an instance of a Pydantic model, including how Pydantic handles data coercion (e.g., string to integer). It highlights that instantiation performs parsing and validation, raising ValidationError on failure. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nuser = User(id='123')\n```\n\n----------------------------------------\n\nTITLE: Pydantic Datetime Parsing Example\nDESCRIPTION: Illustrates Pydantic's ability to parse various string and numeric formats into Python's datetime.datetime objects, including ISO 8601 with timezone information. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Event(BaseModel):\n    dt: datetime = None\n\n\nevent = Event(dt='2032-04-23T10:20:30.400+02:30')\n\nprint(event.model_dump())\n\"\"\"\n{'dt': datetime.datetime(2032, 4, 23, 10, 20, 30, 400000, tzinfo=TzInfo(9000))}\n\"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Create Generic Pydantic Response Model\nDESCRIPTION: Demonstrates creating a generic Pydantic model `Response` that can wrap data of any type. It shows usage with different data types and includes error handling for validation failures. Examples cover Python 3.9+ syntax using `typing.Generic` and Python 3.12+ syntax with new type parameter declarations. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nDataT = TypeVar('DataT')  # (1)!",
    "chunk_length": 2182
  },
  {
    "chunk_id": 33,
    "source": "pydantic_llms_data",
    "content": "class DataModel(BaseModel):\n    number: int\n\n\nclass Response(BaseModel, Generic[DataT]):  # (2)! data: DataT  # (3)! print(Response[int](data=1))\n#> data=1\nprint(Response[str](data='value'))\n#> data='value'\nprint(Response[str](data='value').model_dump())\n#> {'data': 'value'}\n\ndata = DataModel(number=1)\nprint(Response[DataModel](data=data).model_dump())\n#> {'data': {'number': 1}}\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Response[int]\n    data\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]\n    \"\"\"\n\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass DataModel(BaseModel):\n    number: int\n\n\nclass Response[DataT](BaseModel):  # (1)! data: DataT  # (2)! print(Response[int](data=1))\n#> data=1\nprint(Response[str](data='value'))\n#> data='value'\nprint(Response[str](data='value').model_dump())\n#> {'data': 'value'}\n\ndata = DataModel(number=1)\nprint(Response[DataModel](data=data).model_dump())\n#> {'data': {'number': 1}}\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Response[int]\n    data\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: `mapping_type` Validation Error Example (Python)\nDESCRIPTION: This error occurs when a problem arises during validation due to a failure in a call to methods from the Mapping protocol, like `.items()`. The example demonstrates a custom Mapping class that raises an error during item access. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_57\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import Mapping\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass BadMapping(Mapping):\n    def items(self):\n        raise ValueError()\n\n    def __iter__(self):\n        raise ValueError()\n\n    def __getitem__(self, key):\n        raise ValueError()\n\n    def __len__(self):\n        return 1\n\n\nclass Model(BaseModel):\n    x: dict[str, str]\n\n\ntry:\n    Model(x=BadMapping())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'mapping_type'\n```\n\n----------------------------------------\n\nTITLE: Pydantic type for Any Class Validation\nDESCRIPTION: Demonstrates using `type` in Pydantic models to allow any class as a field value, with examples showing valid class inputs and an invalid instance input.",
    "chunk_length": 2615
  },
  {
    "chunk_id": 34,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_22\n\nLANGUAGE: Python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass LenientSimpleModel(BaseModel):\n    any_class_goes: type\n\n\nLenientSimpleModel(any_class_goes=int)\nLenientSimpleModel(any_class_goes=Foo)\ntry:\n    LenientSimpleModel(any_class_goes=Foo())\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for LenientSimpleModel\n    any_class_goes\n      Input should be a type [type=is_type, input_value=<__main__.Foo object at 0x0123456789ab>, input_type=Foo]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Validate XML Data with Pydantic\nDESCRIPTION: Demonstrates how to parse and validate data from an XML file using Python's `xml.etree.ElementTree` module and a Pydantic `BaseModel`. The example defines a `Person` model and extracts data from XML elements for validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#_snippet_11\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\"?>\n<person>\n    <name>John Doe</name>\n    <age>30</age>\n    <email>john@example.com</email>\n</person>\n```\n\nLANGUAGE: python\nCODE:\n```\nimport xml.etree.ElementTree as ET\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\ntree = ET.parse('person.xml').getroot()\ndata = {child.tag: child.text for child in tree}\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```\n\n----------------------------------------\n\nTITLE: `model_attributes_type` Validation Error Example (Python)\nDESCRIPTION: This error occurs when the input value is not a valid dictionary, model instance, or an object from which fields can be extracted. The example shows successful validation with a dictionary and a custom object, then demonstrates the error with an invalid string input. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_63\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int\n\n\n# simply validating a dict\nprint(Model.model_validate({'a': 1, 'b': 2}))\n#> a=1 b=2\n\n\nclass CustomObj:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n\n# using from attributes to extract fields from an objects\nprint(Model.model_validate(CustomObj(3, 4), from_attributes=True))\n#> a=3 b=4\n\ntry:\n    Model.model_validate('not an object', from_attributes=True)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'model_attributes_type'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Field Serializer Incorrect Signature\nDESCRIPTION: Shows an unrecognized signature for Pydantic's field_serializer function.",
    "chunk_length": 2874
  },
  {
    "chunk_id": 35,
    "source": "pydantic_llms_data",
    "content": "This example uses a field_serializer with no arguments, which is invalid and raises a PydanticUserError. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, field_serializer\n\ntry:\n\n    class Model(BaseModel):\n        x: int\n\n        @field_serializer('x')\n        def no_args():\n            return 'x'\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'field-serializer-signature'\n```\n\n----------------------------------------\n\nTITLE: Run Tests and Linting\nDESCRIPTION: This command runs the full suite of Pydantic's automated tests and linting checks. It's essential to run this locally to ensure your changes haven't introduced regressions. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmake\n```\n\n----------------------------------------\n\nTITLE: Push Release Changes with Python Script\nDESCRIPTION: Executes the script to push release-related changes. This action creates a pull request, applies a release label, and opens a draft release on GitHub. SOURCE: https://github.com/pydantic/pydantic/blob/main/release/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nuv run release/push.py\n```\n\n----------------------------------------\n\nTITLE: SchemaExtraCallable for BaseConfig Type Hints\nDESCRIPTION: Ensures `SchemaExtraCallable` is always defined, which helps in getting correct type hints for `BaseConfig`. This is an internal improvement for better developer experience and static analysis. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_224\n\nLANGUAGE: python\nCODE:\n```\n# Internal Pydantic change related to schema generation and type hinting. # Affects how BaseConfig interacts with schema generation functions. ```\n\n----------------------------------------\n\nTITLE: Handling Deprecation Warnings in Validators\nDESCRIPTION: Provides an example of how to access a deprecated field within a Pydantic validator while suppressing the deprecation warning using `warnings.catch_warnings` and `warnings.simplefilter`.",
    "chunk_length": 2146
  },
  {
    "chunk_id": 36,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_33\n\nLANGUAGE: Python\nCODE:\n```\nimport warnings\n\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, Field, model_validator\n\n\nclass Model(BaseModel):\n    deprecated_field: int = Field(deprecated='This is deprecated')\n\n    @model_validator(mode='after')\n    def validate_model(self) -> Self:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', DeprecationWarning)\n            self.deprecated_field = self.deprecated_field * 2\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic V2: Mypy Plugin Configuration\nDESCRIPTION: Shows how to configure Mypy to use Pydantic V2's Mypy plugin, and optionally the V1 plugin if needed for compatibility. Configuration is provided for both mypy.ini and pyproject.toml. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_33\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\nplugins = pydantic.mypy, pydantic.v1.mypy  # include `.v1.mypy` if required. ```\n\n----------------------------------------\n\nTITLE: JSON Mode Serialization with model_dump_json()\nDESCRIPTION: Shows how to serialize Pydantic models directly to a JSON-encoded string using `model_dump_json()`. Includes an example with pretty-printing using `indent=2` and highlights Pydantic's support for various data types. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: tuple[int, ...]\n\n\nclass FooBarModel(BaseModel):\n    foo: datetime\n    bar: BarModel\n\n\nm = FooBarModel(foo=datetime(2032, 6, 1, 12, 13, 14), bar={'whatever': (1, 2)})\n\nprint(m.model_dump_json(indent=2))\n```\n\n----------------------------------------\n\nTITLE: JSON Schema for Person Data\nDESCRIPTION: An example JSON Schema defining the structure for a 'Person' object. It includes properties like first name, last name, age, pets, and a comment, along with type definitions and required fields.",
    "chunk_length": 2096
  },
  {
    "chunk_id": 37,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/datamodel_code_generator.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$id\": \"person.json\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"first_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"last_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"pets\": {\n      \"type\": \"array\",\n      \"items\": [\n        {\n          \"$ref\": \"#/definitions/Pet\"\n        }\n      ]\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  },\n  \"required\": [\n      \"first_name\",\n      \"last_name\"\n  ],\n  \"definitions\": {\n    \"Pet\": {\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"age\": {\n          \"type\": \"integer\"\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuration for Standard Library Dataclasses\nDESCRIPTION: Shows how to configure standard library dataclasses using the `__pydantic_config__` class attribute with `ConfigDict`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom pydantic import ConfigDict\n\n\n@dataclass\nclass User:\n    __pydantic_config__ = ConfigDict(strict=True)\n\n    id: int\n    name: str = 'John Doe'\n\n```\n\n----------------------------------------\n\nTITLE: Handle bytes_invalid_encoding Validation Error in Pydantic\nDESCRIPTION: Details the 'bytes_invalid_encoding' error when bytes data is invalid under the configured encoding, using hex encoding as an example. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes\n    model_config = {'val_json_bytes': 'hex'}\n\n\ntry:\n    Model(x=b'a')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bytes_invalid_encoding'\n```\n\n----------------------------------------\n\nTITLE: Validate TOML Data with Pydantic\nDESCRIPTION: Shows how to parse and validate data from a TOML configuration file using Python's `tomllib` module and a Pydantic `BaseModel`.",
    "chunk_length": 2407
  },
  {
    "chunk_id": 38,
    "source": "pydantic_llms_data",
    "content": "The example defines a `Person` model and validates the loaded TOML data. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\nname = \"John Doe\"\nage = 30\nemail = \"john@example.com\"\n```\n\nLANGUAGE: python\nCODE:\n```\nimport tomllib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.toml', 'rb') as f:\n    data = tomllib.load(f)\n\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Valid Field Serializer Signatures\nDESCRIPTION: Provides examples of valid signatures for Pydantic's field_serializer decorator, covering different modes ('plain', 'wrap') and argument inclusions (self, value, handler, info). SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import FieldSerializationInfo, SerializerFunctionWrapHandler, field_serializer\n\n# an instance method with the default mode or `mode='plain'`\n@field_serializer('x')  # or @field_serializer('x', mode='plain')\ndef ser_x(self, value: Any, info: FieldSerializationInfo): ... # a static method or function with the default mode or `mode='plain'`\n@field_serializer('x')  # or @field_serializer('x', mode='plain')\n@staticmethod\ndef ser_x(value: Any, info: FieldSerializationInfo): ... # equivalent to\ndef ser_x(value: Any, info: FieldSerializationInfo): ... serializer('x')(ser_x)\n\n# an instance method with `mode='wrap'`\n@field_serializer('x', mode='wrap')\ndef ser_x(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ... # a static method or function with `mode='wrap'`\n@field_serializer('x', mode='wrap')\n@staticmethod\ndef ser_x(value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ... # equivalent to\ndef ser_x(value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...",
    "chunk_length": 2069
  },
  {
    "chunk_id": 39,
    "source": "pydantic_llms_data",
    "content": "serializer('x')(ser_x)\n\n# For all of these, you can also choose to omit the `info` argument, for example:\n@field_serializer('x')\ndef ser_x(self, value: Any): ... @field_serializer('x', mode='wrap')\ndef ser_x(self, value: Any, handler: SerializerFunctionWrapHandler): ... ```\n\n----------------------------------------\n\nTITLE: Model Field Missing Annotation (ClassVar): Python Example\nDESCRIPTION: Demonstrates resolving the 'model-field-missing-annotation' error by annotating a field as a ClassVar, indicating it's not intended to be a model field. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: ClassVar[str]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Dataclass Model Validators and Post-Initialization Hooks\nDESCRIPTION: Illustrates the execution order of `@model_validator` (both `before` and `after` modes) and the `__post_init__` method in a Pydantic dataclass, showing how `ArgsKwargs` is used for `before` validators. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import ArgsKwargs\nfrom typing_extensions import Self\n\nfrom pydantic import model_validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Birth:\n    year: int\n    month: int\n    day: int\n\n\n@dataclass\nclass User:\n    birth: Birth\n\n    @model_validator(mode='before')\n    @classmethod\n    def before(cls, values: ArgsKwargs) -> ArgsKwargs:\n        print(f'First: {values}')  # (1)! \"\"\"\n        First: ArgsKwargs((), {'birth': {'year': 1995, 'month': 3, 'day': 2}})\n        \"\"\"\n        return values\n\n    @model_validator(mode='after')\n    def after(self) -> Self:\n        print(f'Third: {self}')\n        # Third: User(birth=Birth(year=1995, month=3, day=2))\n        return self\n\n    def __post_init__(self):\n        print(f'Second: {self.birth}')\n        # Second: Birth(year=1995, month=3, day=2)\n\n\nuser = User(**{'birth': {'year': 1995, 'month': 3, 'day': 2}})\n```\n\n----------------------------------------\n\nTITLE: Performance: Improve Annotation Application\nDESCRIPTION: Boosts the performance of applying type annotations within Pydantic models.",
    "chunk_length": 2319
  },
  {
    "chunk_id": 40,
    "source": "pydantic_llms_data",
    "content": "This optimization contributes to faster model definition and validation setup. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n# Internal improvements to how type annotations are processed and applied. ```\n\n----------------------------------------\n\nTITLE: Serialization of Date Subclasses\nDESCRIPTION: Illustrates how Pydantic serializes subclasses of standard types like `datetime.date`. The example shows that the subclass's custom properties are not included in the default serialization. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n\nclass MyDate(date):\n    @property\n    def my_date_format(self) -> str:\n        return self.strftime('%d/%m/%Y')\n\n\nclass FooModel(BaseModel):\n    date: date\n\n\nm = FooModel(date=MyDate(2023, 1, 1))\nprint(m.model_dump_json())\n```\n\n----------------------------------------\n\nTITLE: Excluding Fields During Export\nDESCRIPTION: Explains how to use the `exclude=True` parameter on a Pydantic `Field` to prevent that field from being included when exporting the model, for example, using `model_dump()`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str\n    age: int = Field(exclude=True)\n\n\nuser = User(name='John', age=42)\nprint(user.model_dump())  # (1)! #> {'name': 'John'}\n```\n\n----------------------------------------\n\nTITLE: Parametrize Generic Model with `int`\nDESCRIPTION: Shows how to instantiate a generic Pydantic model (`ChildClass`) by providing concrete types for its type variables. This example specifically parameterizes `TypeX` with `int` and demonstrates the resulting object's attribute. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nprint(ChildClass[int](X=1))\n#> X=1\n```\n\n----------------------------------------\n\nTITLE: Settings Priority Documentation\nDESCRIPTION: Improved documentation regarding settings priority and provided mechanisms to easily change it, enhancing flexibility in configuration management.",
    "chunk_length": 2280
  },
  {
    "chunk_id": 41,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_279\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseSettings, SettingsConfigDict\n\nclass AppSettings(BaseSettings):\n    database_url: str\n\n    model_config = SettingsConfigDict(\n        env_file='.env',\n        env_file_encoding='utf-8'\n    )\n```\n\n----------------------------------------\n\nTITLE: Customize Validation with __get_pydantic_core_schema__\nDESCRIPTION: Shows how to customize Pydantic validation for custom types by implementing the `__get_pydantic_core_schema__` class method. This example creates a `Username` type inheriting from `str` and customizes its core schema generation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\n\n\nclass Username(str):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_after_validator_function(cls, handler(str))\n\n\nta = TypeAdapter(Username)\nres = ta.validate_python('abc')\nassert isinstance(res, Username)\nassert res == 'abc'\n\n```\n\n----------------------------------------\n\nTITLE: Model Field Missing Annotation (ignored_types): Python Example\nDESCRIPTION: Shows how to resolve the 'model-field-missing-annotation' error by configuring Pydantic to ignore specific types, preventing them from being treated as model fields. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass IgnoredType:\n    pass\n\n\nclass MyModel(BaseModel):\n    model_config = ConfigDict(ignored_types=(IgnoredType,))\n\n    _a = IgnoredType()\n    _b: int = IgnoredType()\n    _c: IgnoredType\n    _d: IgnoredType = IgnoredType()\n```\n\n----------------------------------------\n\nTITLE: Pydantic Arguments Schema API\nDESCRIPTION: Documentation for the experimental Arguments Schema API in Pydantic.",
    "chunk_length": 2145
  },
  {
    "chunk_id": 42,
    "source": "pydantic_llms_data",
    "content": "This API allows for the generation of schemas that describe function arguments. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/experimental.md#_snippet_1\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.experimental.arguments_schema.generate_arguments_schema:\n  Generates a Pydantic schema from a function's signature. Purpose:\n  This function inspects a given Python function and creates a Pydantic model that represents the function's arguments, including their types, defaults, and validation rules. Parameters:\n  - func: The Python function for which to generate the arguments schema. - **kwargs: Additional keyword arguments to pass to the schema generation process. Returns:\n  A Pydantic model class representing the function's arguments. Example:\n  from typing import Annotated\n  \n  def greet(name: str, age: Annotated[int, 'Age in years'] = 30):\n      print(f\"Hello {name}, you are {age} years old.\")\n  \n  ArgumentsSchema = generate_arguments_schema(greet)\n  \n  # Now ArgumentsSchema can be used to validate input for the greet function:\n  valid_args = ArgumentsSchema(name='Alice', age=25)\n  invalid_args = ArgumentsSchema(name='Bob', age='twenty') # This would raise a ValidationError\n  \n  # Note: Specific parameter details and return types are inferred from the source code. ```\n\n----------------------------------------\n\nTITLE: Import Pydantic V1 Fields Module (>=1.10.17)\nDESCRIPTION: Illustrates importing a module like 'fields' from the Pydantic V1 namespace, specifically for Pydantic versions 1.10.17 and later. This import pattern works within both V1 and V2 installations. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.v1.fields import ModelField\n```\n\n----------------------------------------\n\nTITLE: API: pydantic.main.create_model\nDESCRIPTION: Provides documentation for the `create_model` function, which allows dynamic creation of Pydantic models at runtime. Explains how to define fields with types and default values. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_41\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.main.create_model\n\nCreate a model using runtime information to specify the fields.",
    "chunk_length": 2239
  },
  {
    "chunk_id": 43,
    "source": "pydantic_llms_data",
    "content": "Parameters:\n  - __main__: The name of the model to create. - **field_name: type, default_value, validator, etc.**\n    Fields can be defined as keyword arguments. The value can be a type, a tuple of (type, default_value), or a more complex configuration including validators. Returns:\n  - A new Pydantic BaseModel class. Example:\n```python\nfrom pydantic import BaseModel, create_model\n\nDynamicFoobarModel = create_model('DynamicFoobarModel', foo=str, bar=(int, 123))\n\n# Usage:\ninstance = DynamicFoobarModel(foo='hello')\nprint(instance.foo) # Output: hello\nprint(instance.bar) # Output: 123\n```\n\nRelated:\n  - `pydantic.create_model` (alias for `pydantic.main.create_model`)\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Serializer Incorrect Signature\nDESCRIPTION: Illustrates an unrecognized signature for Pydantic's model_serializer function. This example shows a model_serializer with an incorrect number of arguments, leading to a PydanticUserError. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        def _serialize(self, x, y, z):\n            return self\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-signature'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Badges in HTML\nDESCRIPTION: Illustrates how to integrate Pydantic version badges into HTML content. The provided HTML snippets create clickable badges that link to the Pydantic website. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_14\n\nLANGUAGE: html\nCODE:\n```\n<a href=\"https://pydantic.dev\"><img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\" alt=\"Pydantic Version 1\" style=\"max-width:100%;\"></a>\n\n<a href=\"https://pydantic.dev\"><img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\" alt=\"Pydantic Version 2\" style=\"max-width:100%;\"></a>\n```\n\n----------------------------------------\n\nTITLE: mkdocstrings Cross-Reference for Pydantic API\nDESCRIPTION: Configure mkdocstrings within MkDocs to link to Pydantic's API documentation.",
    "chunk_length": 2373
  },
  {
    "chunk_id": 44,
    "source": "pydantic_llms_data",
    "content": "This is achieved by specifying the Pydantic object inventory URL in the mkdocstrings plugin configuration in your `mkdocs.yml` file. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/documentation.md#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nplugins:\n- mkdocstrings:\n    handlers:\n      python:\n        import:\n        - https://docs.pydantic.dev/latest/objects.inv\n```\n\n----------------------------------------\n\nTITLE: Pydantic Literal Validation\nDESCRIPTION: Demonstrates using typing.Literal to enforce specific string values for Pydantic model fields. Includes examples of valid inputs and how validation errors are raised for invalid inputs. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Pie(BaseModel):\n    flavor: Literal['apple', 'pumpkin']\n\n\nPie(flavor='apple')\nPie(flavor='pumpkin')\ntry:\n    Pie(flavor='cherry')\nexcept ValidationError as e:\n    print(str(e))\n    \n```\n\n----------------------------------------\n\nTITLE: Pydantic validate_call Decorator Usage\nDESCRIPTION: Demonstrates how to use the @validate_call decorator to validate function arguments against type annotations. Includes examples of correct usage, type coercion, and handling validation errors. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef repeat(s: str, count: int, *, separator: bytes = b'') -> bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n#> b'hellohellohello'\n\nb = repeat('x', '4', separator=b' ')\nprint(b)\n#> b'x x x x'\n\ntry:\n    c = repeat('hello', 'wrong')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for repeat\n    1\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='wrong', input_type=str]\n    \"\"\"\n\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nfrom pydantic import validate_call\n\n\n@validate_call\ndef greater_than(d1: date, d2: date, *, include_equal=False) -> date:  # (1)!",
    "chunk_length": 2278
  },
  {
    "chunk_id": 45,
    "source": "pydantic_llms_data",
    "content": "if include_equal:\n        return d1 >= d2\n    else:\n        return d1 > d2\n\n\nd1 = '2000-01-01'  # (2)! d2 = date(2001, 1, 1)\ngreater_than(d1, d2, include_equal=True)\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Dataclass Model Validator and Post-Initialization Hooks\nDESCRIPTION: Illustrates the execution order of `@model_validator` (before/after) and the `__post_init__` method in Pydantic dataclasses. It shows how data flows through these hooks during initialization, with a note on the `ArgsKwargs` type for 'before' validators. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import ArgsKwargs\nfrom typing_extensions import Self\n\nfrom pydantic import model_validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Birth:\n    year: int\n    month: int\n    day: int\n\n\n@dataclass\nclass User:\n    birth: Birth\n\n    @model_validator(mode='before')\n    @classmethod\n    def before(cls, values: ArgsKwargs) -> ArgsKwargs:\n        print(f'First: {values}')  # (1)! \"\"\"\n        First: ArgsKwargs((), {'birth': {'year': 1995, 'month': 3, 'day': 2}})\n        \"\"\"\n        return values\n\n    @model_validator(mode='after')\n    def after(self) -> Self:\n        print(f'Third: {self}')\n        #> Third: User(birth=Birth(year=1995, month=3, day=2))\n        return self\n\n    def __post_init__(self):\n        print(f'Second: {self.birth}')\n        #> Second: Birth(year=1995, month=3, day=2)\n\n\nuser = User(**{'birth': {'year': 1995, 'month': 3, 'day': 2}})\n\n# 1. Unlike Pydantic models, the `values` parameter is of type [`ArgsKwargs`][pydantic_core.ArgsKwargs]\n```\n\n----------------------------------------\n\nTITLE: Field Representation Control with Pydantic\nDESCRIPTION: Explains how to use the `repr` parameter in Pydantic's Field to include or exclude fields from the model's string representation. Provides an example demonstrating this functionality. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(repr=True)  # (1)!",
    "chunk_length": 2194
  },
  {
    "chunk_id": 46,
    "source": "pydantic_llms_data",
    "content": "age: int = Field(repr=False)\n\n\nuser = User(name='John', age=42)\nprint(user)\n#> name='John'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Pipeline API\nDESCRIPTION: Documentation for the experimental Pipeline API in Pydantic. This API is designed for building and managing data processing pipelines. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/experimental.md#_snippet_0\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.experimental.pipeline._Pipeline:\n  A class for defining and executing data processing pipelines. Usage:\n  Define a pipeline by subclassing _Pipeline and implementing the steps. Example:\n  class MyPipeline(_Pipeline):\n      def step1(self, data):\n          # Process data\n          return processed_data\n      \n      def step2(self, data):\n          # Further process data\n          return final_data\n  \n  pipeline = MyPipeline()\n  result = pipeline.run(initial_data)\n  \n  # Note: Specific methods, parameters, and return types are inferred from the source code. ```\n\n----------------------------------------\n\nTITLE: Pydantic V2: Mypy Plugin Configuration\nDESCRIPTION: Shows how to configure Mypy to use Pydantic V2's Mypy plugin, and optionally the V1 plugin if needed for compatibility. Configuration is provided for both mypy.ini and pyproject.toml. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_34\n\nLANGUAGE: toml\nCODE:\n```\n[tool.mypy]\nplugins = [\n    \"pydantic.mypy\",\n    \"pydantic.v1.mypy\",  # include `.v1.mypy` if required. ]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Pipeline API Usage\nDESCRIPTION: Illustrates the experimental 'pipeline' API for composing validation, constraints, and transformations in a type-safe manner. It shows how to use `validate_as` with various methods like `str_lower`, `gt`, `str_pattern`, `transform`, `predicate`, and combining steps with `|` or `&`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BaseModel\nfrom pydantic.experimental.pipeline import validate_as\n\n\nclass User(BaseModel):\n    name: Annotated[str, validate_as(str).str_lower()]  # (1)!",
    "chunk_length": 2283
  },
  {
    "chunk_id": 47,
    "source": "pydantic_llms_data",
    "content": "age: Annotated[int, validate_as(int).gt(0)]  # (2)! username: Annotated[str, validate_as(str).str_pattern(r'[a-z]+')]  # (3)! password:\n        Annotated[\n            str,\n            validate_as(str)\n            .transform(str.lower)\n            .predicate(lambda x: x != 'password'),  # (4)! ]\n    favorite_number: Annotated[\n        int,\n        (validate_as(int) | validate_as(str).str_strip().validate_as(int)).gt(\n            0\n        ),\n    ]  # (5)! friends: Annotated[list[User], validate_as(...).len(0, 100)]  # (6)! bio:\n        Annotated[\n            datetime,\n            validate_as(int)\n            .transform(lambda x: x / 1_000_000)\n            .validate_as(...),  # (8)! ]\n```\n\n----------------------------------------\n\nTITLE: datetime_object_invalid Pydantic Validation Example\nDESCRIPTION: Demonstrates the 'datetime_object_invalid' error, raised when a datetime object has an invalid tzinfo implementation. It shows how to define a custom tzinfo and trigger this validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime, tzinfo\n\nfrom pydantic import AwareDatetime, BaseModel, ValidationError\n\n\nclass CustomTz(tzinfo):\n    # utcoffset is not implemented! def tzname(self, _dt):\n        return 'CustomTZ'\n\n\nclass Model(BaseModel):\n    x: AwareDatetime\n\n\ntry:\n    Model(x=datetime(2023, 1, 1, tzinfo=CustomTz()))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_object_invalid'\n```\n\n----------------------------------------\n\nTITLE: Demonstrate `needs_python_object` Pydantic Validation Error in Python\nDESCRIPTION: This error is raised when validation is attempted from a format that cannot be converted to a Python object. For example, attempting to validate a string as a BaseModel class. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_67\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    bm: type[BaseModel]\n\n\ntry:\n    Model.model_validate_json(json.dumps({'bm': 'not a basemodel class'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'needs_python_object'\n```\n\n----------------------------------------\n\nTITLE: Pydantic type[T] Subclass Validation\nDESCRIPTION: Illustrates using `type[T]` in Pydantic models to enforce that a field must be a subclass of a specified type `T`, with examples of valid and invalid inputs.",
    "chunk_length": 2552
  },
  {
    "chunk_id": 48,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_21\n\nLANGUAGE: Python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Other:\n    pass\n\n\nclass SimpleModel(BaseModel):\n    just_subclasses: type[Foo]\n\n\nSimpleModel(just_subclasses=Foo)\nSimpleModel(just_subclasses=Bar)\ntry:\n    SimpleModel(just_subclasses=Other)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SimpleModel\n    just_subclasses\n      Input should be a subclass of Foo [type=is_subclass_of, input_value=<class '__main__.Other'>, input_type=type]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Decimal Validation and Serialization\nDESCRIPTION: Demonstrates Pydantic's handling of the `decimal.Decimal` type. It explains validation by converting to string and then to Decimal, and serialization to strings. Includes an example using `PlainSerializer` to override default serialization behavior, allowing `Decimal` to be serialized as a float. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, PlainSerializer\n\n\nclass Model(BaseModel):\n    x: Decimal\n    y: Annotated[\n        Decimal,\n        PlainSerializer(\n            lambda x: float(x), return_type=float, when_used='json'\n        ),\n    ]\n\n\nmy_model = Model(x=Decimal('1.1'), y=Decimal('2.1'))\n\nprint(my_model.model_dump())\nprint(my_model.model_dump(mode='json'))\nprint(my_model.model_dump_json())\n```\n\n----------------------------------------\n\nTITLE: Pydantic Field Validator Incorrect Signature\nDESCRIPTION: Demonstrates an unrecognized signature for Pydantic's field_validator or model_validator functions. This example shows a field_validator with an incorrect signature, leading to a PydanticUserError. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator('a')\n        @classmethod\n        def check_a(cls):\n            return 'a'\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-signature'\n```\n\n----------------------------------------\n\nTITLE: Pydantic V1 vs V2 JSON Key Serialization\nDESCRIPTION: Compares how Pydantic V1 and V2 serialize dictionary keys, particularly `None` values, to JSON.",
    "chunk_length": 2595
  },
  {
    "chunk_id": 49,
    "source": "pydantic_llms_data",
    "content": "It demonstrates the output differences between V1's `.json()` and V2's `.model_dump_json()` methods. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel as V2BaseModel\nfrom pydantic.v1 import BaseModel as V1BaseModel\n\n\nclass V1Model(V1BaseModel):\n    a: dict[Optional[str], int]\n\n\nclass V2Model(V2BaseModel):\n    a: dict[Optional[str], int]\n\n\nv1_model = V1Model(a={None: 123})\nv2_model = V2Model(a={None: 123})\n\n# V1\nprint(v1_model.json())\n#> {\"a\": {\"null\": 123}}\n\n# V2\nprint(v2_model.model_dump_json())\n#> {\"a\":{\"None\":123}}\n```\n\n----------------------------------------\n\nTITLE: Pydantic V1 Validator Incorrect Signature\nDESCRIPTION: Illustrates an unsupported signature for Pydantic V1-style validators, which raises a PydanticUserError. This example shows how an incorrect parameter in a validator method can cause issues. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\n\nfrom pydantic import BaseModel, PydanticUserError, validator\n\nwarnings.filterwarnings('ignore', category=DeprecationWarning)\n\ntry:\n\n    class Model(BaseModel):\n        a: int\n\n        @validator('a')\n        def check_a(cls, value, foo):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-v1-signature'\n```\n\n----------------------------------------\n\nTITLE: Pydantic BaseModel with Callable json_schema_extra\nDESCRIPTION: Illustrates how to use a callable function with `json_schema_extra` to dynamically modify the JSON schema. This example shows a function that removes the 'default' key from the schema. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, Field\n\n\ndef pop_default(s):\n    s.pop('default')\n\n\nclass Model(BaseModel):\n    a: int = Field(default=1, json_schema_extra=pop_default)\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n```\n\n----------------------------------------\n\nTITLE: Pydantic Field Customization with Field Parameters\nDESCRIPTION: Demonstrates using Pydantic's Field function to customize model fields with parameters like description, examples, title, and json_schema_extra.",
    "chunk_length": 2369
  },
  {
    "chunk_id": 50,
    "source": "pydantic_llms_data",
    "content": "This allows for richer metadata and control over the generated JSON schema. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, EmailStr, Field, SecretStr\n\n\nclass User(BaseModel):\n    age: int = Field(description='Age of the user')\n    email: EmailStr = Field(examples=['marcelo@mail.com'])\n    name: str = Field(title='Username')\n    password: SecretStr = Field(\n        json_schema_extra={\n            'title': 'Password',\n            'description': 'Password of the user',\n            'examples': ['123456'],\n        }\n    )\n\n\nprint(json.dumps(User.model_json_schema(), indent=2))\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"properties\": {\n    \"age\": {\n      \"description\": \"Age of the user\",\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    },\n    \"email\": {\n      \"examples\": [\n        \"marcelo@mail.com\"\n      ],\n      \"format\": \"email\",\n      \"title\": \"Email\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"title\": \"Username\",\n      \"type\": \"string\"\n    },\n    \"password\": {\n      \"description\": \"Password of the user\",\n      \"examples\": [\n        \"123456\"\n      ],\n      \"format\": \"password\",\n      \"title\": \"Password\",\n      \"type\": \"string\",\n      \"writeOnly\": true\n    }\n  },\n  \"required\": [\n    \"age\",\n    \"email\",\n    \"name\",\n    \"password\"\n  ],\n  \"title\": \"User\",\n  \"type\": \"object\"\n}\n```\n\n----------------------------------------\n\nTITLE: Pydantic TypeAdapter with TypedDict Schema\nDESCRIPTION: Demonstrates using TypeAdapter to create a schema from a TypedDict, including validation of datetime and bytes, serialization, and JSON schema generation. It shows how to handle different input types and output formats. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Meeting(TypedDict):\n    when: datetime\n    where: bytes\n    why: NotRequired[str]\n\n\nmeeting_adapter = TypeAdapter(Meeting)\nm = meeting_adapter.validate_python(\n    {'when': '2020-01-01T12:00', 'where': 'home'}\n) # (1)!",
    "chunk_length": 2192
  },
  {
    "chunk_id": 51,
    "source": "pydantic_llms_data",
    "content": "print(m)\n#> {'when': datetime.datetime(2020, 1, 1, 12, 0), 'where': b'home'}\nmeeting_adapter.dump_python(m, exclude={'where'})  # (2)! print(meeting_adapter.json_schema())  # (3)! \"\"\"\n{\n    'properties': {\n        'when': {'format': 'date-time', 'title': 'When', 'type': 'string'},\n        'where': {'format': 'binary', 'title': 'Where', 'type': 'string'},\n        'why': {'title': 'Why', 'type': 'string'},\n    },\n    'required': ['when', 'where'],\n    'title': 'Meeting',\n    'type': 'object',\n}\n\"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Discriminator No Field: Union Example\nDESCRIPTION: Illustrates the 'discriminator-no-field' error, which arises when a model within a discriminated union (using `typing.Union` and `pydantic.Field(discriminator=...)`) does not define the specified discriminator field. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-no-field'\n```\n\n----------------------------------------\n\nTITLE: BaseModel Methods and Properties\nDESCRIPTION: Reference for core methods and attributes of Pydantic's BaseModel, covering data validation, serialization, model construction, copying, schema generation, and field introspection. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_8\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic BaseModel Methods and Properties:\n\nmodel_validate(obj: Any)\n  - Validates the given object against the Pydantic model. model_validate_json(json_data: str)\n  - Validates the given JSON data against the Pydantic model. model_construct(**values: Any)\n  - Creates models without running validation.",
    "chunk_length": 2051
  },
  {
    "chunk_id": 52,
    "source": "pydantic_llms_data",
    "content": "model_dump(**kwargs: Any)\n  - Returns a dictionary of the model's fields and values. model_dump_json(**kwargs: Any)\n  - Returns a JSON string representation of model_dump(). model_copy(**kwargs: Any)\n  - Returns a copy (by default, shallow copy) of the model. model_json_schema(**kwargs: Any)\n  - Returns a jsonable dictionary representing the model's JSON Schema. model_fields\n  - A mapping between field names and their definitions. model_computed_fields\n  - A mapping between computed field names and their definitions. model_extra\n  - The extra fields set during validation. model_fields_set\n  - The set of fields which were explicitly provided when the model was initialized. model_parametrized_name()\n  - Computes the class name for parametrizations of generic classes. model_post_init()\n  - Performs additional actions after the model is instantiated and all field validators are applied. model_rebuild()\n  - Rebuilds the model schema, supporting recursive generic models. ```\n\n----------------------------------------\n\nTITLE: Pydantic PlainValidator with Annotated Pattern\nDESCRIPTION: Illustrates using `PlainValidator` with `Annotated` to modify input values directly, bypassing subsequent Pydantic validation. This example shows doubling an integer input, and how non-integer inputs are accepted without further type checking. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, PlainValidator\n\n\ndef val_number(value: Any) -> Any:\n    if isinstance(value, int):\n        return value * 2\n    else:\n        return value\n\n\nclass Model(BaseModel):\n    number: Annotated[int, PlainValidator(val_number)]\n\n\nprint(Model(number=4))\n#> number=8\nprint(Model(number='invalid'))  # (1)! #> number='invalid'\n\n```\n\n----------------------------------------\n\nTITLE: Python: Validate Unparametrized Type Variables\nDESCRIPTION: Explains Pydantic's behavior when type variables are left unparametrized, falling back to `Any` or using bounds/defaults.",
    "chunk_length": 2079
  },
  {
    "chunk_id": 53,
    "source": "pydantic_llms_data",
    "content": "Shows validation examples with `TypeVar` constraints and default values. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic\n\nfrom typing_extensions import TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nT = TypeVar('T')\nU = TypeVar('U', bound=int)\nV = TypeVar('V', default=str)\n\n\nclass Model(BaseModel, Generic[T, U, V]):\n    t: T\n    u: U\n    v: V\n\n\nprint(Model(t='t', u=1, v='v'))\n\ntry:\n    Model(t='t', u='u', v=1)\nexcept ValidationError as exc:\n    print(exc)\n```\n\n----------------------------------------\n\nTITLE: Serialize Dictionary with Cyclic Reference (Pydantic)\nDESCRIPTION: Demonstrates Pydantic's default behavior when serializing a Python dictionary containing a cyclic reference. It shows the initial setup of cyclic data and the resulting ValueError raised by TypeAdapter during serialization. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/forward_annotations.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\n# Create data with cyclic references representing the graph 1 -> 2 -> 3 -> 1\nnode_data = {'id': 1, 'children': [{'id': 2, 'children': [{'id': 3}]}]}\nnode_data['children'][0]['children'][0]['children'] = [node_data]\n\ntry:\n    # Try serializing the circular reference as JSON\n    TypeAdapter(dict).dump_json(node_data)\nexcept ValueError as exc:\n    print(exc)\n    \"\"\"\n    Error serializing to JSON: ValueError: Circular reference detected (id repeated)\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: ConfigDict(strict=True) for BaseModel\nDESCRIPTION: Illustrates enabling strict mode globally for a `BaseModel` by setting `model_config = ConfigDict(strict=True)`. This example shows how inputs like string '33' for an integer field and 'yes' for a boolean field will raise `ValidationError`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    name: str\n    age: int\n    is_active: bool\n\n\ntry:\n    User(name='David', age='33', is_active='yes')\nexcept ValidationError as exc:\n    print(exc)\n    \n```\n\n----------------------------------------\n\nTITLE: Custom Configuration for validate_call with arbitrary_types_allowed\nDESCRIPTION: Illustrates how to apply custom configurations to the @validate_call decorator using Pydantic's ConfigDict.",
    "chunk_length": 2535
  },
  {
    "chunk_id": 54,
    "source": "pydantic_llms_data",
    "content": "This example enables arbitrary types, allowing custom classes like 'Foobar' to be passed as arguments. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\nfrom pydantic import ConfigDict, ValidationError, validate_call\n\n\nclass Foobar:\n    def __init__(self, v: str):\n        self.v = v\n\n    def __add__(self, other: 'Foobar') -> str:\n        return f'{self} + {other}'\n\n    def __str__(self) -> str:\n        return f'Foobar({self.v})'\n\n\n@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef add_foobars(a: Foobar, b: Foobar):\n    return a + b\n\n\nc = add_foobars(Foobar('a'), Foobar('b'))\nprint(c)\n# > Foobar(a) + Foobar(b)\n\ntry:\n    add_foobars(1, 2)\nexcept ValidationError as e:\n    print(e)\n    # 2 validation errors for add_foobars\n    # 0\n    #   Input should be an instance of Foobar [type=is_instance_of, input_value=1, input_type=int]\n    # 1\n    #   Input should be an instance of Foobar [type=is_instance_of, input_value=2, input_type=int]\n    # \n```\n\n----------------------------------------\n\nTITLE: Custom Validation with Annotated and GetPydanticSchema\nDESCRIPTION: Shows how to reduce boilerplate for custom type validation using `Annotated` and `GetPydanticSchema`. This example defines a validator that doubles a string input, demonstrating a concise way to apply custom logic. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, GetPydanticSchema\nfrom pydantic_core import core_schema\n\n\nclass Model(BaseModel):\n    y: Annotated[\n        str,\n        GetPydanticSchema(\n            lambda tp, handler: core_schema.no_info_after_validator_function(\n                lambda x: x * 2, handler(tp)\n            )\n        ),\n    ]\n\n\nassert Model(y='ab').y == 'abab'\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Schemas with Custom Generator\nDESCRIPTION: Illustrates how to exclude fields from JSON schema generation that are invalid by overriding `handle_invalid_for_json_schema` to raise `PydanticOmit`.",
    "chunk_length": 2160
  },
  {
    "chunk_id": 55,
    "source": "pydantic_llms_data",
    "content": "Includes an example with a `Callable` field. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\nfrom pydantic_core import PydanticOmit, core_schema\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def handle_invalid_for_json_schema(\n        self, schema: core_schema.CoreSchema, error_info: str\n    ) -> JsonSchemaValue:\n        raise PydanticOmit\n\n\ndef example_callable():\n    return 1\n\n\nclass Example(BaseModel):\n    name: str = 'example'\n    function: Callable = example_callable\n\n\ninstance_example = Example()\n\nvalidation_schema = instance_example.model_json_schema(\n    schema_generator=MyGenerateJsonSchema, mode='validation'\n)\nprint(validation_schema)\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n    'properties': {\n        'name': {'default': 'example', 'title': 'Name', 'type': 'string'}\n    },\n    'title': 'Example',\n    'type': 'object',\n}\n```\n\n----------------------------------------\n\nTITLE: Pydantic Badges in Markdown\nDESCRIPTION: Demonstrates how to embed Pydantic version badges into Markdown files. These badges link to the Pydantic documentation and display the current version status. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_12\n\nLANGUAGE: md\nCODE:\n```\n[![Pydantic v1](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json)](https://pydantic.dev)\n\n[![Pydantic v2](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json)](https://pydantic.dev)\n```\n\n----------------------------------------\n\nTITLE: Basic Pydantic Dataclass Usage\nDESCRIPTION: Demonstrates defining a Pydantic dataclass with basic fields and instantiating it, showcasing automatic type coercion. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n\n\nuser = User(id='42', signup_ts='2032-06-21T12:00')\nprint(user)\n```\n\n----------------------------------------\n\nTITLE: Pydantic Reusable Validators with Annotated Pattern\nDESCRIPTION: Shows how to create reusable validators using the `Annotated` pattern in Pydantic with `AfterValidator`.",
    "chunk_length": 2554
  },
  {
    "chunk_id": 56,
    "source": "pydantic_llms_data",
    "content": "This example defines an `is_even` validator and applies it to different fields and types, including lists, promoting code reuse and cleaner type definitions. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel\n\n\ndef is_even(value: int) -> int:\n    if value % 2 == 1:\n        raise ValueError(f'{value} is not an even number')\n    return value\n\n\nEvenNumber = Annotated[int, AfterValidator(is_even)]\n\n\nclass Model1(BaseModel):\n    my_number: EvenNumber\n\n\nclass Model2(BaseModel):\n    other_number: Annotated[EvenNumber, AfterValidator(lambda v: v + 2)]\n\n\nclass Model3(BaseModel):\n    list_of_even_numbers: list[EvenNumber]  # (1)! # 1. As mentioned in the [annotated pattern](./fields.md#the-annotated-pattern) documentation,\n#    we can also make use of validators for specific parts of the annotation (in this case,\n#    validation is applied for list items, but not the whole list). ```\n\n----------------------------------------\n\nTITLE: Authenticate GitHub CLI\nDESCRIPTION: Authenticates the GitHub CLI with your GitHub account. This is required for making API calls during the release process. SOURCE: https://github.com/pydantic/pydantic/blob/main/release/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngh auth login\n```\n\n----------------------------------------\n\nTITLE: Handle Pydantic JSON Validation Errors\nDESCRIPTION: Illustrates how Pydantic handles invalid JSON data by raising a `ValidationError`. This example shows a JSON object with missing fields, incorrect types, and invalid formats, and how to catch and print the detailed error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt, ValidationError\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_string = pathlib.Path('person.json').read_text()\ntry:\n    person = Person.model_validate_json(json_string)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    3 validation errors for Person\n    name\n    Field required [type=missing, input_value={'age': -30, 'email': 'not-an-email-address'}, input_type=dict]\n        For further information visit https://errors.pydantic.dev/2.10/v/missing\n    age\n    Input should be greater than 0 [type=greater_than, input_value=-30, input_type=int]\n        For further information visit https://errors.pydantic.dev/2.10/v/greater_than\n    email\n    value is not a valid email address: An email address must have an @-sign.",
    "chunk_length": 2655
  },
  {
    "chunk_id": 57,
    "source": "pydantic_llms_data",
    "content": "[type=value_error, input_value='not-an-email-address', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: TypeAdapter Schema Rebuilding with Deferred Build\nDESCRIPTION: Shows how to defer the building of a TypeAdapter's core schema using `defer_build=True` and manually trigger it later with the `rebuild` method. This is useful for types with forward references or expensive schema builds. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/type_adapter.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, TypeAdapter\n\nta = TypeAdapter('MyInt', config=ConfigDict(defer_build=True))\n```\n\n----------------------------------------\n\nTITLE: Pydantic Serialization Alias Only\nDESCRIPTION: Shows how to use `serialization_alias` in Pydantic's `Field` for an alias used exclusively during serialization. The example demonstrates validation using the field name and serialization using the specified alias. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(serialization_alias='username')\n\n\nuser = User(name='johndoe')  # (1)! print(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)! #>\n#> {'username': 'johndoe'}\n```\n\n----------------------------------------\n\nTITLE: Run Code Formatting and Linting\nDESCRIPTION: Executes automated code formatting and linting checks using tools like ruff. This command ensures code style consistency across the project. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nmake format\n```\n\n----------------------------------------\n\nTITLE: Pydantic value_error Error Example\nDESCRIPTION: Illustrates the 'value_error' exception, which occurs when a ValueError is raised during Pydantic field validation. Features a BaseModel with a custom validator that intentionally raises a ValueError, and shows how to capture this error.",
    "chunk_length": 2051
  },
  {
    "chunk_id": 58,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_101\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: str\n\n    @field_validator('x')\n    @classmethod\n    def repeat_b(cls, v):\n        raise ValueError()\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'value_error'\n```\n\n----------------------------------------\n\nTITLE: Custom ThirdPartyType with Pydantic\nDESCRIPTION: Demonstrates how to integrate a custom third-party type with Pydantic models. Shows instance creation, attribute access, model dumping, and validation error handling for invalid inputs. Includes an example of generating the JSON schema for a model with a custom type. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, ValidationError\nfrom pydantic_core import core_schema\n\n# Assume ThirdPartyType is defined elsewhere and behaves like this:\nclass ThirdPartyType:\n    def __init__(self):\n        self.x = 0\n\nclass Model(BaseModel):\n    third_party_type: ThirdPartyType\n\n# Example usage:\ninstance = ThirdPartyType()\nassert instance.x == 0\ninstance.x = 10\n\nm_instance = Model(third_party_type=instance)\nassert isinstance(m_instance.third_party_type, ThirdPartyType)\nassert m_instance.third_party_type.x == 10\nassert m_instance.model_dump() == {'third_party_type': 10}\n\n# Demonstrate that validation errors are raised as expected for invalid inputs\ntry:\n    Model(third_party_type='a')\nexcept ValidationError as e:\n    print(e)\n    # Expected output:\n    # 2 validation errors for Model\n    # third_party_type.is-instance[ThirdPartyType]\n    #   Input should be an instance of ThirdPartyType [type=is_instance_of, input_value='a', input_type=str]\n    # third_party_type.chain[int,function-plain[validate_from_int()]]\n    #   Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n\n# Example of model_json_schema\nassert Model.model_json_schema() == {\n    'properties': {\n        'third_party_type': {'title': 'Third Party Type', 'type': 'integer'}\n    },\n    'required': ['third_party_type'],\n    'title': 'Model',\n    'type': 'object',\n}\n\n# This approach can be used for types like Pandas or Numpy types.",
    "chunk_length": 2448
  },
  {
    "chunk_id": 59,
    "source": "pydantic_llms_data",
    "content": "```\n\n----------------------------------------\n\nTITLE: Pydantic Dotenv Path Support\nDESCRIPTION: Supports home directory relative paths (e.g., `~/.env`) for `dotenv` files used by `BaseSettings`. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_204\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseSettings\n\nclass AppSettings(BaseSettings):\n    database_url: str\n\n    class Config:\n        # Loads from ~/.env if it exists\n        env_file = '~/.env'\n        env_file_encoding = 'utf-8'\n\n# settings = AppSettings()\n# print(settings.database_url)\n```\n\n----------------------------------------\n\nTITLE: Pydantic Forward Annotations with PEP563\nDESCRIPTION: Demonstrates using `from __future__ import annotations` to enable forward references for type hints in Pydantic models. This allows referencing types that are not yet defined. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/forward_annotations.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\nMyInt = int\n\n\nclass Model(BaseModel):\n    a: MyInt\n    # Without the future import, equivalent to:\n    # a: 'MyInt'\n\n\nprint(Model(a='1'))\n#> a=1\n```\n\n----------------------------------------\n\nTITLE: Import Pydantic V1 Utility Function\nDESCRIPTION: Demonstrates importing a utility function, 'lenient_isinstance', from the Pydantic V1 namespace. This allows access to functions removed or changed in Pydantic V2. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.v1.utils import lenient_isinstance\n```\n\n----------------------------------------\n\nTITLE: Python Annotation Resolution at Class Definition\nDESCRIPTION: Provides a reference example for understanding how Pydantic resolves type annotations at class definition time. It sets up a scenario with a type alias and a base class using forward references, which is crucial for runtime evaluation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n# module1.py:\ntype MyType = int\n\nclass Base:\n    f1: 'MyType'\n```\n\n----------------------------------------\n\nTITLE: decimal_type Pydantic Validation Example\nDESCRIPTION: Illustrates the 'decimal_type' error, raised when the input value's type is incorrect for a Decimal field, such as providing a list.",
    "chunk_length": 2419
  },
  {
    "chunk_id": 60,
    "source": "pydantic_llms_data",
    "content": "It also applies to strict fields not being instances of Decimal. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x=[1, 2, 3])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'decimal_type'\n```\n\n----------------------------------------\n\nTITLE: Custom Generic Sequence Type with Pydantic\nDESCRIPTION: Demonstrates creating a custom generic sequence type (`MySequence`) that integrates with Pydantic's `__get_pydantic_core_schema__` for validation and generic type handling. Includes examples of default values and validation with specific types, showing how Pydantic generates schemas for generic types. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Sequence, TypeVar\n\nfrom pydantic_core import ValidationError, core_schema\nfrom typing_extensions import get_args\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\nT = TypeVar('T')\n\n\nclass MySequence(Sequence[T]):\n    def __init__(self, v: Sequence[T]):\n        self.v = v\n\n    def __getitem__(self, i):\n        return self.v[i]\n\n    def __len__(self):\n        return len(self.v)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        instance_schema = core_schema.is_instance_schema(cls)\n\n        args = get_args(source)\n        if args:\n            # replace the type and rely on Pydantic to generate the right schema\n            # for `Sequence`\n            sequence_t_schema = handler.generate_schema(Sequence[args[0]])\n        else:\n            sequence_t_schema = handler.generate_schema(Sequence)\n\n        non_instance_schema = core_schema.no_info_after_validator_function(\n            MySequence, sequence_t_schema\n        )\n        return core_schema.union_schema([instance_schema, non_instance_schema])\n\n\nclass M(BaseModel):\n    model_config = dict(validate_default=True)\n\n    s1: MySequence = [3]\n\n\nm = M()\nprint(m)\n#> s1=<__main__.MySequence object at 0x0123456789ab>\nprint(m.s1.v)\n#> [3]\n\n\nclass M(BaseModel):\n    s1: MySequence[int]\n\n\nM(s1=[1])\ntry:\n    M(s1=['a'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for M\n    s1.is-instance[MySequence]\n      Input should be an instance of MySequence [type=is_instance_of, input_value=['a'], input_type=list]\n    s1.function-after[MySequence(), json-or-python[json=list[int],python=chain[is-instance[Sequence],function-wrap[sequence_validator()]]]].0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Configure Serverless Framework for Metadata (YAML)\nDESCRIPTION: This YAML configuration snippet shows how to set `slim: false` in `serverless.yml` for the `serverless-python-requirements` plugin.",
    "chunk_length": 3154
  },
  {
    "chunk_id": 61,
    "source": "pydantic_llms_data",
    "content": "This ensures that package metadata, like `dist-info` directories, is included in the deployment package, resolving issues with libraries like `email-validator` on AWS Lambda. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/aws_lambda.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\npythonRequirements:\n    dockerizePip: non-linux\n    slim: false\n    fileName: requirements.txt\n```\n\n----------------------------------------\n\nTITLE: datetime_type Pydantic Validation Example\nDESCRIPTION: Demonstrates the 'datetime_type' error, raised when the input value's type is incorrect for a datetime field, such as providing None. It also applies to strict fields not being instances of datetime. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_type'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Field Ordering and Validation\nDESCRIPTION: Explains that Pydantic preserves field order in JSON Schema, validation errors, and serialization. The example shows how fields are ordered in `model_dump()` and how validation errors report locations based on this order. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int = 2\n    c: int = 1\n    d: int = 0\n    e: float\n\n\nprint(Model.model_fields.keys())\n#> dict_keys(['a', 'b', 'c', 'd', 'e'])\nm = Model(e=2, a=1)\nprint(m.model_dump())\n#> {'a': 1, 'b': 2, 'c': 1, 'd': 0, 'e': 2.0}\ntry:\n    Model(a='x', b='x', c='x', d='x', e='x')\nexcept ValidationError as err:\n    error_locations = [e['loc'] for e in err.errors()]\n\nprint(error_locations)\n#> [('a',), ('b',), ('c',), ('d',), ('e',)]\n```\n\n----------------------------------------\n\nTITLE: Pydantic BaseModel Method Renaming (V1 to V2)\nDESCRIPTION: Lists common Pydantic BaseModel methods and their corresponding names in Pydantic V2.",
    "chunk_length": 2227
  },
  {
    "chunk_id": 62,
    "source": "pydantic_llms_data",
    "content": "This helps users migrate from V1 to V2 by understanding the new API. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_8\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic BaseModel Method Mapping:\n\n| Pydantic V1 Method Name      | Pydantic V2 Method Name      |\n|------------------------------|------------------------------|\n| `__fields__`                 | `model_fields`               |\n| `__private_attributes__`     | `__pydantic_private__`       |\n| `__validators__`             | `__pydantic_validator__`     |\n| `construct()`                | `model_construct()`          |\n| `copy()`                     | `model_copy()`               |\n| `dict()`                     | `model_dump()`               |\n| `json_schema()`              | `model_json_schema()`        |\n| `json()`                     | `model_dump_json()`          |\n| `parse_obj()`                | `model_validate()`           |\n| `update_forward_refs()`      | `model_rebuild()`            |\n```\n\n----------------------------------------\n\nTITLE: Configuration for TypedDict using with_config\nDESCRIPTION: Illustrates configuring `TypedDict` using the `with_config` decorator with `ConfigDict` to enable `str_to_lower`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, with_config\n\n\n@with_config(ConfigDict(str_to_lower=True))\nclass Model(TypedDict):\n    x: str\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Customizing Settings Sources\nDESCRIPTION: Provides the ability to customize how Pydantic loads settings by adding, disabling, or changing the priority order of configuration sources. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_174\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Settings Management:\n\nCustomize settings loading behavior by modifying the `settings_customise_sources` class method or attribute within a `BaseSettings` subclass. Functionality:\n- Add new sources (e.g., custom file formats, environment variables with prefixes).",
    "chunk_length": 2123
  },
  {
    "chunk_id": 63,
    "source": "pydantic_llms_data",
    "content": "- Disable default sources (e.g., `.env` files, environment variables). - Change the priority order of existing sources. Example:\n```python\nfrom pydantic import BaseSettings, SettingsConfigDict\nfrom pydantic_settings import SettingsSources, init_settings\n\nclass CustomSettings(BaseSettings):\n    api_key: str\n    debug_mode: bool = False\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: SettingsSources,\n        env_settings: SettingsSources,\n        dotenv_settings: SettingsSources,\n        file_secret_settings: SettingsSources,\n    ) -> SettingsSources:\n        # Prioritize environment variables, then a custom config file, then .env\n        return init_settings.with_priority(10) | env_settings.with_priority(20) | dotenv_settings.with_priority(30)\n\n# Usage:\n# settings = CustomSettings()\n```\n\nRelated Configuration:\n- `SettingsConfigDict`: Used to configure settings behavior, including source customization. ```\n\n----------------------------------------\n\nTITLE: Pydantic uuid_version Error Example\nDESCRIPTION: Demonstrates the 'uuid_version' error raised by Pydantic when an input value's type does not match the expected UUID version. Includes a BaseModel with UUID5 and a try-except block to catch and display the error type. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_100\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import UUID5, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID5\n\n\ntry:\n    Model(u='a6cc5730-2261-11ee-9c43-2eb5a363657c')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'uuid_version'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Field Alias for Validation and Serialization\nDESCRIPTION: Demonstrates using the `alias` parameter in Pydantic's `Field` to specify a name for both validation and serialization. The example shows creating a model instance with the alias and dumping it back to a dictionary using the alias. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(alias='username')\n\n\nuser = User(username='johndoe')  # (1)!",
    "chunk_length": 2311
  },
  {
    "chunk_id": 64,
    "source": "pydantic_llms_data",
    "content": "print(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)! #>\n#> {'username': 'johndoe'}\n```\n\n----------------------------------------\n\nTITLE: Demonstrate date_past error in Pydantic\nDESCRIPTION: Illustrates the `date_past` error, raised when a value for a `PastDate` field is not in the past. The example defines a model with a `PastDate` field and attempts to validate a date that is in the future, triggering the validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date, timedelta\n\nfrom pydantic import BaseModel, PastDate, ValidationError\n\n\nclass Model(BaseModel):\n    x: PastDate\n\n\ntry:\n    Model(x=date.today() + timedelta(1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_past'\n```\n\n----------------------------------------\n\nTITLE: Dynamic Model with Aliases, Descriptions, and Private Attributes\nDESCRIPTION: Demonstrates creating a dynamic Pydantic model using `create_model`, specifying field aliases, descriptions via `Annotated`, and private attributes. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, PrivateAttr, create_model\n\nDynamicModel = create_model(\n    'DynamicModel',\n    foo=(str, Field(alias='FOO')),\n    bar=Annotated[str, Field(description='Bar field')],\n    _private=(int, PrivateAttr(default=1)),\n)\n```\n\n----------------------------------------\n\nTITLE: Demonstrate dataclass_exact_type error in Pydantic\nDESCRIPTION: Illustrates the `dataclass_exact_type` error, occurring with `strict=True` validation when the input is not an instance of the target dataclass. The example uses `TypeAdapter` with a Pydantic dataclass and shows how providing a dictionary with `strict=True` raises this specific error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport pydantic.dataclasses\nfrom pydantic import TypeAdapter, ValidationError\n\n\n@pydantic.dataclasses.dataclass\nclass MyDataclass:\n    x: str\n\n\nadapter = TypeAdapter(MyDataclass)\n\nprint(adapter.validate_python(MyDataclass(x='test'), strict=True))\n#> MyDataclass(x='test')\nprint(adapter.validate_python({'x': 'test'}))\n#> MyDataclass(x='test')\n\ntry:\n    adapter.validate_python({'x': 'test'}, strict=True)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'dataclass_exact_type'\n```\n\n----------------------------------------\n\nTITLE: Handle iterable_type Error in Pydantic\nDESCRIPTION: This error is raised when the input value is not valid as an `Iterable` for a Pydantic field.",
    "chunk_length": 2776
  },
  {
    "chunk_id": 65,
    "source": "pydantic_llms_data",
    "content": "The example demonstrates passing an integer (`123`) to a field annotated with `Iterable`, causing a `ValidationError` with the 'iterable_type' error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Iterable\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    y: Iterable\n\n\ntry:\n    Model(y=123)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'iterable_type'\n```\n\n----------------------------------------\n\nTITLE: Handle int_type Error in Pydantic\nDESCRIPTION: This error is raised when the input value's type is not valid for an `int` field in Pydantic. The example demonstrates passing `None` to an `int` field, which results in a `ValidationError` with the 'int_type' error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_type'\n```\n\n----------------------------------------\n\nTITLE: BaseSettings Signature\nDESCRIPTION: Change in how `Any` type is handled when synthesizing the `BaseSettings.__init__` signature in the mypy plugin. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nChange type of `Any` when synthesizing `BaseSettings.__init__` signature in the mypy plugin\n```\n\n----------------------------------------\n\nTITLE: Pydantic v1 @validator Deprecation Example\nDESCRIPTION: Illustrates the deprecated @validator decorator with the 'always=True' argument. It explains that this behavior is now handled by 'validate_default' in Pydantic v2's Field, and notes changes to validator signatures, removing 'field' and 'config' arguments. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, validator\n\n\nclass Model(BaseModel):\n    x: str = 1\n\n    @validator('x', always=True)\n    @classmethod\n    def validate_x(cls, v):\n        return v\n\n\nModel()\n```\n\n----------------------------------------\n\nTITLE: Pydantic `create_model()` Enhancements\nDESCRIPTION: The `create_model()` function now allows specifying configuration and base models together.",
    "chunk_length": 2428
  },
  {
    "chunk_id": 66,
    "source": "pydantic_llms_data",
    "content": "This provides more flexibility when dynamically creating Pydantic models, enabling simultaneous definition of model settings and inheritance. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import create_model, ConfigDict\n\n# Example: Creating a model with config and bases specified together\nMyDynamicModel = create_model(\n    'MyDynamicModel',\n    __config__=ConfigDict(extra='forbid'),\n    field1=(str, ...),\n    base_model_field=(int, 10)\n)\n\n# This is equivalent to:\n# class MyDynamicModel(BaseModel):\n#     field1: str\n#     base_model_field: int = 10\n#     model_config = ConfigDict(extra='forbid')\n\n```\n\n----------------------------------------\n\nTITLE: Global Configuration Inheritance (Allow Extra)\nDESCRIPTION: Demonstrates setting global configuration `extra='allow'` in a parent `BaseModel` and inheriting it in a child model. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Parent(BaseModel):\n    model_config = ConfigDict(extra='allow')\n\n\nclass Model(Parent):\n    x: str\n\n\nm = Model(x='foo', y='bar')\nprint(m.model_dump())\n#> {'x': 'foo', 'y': 'bar'}\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Validation Alias Only\nDESCRIPTION: Illustrates using `validation_alias` in Pydantic's `Field` to specify an alias used only during model validation. The example shows instance creation with the validation alias and serialization using the original field name. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(validation_alias='username')\n\n\nuser = User(username='johndoe')  # (1)! print(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)! #>\n#> {'name': 'johndoe'}\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model with Dict for Nested Model\nDESCRIPTION: Demonstrates a Pydantic `Quest` model that expects a `Knight` model instance for its `knight` field.",
    "chunk_length": 2165
  },
  {
    "chunk_id": 67,
    "source": "pydantic_llms_data",
    "content": "The example shows that passing a literal dictionary that matches the `Knight` structure is still valid and automatically converted by Pydantic, but may trigger strict type errors in linters. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nclass Quest(BaseModel):\n    title: str\n    knight: Knight\n\n\nquest = Quest(\n    title='To seek the Holy Grail', knight={'title': 'Sir Lancelot', 'age': 23}\n)\n```\n\n----------------------------------------\n\nTITLE: Named Type Alias with Type Variables (Python 3.12+)\nDESCRIPTION: Shows the usage of generic named type aliases with the `type` statement syntax, incorporating `TypeVar`. This example defines `ShortList` as a list of type `T` with a maximum length constraint, demonstrating parameterization. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import Annotated, TypeVar\n\nfrom annotated_types import Len\n\ntype ShortList[T] = Annotated[list[T], Len(max_length=4)]\n```\n\n----------------------------------------\n\nTITLE: Avoid Naming Collisions with Types\nDESCRIPTION: Warns about potential issues when a field name clashes with its type annotation in Python. This example shows how such a collision can lead to validation errors due to how Python evaluates annotated assignment statements. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Boo(BaseModel):\n    int: Optional[int] = None\n\n\nm = Boo(int=123)  # Will fail to validate. ```\n\n----------------------------------------\n\nTITLE: Pydantic Model Configuration with model_config\nDESCRIPTION: Demonstrates configuring a Pydantic BaseModel using the `model_config` class attribute with `ConfigDict` to set `str_max_length`. Includes error handling for validation.",
    "chunk_length": 2070
  },
  {
    "chunk_id": 68,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    model_config = ConfigDict(str_max_length=5)  # (1)! v: str\n\n\ntry:\n    m = Model(v='abcdef')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    v\n      String should have at most 5 characters [type=string_too_long, input_value='abcdef', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Use Context in Validators with ValidationInfo.context\nDESCRIPTION: Shows how to pass and access custom context data in Pydantic validators using `ValidationInfo.context`. This allows for dynamic behavior based on external data, requiring `pydantic` and `ValidationInfo`. The example demonstrates removing stopwords from text based on provided context. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass Model(BaseModel):\n    text: str\n\n    @field_validator('text', mode='after')\n    @classmethod\n    def remove_stopwords(cls, v: str, info: ValidationInfo) -> str:\n        if isinstance(info.context, dict):\n            stopwords = info.context.get('stopwords', set())\n            v = ' '.join(w for w in v.split() if w.lower() not in stopwords)\n        return v\n\n\ndata = {'text': 'This is an example document'}\nprint(Model.model_validate(data))  # no context\n#> text='This is an example document'\nprint(Model.model_validate(data, context={'stopwords': ['this', 'is', 'an']}))\n#> text='example document'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Forward Reference Error Example\nDESCRIPTION: Demonstrates a scenario where a Pydantic model uses a forward reference ('A | Forward') that might lead to a PydanticUndefinedAnnotation error if not properly handled during model rebuilding. It shows how to define a model within a function and the subsequent rebuild process.",
    "chunk_length": 2100
  },
  {
    "chunk_id": 69,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef func():\n    A = int\n\n    class Model(BaseModel):\n        f: 'A | Forward'\n\n    return Model\n\n\nModel = func()\n\nModel.model_rebuild(_types_namespace={'Forward': str})\n# pydantic.errors.PydanticUndefinedAnnotation: name 'A' is not defined\n```\n\n----------------------------------------\n\nTITLE: TypeAdapter with Generic Collections\nDESCRIPTION: Demonstrates how Pydantic V2's TypeAdapter handles generic collections, showing that input types are not preserved by default, and a plain dict is returned instead of a custom dict subclass. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Mapping\n\nfrom pydantic import TypeAdapter\n\n\nclass MyDict(dict):\n    pass\n\n\nta = TypeAdapter(Mapping[str, int])\nv = ta.validate_python(MyDict())\nprint(type(v))\n#> <class 'dict'>\n```\n\n----------------------------------------\n\nTITLE: Customize JSON Schema $ref Paths with Pydantic\nDESCRIPTION: This Python example demonstrates how to use the 'ref_template' argument with Pydantic's 'json_schema' method (via TypeAdapter) to alter the '$ref' paths in the generated JSON schema. This is useful for aligning with specific schema conventions, such as those found in OpenAPI's 'components/schemas' section. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel\nfrom pydantic.type_adapter import TypeAdapter\n\n\nclass Foo(BaseModel):\n    a: int\n\n\nclass Model(BaseModel):\n    a: Foo\n\n\nadapter = TypeAdapter(Model)\n\nprint(\n    json.dumps(\n        adapter.json_schema(ref_template='#/components/schemas/{model}'),\n        indent=2,\n    )\n)\n\"\"\"\n{\n  \"$defs\": {\n    \"Foo\": {\n      \"properties\": {\n        \"a\": {\n          \"title\": \"A\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"a\"\n      ],\n      \"title\": \"Foo\",\n      \"type\": \"object\"\n    }\n  },\n  \"properties\": {\n    \"a\": {\n      \"$ref\": \"#/components/schemas/Foo\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Configuration with Class Arguments\nDESCRIPTION: Shows how to configure a Pydantic BaseModel using class arguments, specifically `frozen=True`, which is recognized by static type checkers.",
    "chunk_length": 2489
  },
  {
    "chunk_id": 70,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel, frozen=True):\n    a: str  # (1)! ```\n\n----------------------------------------\n\nTITLE: Verify Python Version Suffix (Python)\nDESCRIPTION: This Python code uses `sysconfig` to retrieve the expected shared library suffix for the current Python environment. It's used to confirm compatibility with the compiled `pydantic_core` library, ensuring the correct native code is installed for the target platform. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/aws_lambda.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sysconfig\nprint(sysconfig.get_config_var(\"EXT_SUFFIX\"))\n#> '.cpython-312-x86_64-linux-gnu.so'\n```\n\n----------------------------------------\n\nTITLE: Handle invalid_key Error in Pydantic\nDESCRIPTION: This error is raised when attempting to validate a `dict` that contains a key which is not an instance of `str`. The example shows passing a bytes key (`b'y'`) to a Pydantic model, triggering the 'invalid_key' validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\ntry:\n    Model.model_validate({'x': 1, b'y': 2})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'invalid_key'\n```\n\n----------------------------------------\n\nTITLE: Modify JSON Schema with __get_pydantic_json_schema__\nDESCRIPTION: Shows how to customize the JSON schema generated by Pydantic by implementing the `__get_pydantic_json_schema__` class method. This method allows adding metadata like `examples` or changing the `title` without affecting the core validation schema. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom typing import Any\n\nfrom pydantic_core import core_schema as cs\n\nfrom pydantic import GetCoreSchemaHandler, GetJsonSchemaHandler, TypeAdapter\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass Person:\n    name: str\n    age: int\n\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> cs.CoreSchema:\n        return cs.typed_dict_schema(\n            {\n                'name': cs.typed_dict_field(cs.str_schema()),\n                'age': cs.typed_dict_field(cs.int_schema()),\n            },\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls,\n        core_schema: cs.CoreSchema,\n        handler: GetJsonSchemaHandler,\n    ) -> JsonSchemaValue:\n        json_schema = handler(core_schema)\n        json_schema = handler.resolve_ref_schema(json_schema)\n        json_schema['examples'] = [\n            {\n                'name': 'John Doe',\n                'age': 25,\n            }\n        ]\n        json_schema['title'] = 'Person'\n        return json_schema\n\n\nprint(json.dumps(TypeAdapter(Person).json_schema(), indent=2))\n\n```\n\n----------------------------------------\n\nTITLE: Enforce Typing Relationships with Nested Generics\nDESCRIPTION: Demonstrates using the same type variable across nested generic models to enforce consistent typing.",
    "chunk_length": 3506
  },
  {
    "chunk_id": 71,
    "source": "pydantic_llms_data",
    "content": "Includes an example of how mismatched types lead to `ValidationError` and how Pydantic handles revalidation for intuitive results. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nT = TypeVar('T')\n\n\nclass InnerT(BaseModel, Generic[T]):\n    inner: T\n\n\nclass OuterT(BaseModel, Generic[T]):\n    outer: T\n    nested: InnerT[T]\n\n\nnested = InnerT[int](inner=1)\nprint(OuterT[int](outer=1, nested=nested))\n#> outer=1 nested=InnerT[int](inner=1)\ntry:\n    print(OuterT[int](outer='a', nested=InnerT(inner='a')))  # (1)! except ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for OuterT[int]\n    outer\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    nested.inner\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Dataclass with Fields and Metadata\nDESCRIPTION: Shows how to use `dataclasses.field` and Pydantic's `Field` for default values, factories, and metadata like titles and constraints. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\nfrom typing import Optional\n\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: list[int] = dataclasses.field(default_factory=lambda: [0])\n    age: Optional[int] = dataclasses.field(\n        default=None,\n        metadata={'title': 'The age of the user', 'description': 'do not lie!'},\n    )\n    height: Optional[int] = Field(\n        default=None, title='The height in cm', ge=50, le=300\n    )\n\n\nuser = User(id='42', height='250')\nprint(user)\n```\n\n----------------------------------------\n\nTITLE: Improving Pydantic Union Error Clarity with Tags\nDESCRIPTION: This example demonstrates how `Tag` can be used with `TypeAdapter` to make validation error messages for union types more informative.",
    "chunk_length": 2224
  },
  {
    "chunk_id": 72,
    "source": "pydantic_llms_data",
    "content": "It compares error outputs when `Tag` is not used versus when it is, highlighting how tags provide clearer context for which union member failed validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Union\n\nfrom pydantic import AfterValidator, Tag, TypeAdapter, ValidationError\n\nDoubledList = Annotated[list[int], AfterValidator(lambda x: x * 2)]\nStringsMap = dict[str, str]\n\n\n# Not using any `Tag`s for each union case, the errors are not so nice to look at\nadapter = TypeAdapter(Union[DoubledList, StringsMap])\n\ntry:\n    adapter.validate_python(['a'])\nexcept ValidationError as exc_info:\n    print(exc_info)\n\ntag_adapter = TypeAdapter(\n    Union[\n        Annotated[DoubledList, Tag('DoubledList')],\n        Annotated[StringsMap, Tag('StringsMap')],\n    ]\n)\n\ntry:\n    tag_adapter.validate_python(['a'])\nexcept ValidationError as exc_info:\n    print(exc_info)\n```\n\n----------------------------------------\n\nTITLE: Define Pydantic User Model\nDESCRIPTION: Demonstrates how to define a Pydantic BaseModel with required and optional fields, default values, and model configuration. It shows the basic structure for creating data models that leverage Python's type hints for validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'Jane Doe'\n\n    model_config = ConfigDict(str_max_length=10)  # (1)! ```\n\n----------------------------------------\n\nTITLE: Demonstrate datetime_future error in Pydantic\nDESCRIPTION: Illustrates the `datetime_future` error, raised when a value provided for a `FutureDatetime` field is not in the future. The example defines a model with a `FutureDatetime` field and attempts to validate a past `datetime` object, triggering the validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, FutureDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: FutureDatetime\n\n\ntry:\n    Model(x=datetime(2000, 1, 1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_future'\n```\n\n----------------------------------------\n\nTITLE: TypeAdapter: Explicit Generic Parameter Specification\nDESCRIPTION: Illustrates the need for explicit generic parameter specification with `TypeAdapter` in certain scenarios to ensure proper typing, especially when dealing with complex union types.",
    "chunk_length": 2656
  },
  {
    "chunk_id": 73,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter[str | int](str | int)\n... ```\n\n----------------------------------------\n\nTITLE: Pydantic Generic Model Revalidation Behavior\nDESCRIPTION: Explains Pydantic's revalidation strategy for nested generic models, particularly when validating data against a generic type like `GenericModel[Any]`. Shows an example where revalidation ensures intuitive results for compatible types. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\n\nclass GenericModel(BaseModel, Generic[T]):\n    a: T\n\n\nclass Model(BaseModel):\n    inner: GenericModel[Any]\n\n\nprint(repr(Model.model_validate(Model(inner=GenericModel[int](a=1)))))\n#> Model(inner=GenericModel[Any](a=1))\n```\n\n----------------------------------------\n\nTITLE: Stdlib Type Configuration Propagation with Pydantic\nDESCRIPTION: Shows that configuration is propagated for standard library types (dataclasses, typed dictionaries) unless they have their own configuration set, when used with Pydantic. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom pydantic import BaseModel, ConfigDict, with_config\n\n\n@dataclass\nclass UserWithoutConfig:\n    name: str\n\n\n@dataclass\n@with_config(str_to_lower=False)\nclass UserWithConfig:\n    name: str\n\n\nclass Parent(BaseModel):\n    user_1: UserWithoutConfig\n    user_2: UserWithConfig\n\n    model_config = ConfigDict(str_to_lower=True)\n\n\nprint(Parent(user_1={'name': 'JOHN'}, user_2={'name': 'JOHN'}))\n#> user_1=UserWithoutConfig(name='john') user_2=UserWithConfig(name='JOHN')\n```\n\n----------------------------------------\n\nTITLE: Mark Pydantic `computed_field` as Deprecated\nDESCRIPTION: This example demonstrates how to mark a `computed_field` as deprecated using the `@deprecated` decorator from `typing_extensions`.",
    "chunk_length": 2125
  },
  {
    "chunk_id": 74,
    "source": "pydantic_llms_data",
    "content": "This allows developers to signal that a computed property is no longer recommended for use, providing clear guidance for API evolution. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import deprecated\n\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    @deprecated(\"'volume' is deprecated\")\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n```\n\n----------------------------------------\n\nTITLE: Handle json_invalid Error in Pydantic\nDESCRIPTION: This error is raised when the input value provided to a `Json` field in Pydantic is not a valid JSON string. The example attempts to parse a plain string 'test' as JSON, triggering the 'json_invalid' validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Json, ValidationError\n\n\nclass Model(BaseModel):\n    x: Json\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'json_invalid'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Apply Validator to Multiple Fields with Decorator\nDESCRIPTION: Demonstrates using the `@field_validator` decorator to apply a single validation function to multiple fields within a Pydantic model. This example uses a `capitalize` validator applied to `f1` and `f2` using `mode='before'`, showcasing efficient application of common validation logic. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    f1: str\n    f2: str\n\n    @field_validator('f1', 'f2', mode='before')\n    @classmethod\n    def capitalize(cls, value: str) -> str:\n        return value.capitalize()\n```\n\n----------------------------------------\n\nTITLE: Handle is_subclass_of Error in Pydantic\nDESCRIPTION: This error is raised when the input value is not a subclass of the expected type for a Pydantic field.",
    "chunk_length": 2231
  },
  {
    "chunk_id": 75,
    "source": "pydantic_llms_data",
    "content": "The example shows passing a string to a field annotated with `type[Nested]`, which expects a class, triggering the 'is_subclass_of' error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Nested:\n    x: str\n\n\nclass Model(BaseModel):\n    y: type[Nested]\n\n\ntry:\n    Model(y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'is_subclass_of'\n```\n\n----------------------------------------\n\nTITLE: Strict Mode with Annotated[..., Strict()]\nDESCRIPTION: Demonstrates using `Annotated[..., Strict()]` to enforce strict validation on individual fields within a Pydantic model. This example shows how a string 'True' fails validation for a strictly typed boolean field. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Strict, ValidationError\n\n\nclass User(BaseModel):\n    name: str\n    age: int\n    is_active: Annotated[bool, Strict()]\n\n\nUser(name='David', age=33, is_active=True)\ntry:\n    User(name='David', age=33, is_active='True')\nexcept ValidationError as exc:\n    print(exc)\n    \n```\n\n----------------------------------------\n\nTITLE: Customizing Core Schema with Annotated\nDESCRIPTION: Illustrates how to customize Pydantic's core schema generation for types using Annotated and custom classes like MyStrict and MyGt, which implement __get_pydantic_core_schema__. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import CoreSchema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\n\n\nclass MyStrict:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        source: Any,\n        handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        schema = handler(source)  # (1)! schema['strict'] = True\n        return schema\n\n\nclass MyGt:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        source: Any,\n        handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        schema = handler(source)  # (2)!",
    "chunk_length": 2278
  },
  {
    "chunk_id": 76,
    "source": "pydantic_llms_data",
    "content": "schema['gt'] = 1\n        return schema\n\n\nta = TypeAdapter(Annotated[int, MyStrict(), MyGt()])\n```\n\n----------------------------------------\n\nTITLE: Pydantic v1 Deprecation Aliases Removal\nDESCRIPTION: This snippet details the removal of deprecated aliases and features from Pydantic v1, guiding users on migration paths. It lists specific attributes and methods that have been replaced or removed, such as `Schema`, `Config.case_insensitive`, `model.fields`, and `model.__values__`. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_141\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic v1 Deprecation Aliases Removal:\n\n- Removed `Schema` (replaced by `Field`)\n- Removed `Config.case_insensitive` (replaced by `Config.case_sensitive`, default `False`)\n- Removed `Config.allow_population_by_alias` (replaced by `Config.allow_population_by_field_name`)\n- Removed `model.fields` (replaced by `model.__fields__`)\n- Removed `model.to_string()` (replaced by `str(model)`)\n- Removed `model.__values__` (replaced by `model.__dict__`)\n- Removed notes on migrating to v1 in docs. ```\n\n----------------------------------------\n\nTITLE: Pydantic Validation Error Structure Example\nDESCRIPTION: This snippet demonstrates the structure of a Pydantic validation error, showing common fields like 'type', 'loc', 'msg', 'input', 'ctx', and 'url'. These structures are used to convey detailed information about why data validation failed. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/errors.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n[\n    {\n        'type': 'missing',\n        'loc': ('body',),\n        'msg': 'Field required',\n        'input': {},\n        'url': 'https://errors.pydantic.dev/2/v/missing',\n    },\n    {\n        'type': 'greater_than',\n        'loc': ('gt_int',),\n        'msg': 'Input should be greater than 42',\n        'input': 21,\n        'ctx': {'gt': 42},\n        'url': 'https://errors.pydantic.dev/2/v/greater_than',\n    },\n    {\n        'type': 'int_parsing',\n        'loc': ('list_of_ints', 2),\n        'msg': 'Input should be a valid integer, unable to parse string as an integer',\n        'input': 'bad',\n        'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n    },\n    {\n        'type': 'value_error',\n        'loc': ('a_float',),\n        'msg': 'Value error, Invalid float value',\n        'input': 3.0,\n        'ctx': {'error': ValueError('Invalid float value')},\n        'url': 'https://errors.pydantic.dev/2/v/value_error',\n    },\n    {\n        'type': 'float_parsing',\n        'loc': ('recursive_model', 'lng'),\n        'msg': 'Input should be a valid number, unable to parse string as a number',\n        'input': 'New York',\n        'url': 'https://errors.pydantic.dev/2/v/float_parsing',\n    },\n]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Configuration via Class Kwargs\nDESCRIPTION: Introduces the ability to configure Pydantic models directly through class keyword arguments.",
    "chunk_length": 2960
  },
  {
    "chunk_id": 77,
    "source": "pydantic_llms_data",
    "content": "This offers a more concise and integrated way to set model-specific configurations. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_145\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Model Configuration via Class Kwargs:\n\nModels can now be configured using class keyword arguments. ```\n\n----------------------------------------\n\nTITLE: Basic Include in Pydantic\nDESCRIPTION: Demonstrates how to use the `include` parameter to specify which fields to serialize. It shows including specific fields and nested fields. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: str\n    name: str\n    user: dict\n\nt = User(id='1234567890', name='John Doe', user={'id': 42})\nprint(t.model_dump(include={'id': True, 'user': {'id'}}))\n#> {'id': '1234567890', 'user': {'id': 42}}\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Configuration Propagation\nDESCRIPTION: Demonstrates that configuration is not propagated across Pydantic models, with each model having its own configuration boundary. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass Parent(BaseModel):\n    user: User\n\n    model_config = ConfigDict(str_to_lower=True)\n\n\nprint(Parent(user={'name': 'JOHN'}))\n#> user=User(name='JOHN')\n```\n\n----------------------------------------\n\nTITLE: Define Pydantic Model with `typing.Literal` for Enum-like Fields\nDESCRIPTION: Demonstrates how to use `typing.Literal` in Pydantic models to restrict a field's value to a predefined set of string literals. Includes an example of successful instantiation and a `ValidationError` for an invalid input, showing how Pydantic enforces these literal constraints. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Pie(BaseModel):\n    flavor: Literal['apple', 'pumpkin']\n\n\nPie(flavor='apple')\nPie(flavor='pumpkin')\ntry:\n    Pie(flavor='cherry')\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for Pie\n    flavor\n      Input should be 'apple' or 'pumpkin' [type=literal_error, input_value='cherry', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Sphinx Intersphinx Configuration for Pydantic\nDESCRIPTION: Configure Sphinx to enable cross-referencing with Pydantic's API documentation.",
    "chunk_length": 2665
  },
  {
    "chunk_id": 78,
    "source": "pydantic_llms_data",
    "content": "This involves adding Pydantic's object inventory URL to the `intersphinx_mapping` in your Sphinx configuration file (`conf.py`). SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/documentation.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nintersphinx_mapping = {\n    'pydantic': ('https://docs.pydantic.dev/latest', None)\n}\n```\n\n----------------------------------------\n\nTITLE: Handle iteration_error in Pydantic\nDESCRIPTION: This error is raised when an error occurs during the iteration process for a Pydantic field, such as when validating a list from a generator that raises an exception. The example shows a generator yielding values and then raising a `RuntimeError`, which Pydantic catches and reports as 'iteration_error'. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\ndef gen():\n    yield 1\n    raise RuntimeError('error')\n\n\nclass Model(BaseModel):\n    x: list[int]\n\n\ntry:\n    Model(x=gen())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'iteration_error'\n```\n\n----------------------------------------\n\nTITLE: Handle list_type Error in Pydantic\nDESCRIPTION: This error is raised when the input value's type is not valid for a `list` field in Pydantic. The example demonstrates passing an integer (`1`) to a field annotated as `list[int]`, which causes a `ValidationError` with the 'list_type' error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int]\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'list_type'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Mypy Plugin Compatibility with disallow_any_explicit\nDESCRIPTION: A note on compatibility issues with mypy's `disallow_any_explicit` option. It explains that synthesized `__init__` methods might contain `Any` annotations, causing errors, and provides a solution.",
    "chunk_length": 2150
  },
  {
    "chunk_id": 79,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#_snippet_7\n\nLANGUAGE: APIDOC\nCODE:\n```\nCompatibility Note:\n  Topic: Interaction with mypy's `disallow_any_explicit`\n  Problem: Synthesized `__init__` methods may contain `Any` annotations, causing errors if `disallow_any_explicit` is enabled. Solution: Enable both `init_forbid_extra` and `init_typed` to circumvent this issue. ```\n\n----------------------------------------\n\nTITLE: Handle is_instance_of Error in Pydantic\nDESCRIPTION: This error occurs when an input value is not an instance of the expected type for a Pydantic field. The example demonstrates assigning a string to a field that expects a custom object type (`Nested`), resulting in an 'is_instance_of' validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Nested:\n    x: str\n\n\nclass Model(BaseModel):\n    y: Nested\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n\ntry:\n    Model(y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'is_instance_of'\n```\n\n----------------------------------------\n\nTITLE: Demonstrate date_from_datetime_parsing error in Pydantic\nDESCRIPTION: This example demonstrates the `date_from_datetime_parsing` error, raised when a string input for a `date` field cannot be parsed into a valid date. The code attempts to validate a Pydantic model with a `date` field using a malformed string, resulting in this parsing error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\ntry:\n    Model(x='XX1494012000')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_from_datetime_parsing'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Enum Validation with Python Enums\nDESCRIPTION: Illustrates Pydantic's integration with Python's standard `enum.Enum` and `IntEnum` classes for defining choices and validating model fields.",
    "chunk_length": 2240
  },
  {
    "chunk_id": 80,
    "source": "pydantic_llms_data",
    "content": "Shows how Pydantic checks for valid Enum instances and members, including examples of successful instantiation and error handling for invalid inputs. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom enum import Enum, IntEnum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass FruitEnum(str, Enum):\n    pear = 'pear'\n    banana = 'banana'\n\n\nclass ToolEnum(IntEnum):\n    spanner = 1\n    wrench = 2\n\n\nclass CookingModel(BaseModel):\n    fruit: FruitEnum = FruitEnum.pear\n    tool: ToolEnum = ToolEnum.spanner\n\n\nprint(CookingModel())\nprint(CookingModel(tool=2, fruit='banana'))\ntry:\n    CookingModel(fruit='other')\nexcept ValidationError as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Pydantic `con*` Type Functions Documentation\nDESCRIPTION: Adds documentation for Pydantic's `con*` type functions, such as `conint`, `conlist`, `conset`, etc. This helps users understand and utilize these constrained types effectively. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_166\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic `con*` Type Functions Documentation:\n\nAdds documentation for `con*` type functions. ```\n\n----------------------------------------\n\nTITLE: Model Validation and Serialization with pydantic-core\nDESCRIPTION: Shows how Pydantic uses pydantic-core's SchemaValidator for validation and SchemaSerializer for serialization, demonstrating instance-level operations. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    foo: int\n\n\nmodel = Model.model_validate({'foo': 1})  # (1)! dumped = model.model_dump()  # (2)! ```\n\n----------------------------------------\n\nTITLE: Pydantic: Self Type in BaseModel Method\nDESCRIPTION: Shows an example where `Self` is used within a method of a `BaseModel` subclass, which is also disallowed by Pydantic's current validation rules for `Self`.",
    "chunk_length": 2051
  },
  {
    "chunk_id": 81,
    "source": "pydantic_llms_data",
    "content": "This specific usage, even if type-checker valid, will raise an error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, PydanticUserError, validate_call\n\ntry:\n\n    class A(BaseModel):\n        @validate_call\n        def func(self, arg: Self):\n            pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Utility Functions\nDESCRIPTION: A collection of utility functions for Pydantic, including class attribute handling, value comparisons, identifier validation, and path type management. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_37\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.utils:\n  ClassAttribute: A descriptor for class attributes. DUNDER_ATTRIBUTES: A set of dunder attributes. PyObjectStr: Alias for typing.Union[str, PyObject]. ValueItems: Alias for typing.Tuple[str, Any]. almost_equal_floats(a: float, b: float, *, tolerance: float = 1e-9) -> bool\n    Check if two floats are almost equal. get_discriminator_alias_and_values(model: type) -> typing.Tuple[str, typing.List[typing.Any]]\n    Get the discriminator alias and values for a model. get_model(obj: typing.Any) -> typing.Optional[type]\n    Get the Pydantic model from an object. get_unique_discriminator_alias(model: type) -> str\n    Get the unique discriminator alias for a model. in_ipython() -> bool\n    Check if the code is running in an IPython environment. is_valid_identifier(name: str) -> bool\n    Check if a string is a valid Python identifier. path_type() -> type\n    Get the path type (pathlib.Path or str). validate_field_name(name: str) -> str\n    Validate and return a field name. ```\n\n----------------------------------------\n\nTITLE: Generate Pydantic Models from JSON Schema\nDESCRIPTION: Demonstrates the command-line usage of datamodel-code-generator to convert a JSON Schema file into Python Pydantic models.",
    "chunk_length": 2070
  },
  {
    "chunk_id": 82,
    "source": "pydantic_llms_data",
    "content": "It specifies the input file, its type, and the desired output file. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/datamodel_code_generator.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndatamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n```\n\n----------------------------------------\n\nTITLE: Pydantic Field Serializer API Reference\nDESCRIPTION: API documentation for Pydantic's field serializer components, including PlainSerializer, WrapSerializer, and the field_serializer decorator. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_8\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.functional_serializers.PlainSerializer\n  - Serializer that is called unconditionally. - The serialization logic for types supported by Pydantic will not be called. pydantic.functional_serializers.WrapSerializer\n  - Serializer that provides more flexibility by allowing custom logic before or after Pydantic's default serialization. - Requires a mandatory 'handler' parameter. pydantic.functional_serializers.field_serializer\n  - Decorator to apply custom serialization logic to fields. - Can be used with mode='plain' or mode='wrap'. - Applied on instance or static methods. - Signature: @field_serializer(field_name, *, mode='plain', return_type=None)\n    - field_name: The name of the field to serialize. - mode: 'plain' or 'wrap'. Defaults to 'plain'. - return_type: Optional return type annotation for the serialized value. ```\n\n----------------------------------------\n\nTITLE: Support Multiple Dotenv Files\nDESCRIPTION: Enhances Pydantic's settings management to support loading configuration from multiple `.env` files, allowing for layered configuration. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_107\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseSettings, SettingsConfigDict\n\nclass AppSettingsMultiEnv(BaseSettings):\n    setting1: str\n    setting2: int\n\n    model_config = SettingsConfigDict(\n        env_file=('.env', '.env.prod'), # Loads from .env first, then .env.prod\n        env_file_encoding='utf-8'\n    )\n\n# Example:\n# .env file:\n# setting1=value_from_env1\n# .env.prod file:\n# setting2=123\n# The model will load both settings.",
    "chunk_length": 2256
  },
  {
    "chunk_id": 83,
    "source": "pydantic_llms_data",
    "content": "```\n\n----------------------------------------\n\nTITLE: Handle literal_error in Pydantic\nDESCRIPTION: This error is raised when an input value is not one of the expected literal values defined for a field using `typing.Literal`. The example shows a field `x` restricted to literals 'a' or 'b', and passing 'c' triggers the 'literal_error' validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: Literal['a', 'b']\n\n\nModel(x='a')  # OK\n\ntry:\n    Model(x='c')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'literal_error'\n```\n\n----------------------------------------\n\nTITLE: Handle JSON Instantiation Type Mismatch Errors\nDESCRIPTION: Shows how Pydantic catches `ValidationError` when JSON data is invalid for models with custom generic types. The example uses `model_validate_json` with mismatched types in the JSON payload, demonstrating error reporting for missing fields. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    Model.model_validate_json(\n        '{\"car_owner\":{\"name\":\"John\",\"item\":{\"rooms\":3}},\"home_owner\":{\"name\":\"James\",\"item\":{\"color\":\"black\"}}}'\n    )\nexcept ValidationError as e:\n    print(e)\n\n```\n\n----------------------------------------\n\nTITLE: Handle json_type Error in Pydantic\nDESCRIPTION: This error is raised when the input value's type cannot be parsed as JSON for a `Json` field in Pydantic. The example shows passing `None` to a `Json` field, which is not a valid JSON type, resulting in a 'json_type' validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Json, ValidationError\n\n\nclass Model(BaseModel):\n    x: Json\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'json_type'\n```\n\n----------------------------------------\n\nTITLE: Parametrize Generic Class with String\nDESCRIPTION: Demonstrates parametrizing a generic class with specific types like `str` and `int`.",
    "chunk_length": 2283
  },
  {
    "chunk_id": 84,
    "source": "pydantic_llms_data",
    "content": "Shows how to instantiate and represent the resulting object, highlighting type-specific initialization. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nprint(ChildClass[str, int](x='1', y='y', z='3'))\n#> x=1 y='y' z=3\n```\n\n----------------------------------------\n\nTITLE: Customize JSON Schema $ref with ref_template in Python\nDESCRIPTION: Demonstrates customizing JSON schema $ref format using Pydantic's `ref_template` argument. This allows specifying custom paths for schema references, beneficial for OpenAPI integrations. The example shows a Pydantic model with nested structures and its generated schema with custom $ref paths. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel\nfrom pydantic.type_adapter import TypeAdapter\n\n\nclass Foo(BaseModel):\n    a: int\n\n\nclass Model(BaseModel):\n    a: Foo\n\n\nadapter = TypeAdapter(Model)\n\nprint(\n    json.dumps(\n        adapter.json_schema(ref_template='#/components/schemas/{model}'),\n        indent=2,\n    )\n)\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$defs\": {\n    \"Foo\": {\n      \"properties\": {\n        \"a\": {\n          \"title\": \"A\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"a\"\n      ],\n      \"title\": \"Foo\",\n      \"type\": \"object\"\n    }\n  },\n  \"properties\": {\n    \"a\": {\n      \"$ref\": \"#/components/schemas/Foo\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n```\n\n----------------------------------------\n\nTITLE: TypeAdapter Configuration\nDESCRIPTION: Demonstrates configuring a `TypeAdapter` with `ConfigDict` to enable `coerce_numbers_to_str` for type coercion. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, TypeAdapter\n\nta = TypeAdapter(list[str], config=ConfigDict(coerce_numbers_to_str=True))\n\nprint(ta.validate_python([1, 2]))\n#> ['1', '2']\n\n```\n\n----------------------------------------\n\nTITLE: TypeAdapter defer_build Support\nDESCRIPTION: Introduces experimental support for the 'defer_build' argument within Pydantic's TypeAdapter, allowing for deferred model building.",
    "chunk_length": 2284
  },
  {
    "chunk_id": 85,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_36\n\nLANGUAGE: APIDOC\nCODE:\n```\nTypeAdapter:\n  defer_build(value: Any, *, include: Include | None = None, exclude: Exclude | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, ...) -> Any\n    Allows deferring the model building process for a TypeAdapter. Parameters:\n      value: The input data to be processed. include: Fields to include in the output. exclude: Fields to exclude from the output. exclude_unset: Exclude fields that were not explicitly set. exclude_defaults: Exclude fields that have their default value. exclude_none: Exclude fields that are None. Returns: The processed data, potentially with deferred building. Note: This is an experimental feature. ```\n\n----------------------------------------\n\nTITLE: Reuse TypeAdapter Instance\nDESCRIPTION: Instantiating `TypeAdapter` repeatedly within a function can lead to performance degradation as new validators and serializers are constructed each time. Reusing a single instance of `TypeAdapter` is more efficient. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/performance.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\n\n# Bad practice: Instantiating adapter inside the function\ndef my_func_bad():\n    adapter = TypeAdapter(list[int])\n    # do something with adapter\n\n\n# Good practice: Instantiate adapter once and reuse\nadapter_good = TypeAdapter(list[int])\n\ndef my_func_good():\n    # do something with adapter_good\n```\n\n----------------------------------------\n\nTITLE: Handle less_than Error in Pydantic\nDESCRIPTION: This error is raised when an input value fails the `lt` (less than) constraint defined using `Field` in Pydantic. The example sets a field `x` to require a value less than 10, and passing 10 triggers the 'less_than' validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(lt=10)\n\n\ntry:\n    Model(x=10)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'less_than'\n```\n\n----------------------------------------\n\nTITLE: Mypy Plugin for BaseModel.__init__\nDESCRIPTION: Introduces a mypy plugin to improve type checking for `BaseModel.__init__` and other related aspects.",
    "chunk_length": 2447
  },
  {
    "chunk_id": 86,
    "source": "pydantic_llms_data",
    "content": "This enhances static analysis capabilities for Pydantic models. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_253\n\nLANGUAGE: APIDOC\nCODE:\n```\n# To enable the mypy plugin, add the following to your mypy.ini or setup.cfg:\n# [mypy]\n# plugins = pydantic.mypy\n\n# Example of what the plugin helps check:\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n# The plugin helps catch type errors in initialization:\n# user = User(id='1', name='Alice') # Mypy would flag 'id' type mismatch\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrate dataclass_type error in Pydantic\nDESCRIPTION: This example demonstrates the `dataclass_type` error, which is raised when a value is not valid for a dataclass field. It defines nested dataclasses and shows that passing an incorrect type (an integer instead of an `Inner` dataclass instance) for a nested field triggers this validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, dataclasses\n\n\n@dataclasses.dataclass\nclass Inner:\n    x: int\n\n\n@dataclasses.dataclass\nclass Outer:\n    y: Inner\n\n\nOuter(y=Inner(x=1))  # OK\n\ntry:\n    Outer(y=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'dataclass_type'\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Support typing.Annotated for Field hints\nDESCRIPTION: Demonstrates how to use `typing.Annotated` to specify Pydantic `Field` configurations directly within type hints. Other annotations are ignored but preserved. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_169\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\nfrom pydantic import BaseModel, Field\n\nclass MyModel(BaseModel):\n    my_field: Annotated[int, Field(gt=0, description=\"A positive integer\")]\n\n# get_type_hints(MyModel, include_extras=True) would show the Field details. ```\n\n----------------------------------------\n\nTITLE: Fetch and Validate Single User with httpx and Pydantic\nDESCRIPTION: Fetches user data from the JSONPlaceholder API using httpx and validates the response against a Pydantic BaseModel.",
    "chunk_length": 2238
  },
  {
    "chunk_id": 87,
    "source": "pydantic_llms_data",
    "content": "It demonstrates basic model creation and data retrieval for a single record. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/requests.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport httpx\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nurl = 'https://jsonplaceholder.typicode.com/users/1'\n\nresponse = httpx.get(url)\nresponse.raise_for_status()\n\nuser = User.model_validate(response.json())\nprint(repr(user))\n#> User(id=1, name='Leanne Graham', email='Sincere@april.biz')\n```\n\n----------------------------------------\n\nTITLE: Handle less_than_equal Error in Pydantic\nDESCRIPTION: This error is raised when an input value fails the `le` (less than or equal to) constraint defined using `Field` in Pydantic. The example sets a field `x` to require a value less than or equal to 10, and passing 11 triggers the 'less_than_equal' validation error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(le=10)\n\n\ntry:\n    Model(x=11)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'less_than_equal'\n```\n\n----------------------------------------\n\nTITLE: Python Version Support and Dependencies\nDESCRIPTION: Information on supported Python versions and changes related to code formatting and dependencies. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_299\n\nLANGUAGE: APIDOC\nCODE:\n```\nPython Support:\n  - Supported Python 3.7. Code Formatting:\n  - Moved codebase to use black for formatting. Dependency Changes:\n  - Breaking change: Removed msgpack parsing. ```\n\n----------------------------------------\n\nTITLE: Structural Pattern Matching on BaseModel\nDESCRIPTION: Adds support and documentation for structural pattern matching (PEP 636) on Pydantic's `BaseModel`, enabling more expressive data handling. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_88\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nclass Point(BaseModel):\n    x: int\n    y: int\n\ndef process_point(p):\n    match p:\n        case Point(x=0, y=0):\n            print(\"Origin\")\n        case Point(x=x_val, y=y_val):\n            print(f\"Point at ({x_val}, {y_val})\")\n\n# Example:\n# process_point(Point(x=1, y=2))\n```\n\n----------------------------------------\n\nTITLE: Configure Strict Mode with @validate_call in Pydantic\nDESCRIPTION: Illustrates enabling strict mode for function calls using the @validate_call decorator.",
    "chunk_length": 2638
  },
  {
    "chunk_id": 88,
    "source": "pydantic_llms_data",
    "content": "By passing config=ConfigDict(strict=True) to the decorator, Pydantic will strictly validate function arguments against their type hints, preventing implicit type coercion. The example shows a ValidationError when a string '1' is passed to an integer parameter. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, ValidationError, validate_call\n\n\n@validate_call(config=ConfigDict(strict=True))\ndef foo(x: int) -> int:\n    return x\n\n\ntry:\n    foo('1')\nexcept ValidationError as exc:\n    print(exc)\n    \n```\n\n----------------------------------------\n\nTITLE: Demonstrate date_type error in Pydantic\nDESCRIPTION: This example shows the `date_type` error, raised when the input value's type is invalid for a `date` field. It also covers strict fields where the input must be an instance of `date`. The snippet attempts to validate `None` for a `date` field, triggering the error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'date_type'\n\n# This error is also raised for strict fields when the input value is not an instance of `date`. ```\n\n----------------------------------------\n\nTITLE: Pydantic V2: Constrained Types Migration\nDESCRIPTION: Illustrates the migration from Pydantic V1's Constrained types (like ConstrainedInt) to Pydantic V2's use of Annotated with Field for defining constraints. It shows the old and new syntax. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n# Pydantic V1 syntax (removed in V2)\nfrom pydantic import BaseModel, ConstrainedInt\n\n\nclass MyIntV1(ConstrainedInt):\n    ge = 0\n\n\nclass ModelV1(BaseModel):\n    x: MyIntV1\n```\n\nLANGUAGE: python\nCODE:\n```\n# Pydantic V2 syntax\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nMyIntV2 = Annotated[int, Field(ge=0)]\n\n\nclass ModelV2(BaseModel):\n    x: MyIntV2\n```\n\n----------------------------------------\n\nTITLE: Exclude Invalid Fields from Pydantic JSON Schema\nDESCRIPTION: This example illustrates how to prevent fields that do not have a valid JSON schema representation (e.g., callables) from being included in the final schema.",
    "chunk_length": 2491
  },
  {
    "chunk_id": 89,
    "source": "pydantic_llms_data",
    "content": "This is achieved by overriding the `handle_invalid_for_json_schema` method to raise `PydanticOmit`, effectively omitting the field. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\nfrom pydantic_core import PydanticOmit, core_schema\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def handle_invalid_for_json_schema(\n        self, schema: core_schema.CoreSchema, error_info: str\n    ) -> JsonSchemaValue:\n        raise PydanticOmit\n\n\ndef example_callable():\n    return 1\n\n\nclass Example(BaseModel):\n    name: str = 'example'\n    function: Callable = example_callable\n\n\ninstance_example = Example()\n\nvalidation_schema = instance_example.model_json_schema(\n    schema_generator=MyGenerateJsonSchema, mode='validation'\n)\nprint(validation_schema)\n\"\"\"\n{\n    'properties': {\n        'name': {'default': 'example', 'title': 'Name', 'type': 'string'}\n    },\n    'title': 'Example',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Regex Anchoring Semantics Documentation\nDESCRIPTION: Clarifies the default behavior of regular expression anchoring within Pydantic's validation. This documentation update helps users understand how regex patterns are applied to input strings. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_219\n\nLANGUAGE: python\nCODE:\n```\n# Documentation update regarding regex anchoring. # Example: A regex like 'abc' might be implicitly anchored to match the whole string\n# depending on Pydantic's internal handling, which is now documented. ```\n\n----------------------------------------\n\nTITLE: Basic Default Values\nDESCRIPTION: Demonstrates setting default values for fields using direct assignment and the `Field` function with `default`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    # Both fields aren't required:\n    name: str = 'John Doe'\n    age: int = Field(default=20)\n```\n\n----------------------------------------\n\nTITLE: Generate JSON Schema with Pydantic `computed_field`\nDESCRIPTION: This example demonstrates how the `computed_field` decorator influences the JSON Schema generated for a Pydantic model.",
    "chunk_length": 2437
  },
  {
    "chunk_id": 90,
    "source": "pydantic_llms_data",
    "content": "It shows that computed properties like `volume` are included in the schema as read-only fields, ensuring they are part of the model's contract during serialization. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property  # (1)! def volume(self) -> float:\n        return self.width * self.height * self.depth\n\n\nprint(Box.model_json_schema(mode='serialization'))\n\"\"\"\n{\n    'properties': {\n        'width': {'title': 'Width', 'type': 'number'},\n        'height': {'title': 'Height', 'type': 'number'},\n        'depth': {'title': 'Depth', 'type': 'number'},\n        'volume': {'readOnly': True, 'title': 'Volume', 'type': 'number'}\n    },\n    'required': ['width', 'height', 'depth', 'volume'],\n    'title': 'Box',\n    'type': 'object'\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Pydantic v2 @field_validator with ValidationInfo\nDESCRIPTION: Demonstrates the usage of Pydantic v2's @field_validator decorator, showing how to access validation context via the 'info' parameter, including 'config' and 'field_name'. This replaces the older 'config' and 'field' arguments available in v1. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    def val_x(cls, v: int, info: ValidationInfo) -> int:\n        assert info.config is not None\n        print(info.config.get('title'))\n        # Expected output: Model\n        print(cls.model_fields[info.field_name].is_required())\n        # Expected output: True\n        return v\n\n\nModel(x=1)\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Use WithJsonSchema to Override JSON Schema Generation\nDESCRIPTION: The `WithJsonSchema` annotation allows overriding the generated JSON schema for a type without implementing schema generation methods.",
    "chunk_length": 2120
  },
  {
    "chunk_id": 91,
    "source": "pydantic_llms_data",
    "content": "It requires providing the full schema, including the 'type', and is preferred over manual implementation for simplicity. This example demonstrates overriding the schema for an integer type. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, WithJsonSchema\n\nMyInt = Annotated[\n    int,\n    WithJsonSchema({'type': 'integer', 'examples': [1, 0, -1]}),\n]\n\n\nclass Model(BaseModel):\n    a: MyInt\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n```\n\n----------------------------------------\n\nTITLE: Import Pydantic V1 Features (Universal)\nDESCRIPTION: Provides a robust method to import Pydantic V1 features, compatible with any Pydantic version (V1 or V2). It uses a try-except block to fall back to the V1 namespace if direct import fails. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    from pydantic.v1.fields import ModelField\nexcept ImportError:\n    from pydantic.fields import ModelField\n```\n\n----------------------------------------\n\nTITLE: Handle int_parsing_size Error in Pydantic\nDESCRIPTION: This error is raised when attempting to parse an integer from a string that exceeds the maximum range permitted by Python's str to int parsing. The example demonstrates triggering this error with both direct Python parsing and JSON parsing within Pydantic models. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\n# from Python\nassert Model(x='1' * 4_300).x == int('1' * 4_300)  # OK\n\ntoo_long = '1' * 4_301\ntry:\n    Model(x=too_long)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_parsing_size'\n\n# from JSON\ntry:\n    Model.model_validate_json(json.dumps({'x': too_long}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_parsing_size'\n```\n\n----------------------------------------\n\nTITLE: Pydantic `.json()` Method Deprecation\nDESCRIPTION: Highlights the deprecation of the `.json()` method in Pydantic V2, recommending the use of `model_dump_json()` instead.",
    "chunk_length": 2337
  },
  {
    "chunk_id": 92,
    "source": "pydantic_llms_data",
    "content": "It also notes potential issues with arguments like `indent` and provides a workaround. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_14\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic `.json()` Method Deprecation:\n\n- The `.json()` method for serializing models to JSON strings is deprecated in Pydantic V2. - Recommended Replacement: Use `model_dump_json()`. Reasons for Deprecation:\n- Potential for confusing errors when using arguments like `indent` or `ensure_ascii`. - `model_dump_json()` provides a more consistent and robust API. Workaround for Arguments:\nIf you need to use arguments like `indent` or `ensure_ascii` with the deprecated `.json()` method, a workaround involves using `model_dump()` first and then passing the result to Python's standard `json` module. Example Usage:\n```python\nimport json\nfrom pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    price: float\n\nitem = Item(name='Foo', price=12.50)\n\n# Recommended V2 approach:\njson_output_v2 = item.model_dump_json(indent=2)\nprint(json_output_v2)\n\n# Workaround for arguments if .json() must be used (not recommended):\n# This is to illustrate the workaround, but model_dump_json is preferred. # json_output_workaround = json.dumps(item.model_dump(), indent=2)\n# print(json_output_workaround)\n```\n```\n\n----------------------------------------\n\nTITLE: Pydantic Wrap Serializer - Annotated Pattern\nDESCRIPTION: Shows how to use WrapSerializer with the annotated pattern, allowing custom logic to be executed before or after Pydantic's default serialization by including a 'handler' parameter. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, SerializerFunctionWrapHandler, WrapSerializer\n\n\ndef ser_number(value: Any, handler: SerializerFunctionWrapHandler) -> int:\n    return handler(value) + 1\n\n\nclass Model(BaseModel):\n    number: Annotated[int, WrapSerializer(ser_number)]\n\n\nprint(Model(number=4).model_dump())\n#> {'number': 5}\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Use SkipJsonSchema to Skip Fields in JSON Schema\nDESCRIPTION: The `SkipJsonSchema` annotation is used to exclude a field or part of a field's specifications from the generated JSON schema.",
    "chunk_length": 2333
  },
  {
    "chunk_id": 93,
    "source": "pydantic_llms_data",
    "content": "This is useful for selectively omitting certain data from schema outputs. Refer to the API documentation for detailed usage and examples. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_13\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.json_schema.SkipJsonSchema\n\nDescription:\n  Used to skip an included field (or part of a field's specifications) from the generated JSON schema. Usage:\n  Apply the `SkipJsonSchema` annotation to a field or type to prevent its inclusion in the JSON schema. Related:\n  - `pydantic.json_schema.WithJsonSchema`: For overriding JSON schema generation. - Validators: For fine-tuning JSON schema of fields with validators using `json_schema_input_type`. ```\n\n----------------------------------------\n\nTITLE: Pydantic Inconsistency: Model Completion Status\nDESCRIPTION: Highlights an inconsistency in Pydantic's backward compatibility logic where a model defined within a function, referencing other types, might incorrectly report its completion status. This example shows a dataclass with forward references to 'Model' and 'Inner', and a BaseModel 'Model' within a function, leading to an unexpected '__pydantic_complete__' status. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass Foo:\n    # `a` and `b` shouldn't resolve:\n    a: 'Model'\n    b: 'Inner'\n\n\ndef func():\n    Inner = int\n\n    class Model(BaseModel):\n        foo: Foo\n\n    Model.__pydantic_complete__\n    #> True, should be False. ```\n\n----------------------------------------\n\nTITLE: TypeAdapter: Validate and Generate Schema for List[int]\nDESCRIPTION: Demonstrates creating a `TypeAdapter` for a `list[int]`, validating Python data against it, and generating its JSON schema. This showcases `TypeAdapter`'s ability to handle non-BaseModel types. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\nassert adapter.validate_python(['1', '2', '3']) == [1, 2, 3]\nprint(adapter.json_schema())\n#> {'items': {'type': 'integer'}, 'type': 'array'}\n```\n\n----------------------------------------\n\nTITLE: Merging Parent and Child Configuration\nDESCRIPTION: Shows how Pydantic merges configuration from parent and child models, prioritizing the child's configuration when conflicts arise.",
    "chunk_length": 2500
  },
  {
    "chunk_id": 94,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Parent(BaseModel):\n    model_config = ConfigDict(extra='allow', str_to_lower=False)\n\n\nclass Model(Parent):\n    model_config = ConfigDict(str_to_lower=True)\n\n    x: str\n\nm = Model(x='FOO', y='bar')\nprint(m.model_dump())\n#> {'x': 'foo', 'y': 'bar'}\nprint(Model.model_config)\n#> {'extra': 'allow', 'str_to_lower': True}\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic V2 Field Requirements and Nullability\nDESCRIPTION: Illustrates Pydantic V2's updated logic for field requirements and nullability, which now more closely matches Python dataclasses. It clarifies how `Optional` and `Any` annotations behave and how default values impact whether a field is required. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo(BaseModel):\n    f1: str  # required, cannot be None\n    f2: Optional[str]  # required, can be None - same as str | None\n    f3: Optional[str] = None  # not required, can be None\n    f4: str = 'Foobar'  # not required, but cannot be None\n\n\ntry:\n    # Example demonstrating validation errors for f1 being None\n    Foo(f1=None, f2=None, f4='b')\nexcept ValidationError as e:\n    print(e)\n    # Output will show validation error for f1\n    # 1 validation error for Foo\n    # f1\n    #   Input should be a valid string [type=string_type, input_value=None, input_type=NoneType]\n```\n\n----------------------------------------\n\nTITLE: Partial JSON List Parsing with pydantic_core.from_json\nDESCRIPTION: Demonstrates parsing incomplete JSON lists using `pydantic_core.from_json`. Shows how `allow_partial=False` raises an error for malformed JSON, while `allow_partial=True` deserializes the valid portion. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import from_json\n\npartial_json_data = '[\"aa\", \"bb\", \"c'\n\ntry:\n    result = from_json(partial_json_data, allow_partial=False)\nexcept ValueError as e:\n    print(e)\n    #> EOF while parsing a string at line 1 column 15\n\nresult = from_json(partial_json_data, allow_partial=True)\nprint(result)\n#> ['aa', 'bb']\n```\n\n----------------------------------------\n\nTITLE: Pydantic V2 model_dump_json() Compaction and Separators\nDESCRIPTION: Illustrates that Pydantic V2's `model_dump_json()` output is compacted for space efficiency and may differ from standard `json.dumps()`.",
    "chunk_length": 2644
  },
  {
    "chunk_id": 95,
    "source": "pydantic_llms_data",
    "content": "It shows how to match `json.dumps()` output by adjusting separators. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel as V2BaseModel\nfrom pydantic.v1 import BaseModel as V1BaseModel\n\n\nclass V1Model(V1BaseModel):\n    a: list[str]\n\n\nclass V2Model(V2BaseModel):\n    a: list[str]\n\n\nv1_model = V1Model(a=['fancy', 'sushi'])\nv2_model = V2Model(a=['fancy', 'sushi'])\n\n# V1\nprint(v1_model.json())\n#> {\"a\": [\"fancy\", \"sushi\"]}\n\n# V2\nprint(v2_model.model_dump_json())\n#> {\"a\":[\"fancy\",\"sushi\"]}\n\n# Plain json.dumps\nprint(json.dumps(v2_model.model_dump()))\n#> {\"a\": [\"fancy\", \"sushi\"]}\n\n# Modified json.dumps\nprint(json.dumps(v2_model.model_dump(), separators=(',', ':')))\n#> {\"a\":[\"fancy\",\"sushi\"]}\n```\n\n----------------------------------------\n\nTITLE: Pydantic JSON Serialization API Methods\nDESCRIPTION: Lists key API methods available in Pydantic for serializing data to JSON format, providing options for different use cases like BaseModel instances or TypeAdapter usage. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#_snippet_6\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.main.BaseModel.model_dump_json\npydantic.type_adapter.TypeAdapter.dump_json\npydantic_core.to_json\n```\n\n----------------------------------------\n\nTITLE: Accept empty query/fragment URL parts\nDESCRIPTION: Allows URL parsing to accept empty query or fragment parts. This improves flexibility when dealing with URLs that may omit these components. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_126\n\nLANGUAGE: python\nCODE:\n```\nAccept empty query/fragment URL parts, [#1807](https://github.com/pydantic/pydantic/pull/1807) by @xavier\n```\n\n----------------------------------------\n\nTITLE: Type Hints for `BaseSettings.Config`\nDESCRIPTION: Adds type hints to the `Config` inner class of `pydantic.BaseSettings`. This improves static analysis and helps avoid mypy errors, ensuring better compatibility with type checking tools. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_117\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n    class Config:\n        # Type hints added here for better mypy compatibility\n        env_file: str | None = None\n        env_file_encoding: str | None = None\n        env_prefix: str = ''\n        case_sensitive: bool = False\n        extra: str | None = None\n        # ...",
    "chunk_length": 2491
  },
  {
    "chunk_id": 96,
    "source": "pydantic_llms_data",
    "content": "other Config attributes\n```\n\n----------------------------------------\n\nTITLE: Pydantic BeforeValidator with Annotated Pattern\nDESCRIPTION: Demonstrates using `BeforeValidator` with `Annotated` to preprocess input before Pydantic's core validation. It shows how to ensure a value is a list, handling cases where a single item is provided, and how Pydantic still validates the processed item. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, BeforeValidator, ValidationError\n\n\ndef ensure_list(value: Any) -> Any:  # (1)! if not isinstance(value, list):  # (2)! return [value]\n    else:\n        return value\n\n\nclass Model(BaseModel):\n    numbers: Annotated[list[int], BeforeValidator(ensure_list)]\n\n\nprint(Model(numbers=2))\n#> numbers=[2]\ntry:\n    Model(numbers='str')\nexcept ValidationError as err:\n    print(err)  # (3)! \"\"\"\n    1 validation error for Model\n    numbers.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='str', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: RootModel Subclass with Custom Methods\nDESCRIPTION: Demonstrates creating a subclass of a parametrized `RootModel` and adding custom methods for enhanced functionality. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import RootModel\n\n\nclass Pets(RootModel[list[str]]):\n    def describe(self) -> str:\n        return f'Pets: {\", \".join(self.root)}'\n\n\nmy_pets = Pets.model_validate(['dog', 'cat'])\n\nprint(my_pets.describe())\n#> Pets: dog, cat\n```\n\n----------------------------------------\n\nTITLE: Adding Validators with create_model and field_validator\nDESCRIPTION: Demonstrates how to dynamically create a model with custom validators using `create_model` and the `field_validator` decorator. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, create_model, field_validator\n\n\ndef alphanum(cls, v):\n    assert v.isalnum(), 'must be alphanumeric'\n    return v\n\n\nvalidators = {\n    'username_validator': field_validator('username')(alphanum)  # (1)!",
    "chunk_length": 2340
  },
  {
    "chunk_id": 97,
    "source": "pydantic_llms_data",
    "content": "}\n\nUserModel = create_model(\n    'UserModel', username=(str, ...), __validators__=validators\n)\n\nuser = UserModel(username='scolvin')\nprint(user)\n#> username='scolvin'\n\ntry:\n    UserModel(username='scolvi%n')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for UserModel\n    username\n      Assertion failed, must be alphanumeric [type=assertion_error, input_value='scolvi%n', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic V1 to V2 Deprecated Features\nDESCRIPTION: This API documentation maps deprecated Pydantic V1 features to their corresponding locations or replacements in Pydantic V2. It serves as a reference for users updating their projects. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_35\n\nLANGUAGE: APIDOC\nCODE:\n```\nAPIDOC: Pydantic V1 to V2 Migration Guide\n\nDescription:\n  This guide details the migration path for deprecated Pydantic V1 features to Pydantic V2. It provides a direct mapping from V1 module/function paths to their V2 equivalents or new locations. Mappings:\n  - pydantic.tools.schema_of -> pydantic.deprecated.tools.schema_of\n  - pydantic.tools.parse_obj_as -> pydantic.deprecated.tools.parse_obj_as\n  - pydantic.tools.schema_json_of -> pydantic.deprecated.tools.schema_json_of\n  - pydantic.json.pydantic_encoder -> pydantic.deprecated.json.pydantic_encoder\n  - pydantic.validate_arguments -> pydantic.deprecated.decorator.validate_arguments\n  - pydantic.json.custom_pydantic_encoder -> pydantic.deprecated.json.custom_pydantic_encoder\n  - pydantic.json.ENCODERS_BY_TYPE -> pydantic.deprecated.json.ENCODERS_BY_TYPE\n  - pydantic.json.timedelta_isoformat -> pydantic.deprecated.json.timedelta_isoformat\n  - pydantic.decorator.validate_arguments -> pydantic.deprecated.decorator.validate_arguments\n  - pydantic.class_validators.validator -> pydantic.deprecated.class_validators.validator\n  - pydantic.class_validators.root_validator -> pydantic.deprecated.class_validators.root_validator\n  - pydantic.utils.deep_update -> pydantic.v1.utils.deep_update\n  - pydantic.utils.GetterDict -> pydantic.v1.utils.GetterDict\n  - pydantic.utils.lenient_issubclass -> pydantic.v1.utils.lenient_issubclass\n  - pydantic.utils.lenient_isinstance -> pydantic.v1.utils.lenient_isinstance\n  - pydantic.utils.is_valid_field -> pydantic.v1.utils.is_valid_field\n  - pydantic.utils.update_not_none -> pydantic.v1.utils.update_not_none\n  - pydantic.utils.import_string -> pydantic.v1.utils.import_string\n  - pydantic.utils.Representation -> pydantic.v1.utils.Representation\n  - pydantic.utils.ROOT_KEY -> pydantic.v1.utils.ROOT_KEY\n  - pydantic.utils.smart_deepcopy -> pydantic.v1.utils.smart_deepcopy\n  - pydantic.utils.sequence_like -> pydantic.v1.utils.sequence_like\n\nNotes:\n  - Features marked as 'deprecated' in V1 are often moved to a 'deprecated' submodule in V2.",
    "chunk_length": 2873
  },
  {
    "chunk_id": 98,
    "source": "pydantic_llms_data",
    "content": "- Some utilities are moved to a 'v1' submodule in V2 to maintain backward compatibility or indicate V1-specific behavior. ```\n\n----------------------------------------\n\nTITLE: Pydantic BaseSettings Secret Files\nDESCRIPTION: Introduces the ability for `BaseSettings` models to read sensitive configuration values from secret files. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_202\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n    api_key: str\n\n    class Config:\n        # Example: Specify a file to load secrets from\n        # secrets_dir = '/path/to/secrets'\n        # api_key will be loaded from a file named 'api_key' in secrets_dir\n        pass\n\n# settings = Settings()\n# print(settings.api_key)\n```\n\n----------------------------------------\n\nTITLE: SerializeAsAny Runtime Setting\nDESCRIPTION: Illustrates the use of the `serialize_as_any` runtime setting in Pydantic's serialization methods. Setting it to True enables duck typed serialization, similar to V1 behavior, while False uses V2 defaults. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    user1: User\n    user2: User\n\n\nuser = UserLogin(name='pydantic', password='password')\n\nouter_model = OuterModel(user1=user, user2=user)\nprint(outer_model.model_dump(serialize_as_any=True))  # (1)! print(outer_model.model_dump(serialize_as_any=False))  # (2)! ```\n\n----------------------------------------\n\nTITLE: Pydantic API Documentation\nDESCRIPTION: API reference for Pydantic serialization functions, including @field_serializer and @model_serializer. Details their usage, parameters, and modes ('plain', 'wrap'). SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_13\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.functional_serializers.model_serializer\n  Serializes an entire model.",
    "chunk_length": 2076
  },
  {
    "chunk_id": 99,
    "source": "pydantic_llms_data",
    "content": "Modes:\n    - 'plain': Called unconditionally. Can return any type. - 'wrap': Takes a 'handler' argument for custom pre/post processing. pydantic.field_serializer\n  Decorator to apply serialization to specific fields. Arguments:\n    *field_names: Names of fields to apply the serializer to. Use '*' for all fields. mode: 'plain' or 'wrap'. check_fields: Boolean, whether to check if fields exist on the model (default True). SerializerFunctionWrapHandler\n  A callable passed to 'wrap' mode serializers. It handles the default serialization process. ```\n\n----------------------------------------\n\nTITLE: Pydantic Web Template Inheritance\nDESCRIPTION: This snippet illustrates the Jinja2 template inheritance pattern used in the Pydantic project. It extends a base template and includes specific content blocks and partials for announcements and main content. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/theme/main.html#_snippet_0\n\nLANGUAGE: jinja\nCODE:\n```\n{% extends \"base.html\" %}\n{% block announce %}\n  {% include 'announce.html' ignore missing %}\n{% endblock %}\n{% block content %}\n  {{ super() }}\n  {% include 'mkdocs\\_run_deps.html' ignore missing %}\n{% endblock %}\n```\n\n----------------------------------------\n\nTITLE: Define Pydantic Model with Type Hints\nDESCRIPTION: Demonstrates defining a Pydantic `BaseModel` using Python type hints for data validation. It shows basic types, `Literal`, `Annotated` with constraints, and complex nested types for robust data structuring. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Literal\n\nfrom annotated_types import Gt\n\nfrom pydantic import BaseModel\n\n\nclass Fruit(BaseModel):\n    name: str  # (1)! color: Literal['red', 'green']  # (2)! weight: Annotated[float, Gt(0)]  # (3)! bazam: dict[str, list[tuple[int, bool, float]]]  # (4)! print(\n    Fruit(\n        name='Apple',\n        color='red',\n        weight=4.2,\n        bazam={'foobar': [(1, True, 0.1)]},\n    )\n)\n#> name='Apple' color='red' weight=4.2 bazam={'foobar': [(1, True, 0.1)]}\n```\n\n----------------------------------------\n\nTITLE: Create New Feature Branch\nDESCRIPTION: Steps to create a new Git branch for your contributions and make your changes.",
    "chunk_length": 2267
  },
  {
    "chunk_id": 100,
    "source": "pydantic_llms_data",
    "content": "This ensures that your work is isolated and can be easily tracked. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b my-new-feature-branch\n# Make your changes... ```\n\n----------------------------------------\n\nTITLE: Pydantic Model Creation and Validation\nDESCRIPTION: Covers methods and features related to creating and validating Pydantic models. This includes dynamic model creation and advanced validator usage. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_302\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Model Creation and Validation:\n\ncreate_model(name, **field_definitions)\n  - Dynamically creates a Pydantic model. @validate('*')\n  - Wildcard validator decorator that applies to all fields. @validator('field_name', always=True)\n  - Validator decorator that can be configured to run always. ```\n\n----------------------------------------\n\nTITLE: Python Mode Serialization with model_dump()\nDESCRIPTION: Demonstrates serializing Pydantic models to Python dictionaries using `model_dump()`. Shows default output and output with `by_alias=True`. Also illustrates converting to JSON-compatible types with `mode='json'`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass BarModel(BaseModel):\n    whatever: tuple[int, ...]\n\n\nclass FooBarModel(BaseModel):\n    banana: Optional[float] = 1.1\n    foo: str = Field(serialization_alias='foo_alias')\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': (1, 2)})\n\n# returns a dictionary:\nprint(m.model_dump())\n#> {'banana': 3.14, 'foo': 'hello', 'bar': {'whatever': (1, 2)}}\n\nprint(m.model_dump(by_alias=True))\n#> {'banana': 3.14, 'foo_alias': 'hello', 'bar': {'whatever': (1, 2)}}\n\nprint(m.model_dump(mode='json'))\n#> {'banana': 3.14, 'foo': 'hello', 'bar': {'whatever': [1, 2]}}\n```\n\n----------------------------------------\n\nTITLE: Pydantic Config Options\nDESCRIPTION: Details various configuration options available within Pydantic models, such as aliasing, error message templating, and whitespace stripping.",
    "chunk_length": 2233
  },
  {
    "chunk_id": 101,
    "source": "pydantic_llms_data",
    "content": "These settings control model behavior and validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_300\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Configuration:\n\nConfig.allow_population_by_alias: bool\n  - Allows population of model fields using their aliases. Config.error_msg_templates: dict\n  - Defines custom error message templates for validation errors. Config.anystr_strip_whitespace: bool\n  - Controls whether whitespace is automatically stripped from string fields. constr(strip_whitespace=True): kwarg\n  - Option for constrained string types to strip whitespace. ```\n\n----------------------------------------\n\nTITLE: Pydantic BaseModel Construct and Default Factory\nDESCRIPTION: Introduces support for `default_factory` with `BaseModel.construct` and deprecates `__field_defaults__`. Users should now use the `.get_default()` method on fields within the `__fields__` attribute. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_195\n\nLANGUAGE: python\nCODE:\n```\nclass MyModel:\n    # ... # Previously: __field_defaults__ = {...}\n    # Now: use default_factory with construct\n    # Access defaults via .get_default() on fields in __fields__\n```\n\n----------------------------------------\n\nTITLE: Using '__all__' for Sequence Exclusion in Pydantic\nDESCRIPTION: Demonstrates using the special '__all__' key with `exclude` to apply an exclusion pattern to all items within a sequence (list) in Pydantic models. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Hobby(BaseModel):\n    name: str\n    info: str\n\n\nclass User(BaseModel):\n    hobbies: list[Hobby]\n\n\nuser = User(\n    hobbies=[\n        Hobby(name='Programming', info='Writing code and stuff'),\n        Hobby(name='Gaming', info='Hell Yeah!!!'),\n    ],\n)\n\nprint(user.model_dump(exclude={'hobbies': {'__all__': {'info'}}}))\n#> {'hobbies': [{'name': 'Programming'}, {'name': 'Gaming'}]}\n```\n\n----------------------------------------\n\nTITLE: Pydantic Handling of `pathlib.Path`\nDESCRIPTION: Describes Pydantic's validation for `pathlib.Path` types, which involves simply passing the input value directly to the `Path(v)` constructor for instantiation and validation.",
    "chunk_length": 2285
  },
  {
    "chunk_id": 102,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_35\n\nLANGUAGE: APIDOC\nCODE:\n```\npathlib.Path:\n  Behavior: Simply uses the type itself for validation by passing the value to `Path(v)`. ```\n\n----------------------------------------\n\nTITLE: Pydantic Model Structural Pattern Matching (Python 3.10+)\nDESCRIPTION: Shows how Pydantic models support structural pattern matching (PEP 636) in Python 3.10+, allowing for concise matching against model attributes and extraction of values. This provides a clean syntax for handling different model states or types. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_60\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n\na = Pet(name='Bones', species='dog')\n\nmatch a:\n    # match `species` to 'dog', declare and initialize `dog_name`\n    case Pet(species='dog', name=dog_name):\n        print(f'{dog_name} is a dog')\n#> Bones is a dog\n    # default case\n    case _:\n        print('No dog matched')\n```\n\n----------------------------------------\n\nTITLE: ConfigDict validate_by_alias\nDESCRIPTION: Shows how `ConfigDict.validate_by_alias=True` (default) allows validation using field aliases. Demonstrates validation with `my_alias`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=True, validate_by_name=False)\n\n\nprint(repr(Model(my_alias='foo')))  # (1)! #> Model(my_field='foo')\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Validator (Before Mode)\nDESCRIPTION: Demonstrates a 'before' model validator in Pydantic, which runs prior to model instantiation. These validators receive raw input data and can transform or validate it before Pydantic's core validation process begins. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, model_validator\n\n\nclass UserModel(BaseModel):\n    username: str\n\n    @model_validator(mode='before')\n    @classmethod\n    def check_card_number_not_present(cls, data: Any) -> Any:  # (1)!",
    "chunk_length": 2405
  },
  {
    "chunk_id": 103,
    "source": "pydantic_llms_data",
    "content": "if isinstance(data, dict):  # (2)! if 'card_number' in data:\n                raise ValueError(\"'card_number' should not be included\")\n        return data\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Signature with Custom Init\nDESCRIPTION: Shows how Pydantic incorporates custom `__init__` methods into the generated model signature, ensuring that parameters defined in the custom initializer are correctly reflected. This allows for more control over model instantiation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_57\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\nfrom pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    id: int\n    info: str = 'Foo'\n\n    def __init__(self, id: int = 1, *, bar: str, **data) -> None:\n        \"\"\"My custom init!\"\"\"\n        super().__init__(id=id, bar=bar, **data)\n\n\nprint(inspect.signature(MyModel))\n#> (id: int = 1, *, bar: str, info: str = 'Foo') -> None\n```\n\n----------------------------------------\n\nTITLE: Pydantic Dataclass Configuration\nDESCRIPTION: Illustrates configuring Pydantic dataclasses using the `@dataclass` decorator with `ConfigDict` to set `str_max_length` and `validate_assignment=True`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config=ConfigDict(str_max_length=10, validate_assignment=True))\nclass User:\n    name: str\n\n\nuser = User(name='John Doe')\ntry:\n    user.name = 'x' * 20\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      String should have at most 10 characters [type=string_too_long, input_value='xxxxxxxxxxxxxxxxxxxx', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Asserting Type Hint Correctness\nDESCRIPTION: Demonstrates how to use `typing.assert_type` to verify type hint correctness for Pydantic constructs like `TypeAdapter`. This is crucial for ensuring static analysis tools correctly interpret Pydantic types.",
    "chunk_length": 2117
  },
  {
    "chunk_id": 104,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/tests/typechecking/README.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing_extensions import assert_type\n\nfrom pydantic import TypeAdapter\n\nta1 = TypeAdapter(int)\nassert_type(ta1, TypeAdapter[int])\n```\n\n----------------------------------------\n\nTITLE: Secrets Files Support in BaseSettings\nDESCRIPTION: Adds support for loading sensitive configuration values from 'secrets files' when using `BaseSettings`. This provides a secure way to manage credentials and other secrets, separating them from code and environment variables. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_193\n\nLANGUAGE: python\nCODE:\n```\n# BaseSettings secrets files support\n```\n\n----------------------------------------\n\nTITLE: Pydantic Alias Generators API\nDESCRIPTION: API reference for Pydantic's alias generation capabilities, focusing on how to customize field name transformations. Includes options for root heading display. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/config.md#_snippet_1\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.alias_generators:\n  options:\n    show_root_heading: true\n```\n\n----------------------------------------\n\nTITLE: Extending Base Model with Extra Fields via create_model\nDESCRIPTION: Shows how to create a new model that inherits from an existing Pydantic `BaseModel` by using `create_model` and specifying `__base__`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, create_model\n\n\nclass FooModel(BaseModel):\n    foo: str\n    bar: int = 123\n\n\nBarModel = create_model(\n    'BarModel',\n    apple=(str, 'russet'),\n    banana=(str, 'yellow'),\n    __base__=FooModel,\n)\nprint(BarModel)\n#> <class '__main__.BarModel'>\nprint(BarModel.model_fields.keys())\n#> dict_keys(['foo', 'bar', 'apple', 'banana'])\n```\n\n----------------------------------------\n\nTITLE: FailFast Annotation for Sequence Validation\nDESCRIPTION: Demonstrates the `FailFast` annotation in Pydantic v2.8+ for sequence types.",
    "chunk_length": 2092
  },
  {
    "chunk_id": 105,
    "source": "pydantic_llms_data",
    "content": "This feature allows validation to stop as soon as the first item in a sequence fails, improving performance at the cost of reduced error visibility for subsequent items. It requires Pydantic and `typing`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/performance.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import FailFast, TypeAdapter, ValidationError\n\nta = TypeAdapter(Annotated[list[bool], FailFast()])\ntry:\n    ta.validate_python([True, 'invalid', False, 'also invalid'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[bool]\n    1\n      Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value='invalid', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic create_model API Reference\nDESCRIPTION: A utility function for dynamically creating Pydantic models at runtime. It allows for the creation of models without defining them as classes beforehand, useful for flexible data handling. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/base_model.md#_snippet_1\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.create_model\n  options:\n    show_root_heading: true\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model from SQLAlchemy Instance\nDESCRIPTION: Demonstrates creating a Pydantic model from a SQLAlchemy ORM instance by setting `ConfigDict(from_attributes=True)`. This allows Pydantic to read attributes directly from the ORM object. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom sqlalchemy import ARRAY, String\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nfrom pydantic import BaseModel, ConfigDict, StringConstraints\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass CompanyOrm(Base):\n    __tablename__ = 'companies'\n\n    id: Mapped[int] = mapped_column(primary_key=True, nullable=False)\n    public_key: Mapped[str] = mapped_column(\n        String(20), index=True, nullable=False, unique=True\n    )\n    domains: Mapped[list[str]] = mapped_column(ARRAY(String(255)))\n\n\nclass CompanyModel(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    public_key: Annotated[str, StringConstraints(max_length=20)]\n    domains: list[Annotated[str, StringConstraints(max_length=255)]]\n\n\nco_orm = CompanyOrm(\n    id=123,\n    public_key='foobar',\n    domains=['example.com', 'foobar.com'],\n)\nprint(co_orm)\n# > <__main__.CompanyOrm object at 0x0123456789ab>\nco_model = CompanyModel.model_validate(co_orm)\nprint(co_model)\n# > id=123 public_key='foobar' domains=['example.com', 'foobar.com']\n\n```\n\n----------------------------------------\n\nTITLE: Packaging Updates\nDESCRIPTION: Details on dependency version bumps and build optimizations for Pydantic and pydantic-core.",
    "chunk_length": 2909
  },
  {
    "chunk_id": 106,
    "source": "pydantic_llms_data",
    "content": "These updates aim to improve build times and leverage performance enhancements. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nBump `ruff` from 0.9.2 to 0.9.5\nBump `pydantic-core` to v2.29.0\nUse locally-built rust with symbols & pgo\n```\n\n----------------------------------------\n\nTITLE: Pydantic ValidationError Handling\nDESCRIPTION: Demonstrates how to define Pydantic models, apply field validators, and catch/process ValidationError exceptions. It shows how to print the exception directly or access structured error details. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/errors.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError, field_validator\n\n\nclass Location(BaseModel):\n    lat: float = 0.1\n    lng: float = 10.1\n\n\nclass Model(BaseModel):\n    is_required: float\n    gt_int: int = Field(gt=42)\n    list_of_ints: list[int]\n    a_float: float\n    recursive_model: Location\n\n    @field_validator('a_float', mode='after')\n    @classmethod\n    def validate_float(cls, value: float) -> float:\n        if value > 2.0:\n            raise ValueError('Invalid float value')\n        return value\n\n\ndata = {\n    'list_of_ints': ['1', 2, 'bad'],\n    'a_float': 3.0,\n    'recursive_model': {'lat': 4.2, 'lng': 'New York'},\n    'gt_int': 21,\n}\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    # Expected output:\n    # 5 validation errors for Model\n    # is_required\n    #   Field required [type=missing, input_value={'list_of_ints': ['1', 2,...ew York'}, 'gt_int': 21}, input_type=dict]\n    # gt_int\n    #   Input should be greater than 42 [type=greater_than, input_value=21, input_type=int]\n    # list_of_ints.2\n    #   Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]\n    # a_float\n    #   Value error, Invalid float value [type=value_error, input_value=3.0, input_type=float]\n    # recursive_model.lng\n    #   Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='New York', input_type=str]\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e.errors())\n    # Expected output:\n    # [\n    #     {\n    #         'type': 'missing',\n    #         'loc': ('is_required',),\n    #         'msg': 'Field required',\n    #         'input': {\n    #             'list_of_ints': ['1', 2, 'bad'],\n    #             'a_float': 3.0,\n    #             'recursive_model': {'lat': 4.2, 'lng': 'New York'},\n    #             'gt_int': 21,\n    #         },\n    # ...",
    "chunk_length": 2620
  },
  {
    "chunk_id": 107,
    "source": "pydantic_llms_data",
    "content": "(rest of the errors)\n    # ]\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Badges in reStructuredText\nDESCRIPTION: Provides the syntax for including Pydantic version badges within reStructuredText documentation. These badges serve as visual indicators and links to the Pydantic project. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#_snippet_13\n\nLANGUAGE: rst\nCODE:\n```\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Default Values with Field (Python)\nDESCRIPTION: Illustrates using `pydantic.Field` to provide default values for model attributes. It highlights the requirement for `default` to be a keyword argument for type checkers like Pyright to correctly infer optional fields, and explains a limitation related to runtime vs. type-checker behavior. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Knight(BaseModel):\n    title: str = Field(default='Sir Lancelot')  # this is okay\n    age: int = Field(\n        23\n    )  # this works fine at runtime but will case an error for pyright\n\n\nlance = Knight()  # error: Argument missing for parameter \"age\"\n```\n\n----------------------------------------\n\nTITLE: Generate Schema for Callable Arguments\nDESCRIPTION: Shows how to use `generate_arguments_schema` to create a schema for a function's arguments. This schema can then be used with `SchemaValidator` to validate data (e.g., from JSON) into positional and keyword arguments for the function. The validated arguments can be bound to the function signature. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import SchemaValidator\n\nfrom pydantic.experimental.arguments_schema import generate_arguments_schema\n\n\ndef func(p: bool, *args: str, **kwargs: int) -> None: ...",
    "chunk_length": 2315
  },
  {
    "chunk_id": 108,
    "source": "pydantic_llms_data",
    "content": "arguments_schema = generate_arguments_schema(func=func)\n\nval = SchemaValidator(arguments_schema, config={'coerce_numbers_to_str': True})\n\nargs, kwargs = val.validate_json(\n    '{\"p\": true, \"args\": [\"arg1\", 1], \"kwargs\": {\"extra\": 1}}'\n)\nprint(args, kwargs)  # (1)! #> (True, 'arg1', '1') {'extra': 1}\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom inspect import signature\n\n# Assuming 'func', 'args', 'kwargs' are defined as above\nsignature(func).bind(*args, **kwargs).arguments\n#> {'p': True, 'args': ('arg1', '1'), 'kwargs': {'extra': 1}}\n```\n\n----------------------------------------\n\nTITLE: Configure Flake8 for Pydantic Linting\nDESCRIPTION: Configures Flake8 to extend the ignored linting rules, specifically for Pydantic-related errors (PYDXXX codes). This allows you to customize which linting suggestions are displayed. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/linting.md#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[flake8]\nextend-ignore = PYD001,PYD002\n```\n\n----------------------------------------\n\nTITLE: Generated Pydantic Models from JSON Schema\nDESCRIPTION: The Python code generated by datamodel-code-generator from the provided JSON Schema. It defines Pydantic models for 'Pet' and 'Person', including type hints, field descriptions, and constraints. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/datamodel_code_generator.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-05-19T15:07:31+00:00\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Pet(BaseModel):\n    name: str | None = None\n    age: int | None = None\n\n\nclass Person(BaseModel):\n    first_name: str = Field(description=\"The person's first name.\")\n    last_name: str = Field(description=\"The person's last name.\")\n    age: conint(ge=0) | None = Field(None, description='Age in years.')\n    pets: list[Pet] | None = None\n    comment: Any | None = None\n```\n\n----------------------------------------\n\nTITLE: Compare Pydantic Performance vs.",
    "chunk_length": 2093
  },
  {
    "chunk_id": 109,
    "source": "pydantic_llms_data",
    "content": "Pure Python\nDESCRIPTION: Benchmarks Pydantic's data validation performance against a pure Python implementation for parsing JSON and validating URLs. It highlights Pydantic's speed advantage, showing it to be significantly faster for common tasks. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport json\nimport timeit\nfrom urllib.parse import urlparse\n\nimport requests\n\nfrom pydantic import HttpUrl, TypeAdapter\n\nreps = 7\nnumber = 100\nr = requests.get('https://api.github.com/emojis')\nr.raise_for_status()\nemojis_json = r.content\n\n\ndef emojis_pure_python(raw_data):\n    data = json.loads(raw_data)\n    output = {}\n    for key, value in data.items():\n        assert isinstance(key, str)\n        url = urlparse(value)\n        assert url.scheme in ('https', 'http')\n        output[key] = url\n\n\nemojis_pure_python_times = timeit.repeat(\n    'emojis_pure_python(emojis_json)',\n    globals={\n        'emojis_pure_python': emojis_pure_python,\n        'emojis_json': emojis_json,\n    },\n    repeat=reps,\n    number=number,\n)\nprint(f'pure python: {min(emojis_pure_python_times) / number * 1000:0.2f}ms')\n#> pure python: 5.32ms\n\ntype_adapter = TypeAdapter(dict[str, HttpUrl])\nemojis_pydantic_times = timeit.repeat(\n    'type_adapter.validate_json(emojis_json)',\n    globals={\n        'type_adapter': type_adapter,\n        'HttpUrl': HttpUrl,\n        'emojis_json': emojis_json,\n    },\n    repeat=reps,\n    number=number,\n)\nprint(f'pydantic: {min(emojis_pydantic_times) / number * 1000:0.2f}ms')\n#> pydantic: 1.54ms\n\nprint(\n    f'Pydantic {min(emojis_pure_python_times) / min(emojis_pydantic_times):0.2f}x faster'\n)\n#> Pydantic 3.45x faster\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Dataclass Configuration\nDESCRIPTION: Illustrates how to configure Pydantic dataclasses using `ConfigDict` either via the decorator argument or the `__pydantic_config__` attribute, specifically for `validate_assignment`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict\nfrom pydantic.dataclasses import dataclass\n\n\n# Option 1 -- using the decorator argument:\n@dataclass(config=ConfigDict(validate_assignment=True))\nclass MyDataclass1:\n    a: int\n\n\n# Option 2 -- using an attribute:\n@dataclass\nclass MyDataclass2:\n    a: int\n\n    __pydantic_config__ = ConfigDict(validate_assignment=True)\n```\n\n----------------------------------------\n\nTITLE: Python: GenericModel with After Validator\nDESCRIPTION: Demonstrates a generic Pydantic model with a custom validator.",
    "chunk_length": 2620
  },
  {
    "chunk_id": 110,
    "source": "pydantic_llms_data",
    "content": "It shows how `model_validator(mode='after')` works on generic models, including output from validation and model printing. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Generic, Self, TypeVar\n\nfrom pydantic import BaseModel, model_validator\n\nT = TypeVar('T')\n\n\nclass GenericModel(BaseModel, Generic[T]):\n    a: T\n\n    @model_validator(mode='after')\n    def validate_after(self: Self) -> Self:\n        print('after validator running custom validation...')\n        return self\n\n\nclass Model(BaseModel):\n    inner: GenericModel[Any]\n\n\nm = Model.model_validate(Model(inner=GenericModel[int](a=1)))\nprint(repr(m))\n```\n\n----------------------------------------\n\nTITLE: Dataclass Init=False and Extra=Allow Incompatibility in Pydantic\nDESCRIPTION: Pydantic disallows the combination of `extra='allow'` with fields set to `init=False` on a dataclass. This prevents potential conflicts during schema building. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config=ConfigDict(extra='allow'))\nclass A:\n    a: int = Field(init=False, default=1)\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Parsing with `Union` and `Literal` for Type Specificity\nDESCRIPTION: Shows how to order types in a `typing.Union` with `typing.Literal` to parse data into the most specific matching Pydantic model. Demonstrates how Pydantic resolves types based on the order in the union and literal values, allowing for hierarchical parsing. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Optional, Union\n\nfrom pydantic import BaseModel\n\n\nclass Dessert(BaseModel):\n    kind: str\n\n\nclass Pie(Dessert):\n    kind: Literal['pie']\n    flavor: Optional[str]\n\n\nclass ApplePie(Pie):\n    flavor: Literal['apple']\n\n\nclass PumpkinPie(Pie):\n    flavor: Literal['pumpkin']\n\n\nclass Meal(BaseModel):\n    dessert: Union[ApplePie, PumpkinPie, Pie, Dessert]\n\n\nprint(type(Meal(dessert={'kind': 'pie', 'flavor': 'apple'}).dessert).__name__)\n#> ApplePie\nprint(type(Meal(dessert={'kind': 'pie', 'flavor': 'pumpkin'}).dessert).__name__)\n#> PumpkinPie\nprint(type(Meal(dessert={'kind': 'pie'}).dessert).__name__)\n#> Dessert\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\n#> Dessert\n```\n\n----------------------------------------\n\nTITLE: Pydantic validate_call API Reference\nDESCRIPTION: Provides details on the pydantic.validate_call decorator, its purpose, and how it leverages type annotations for argument validation and coercion.",
    "chunk_length": 2786
  },
  {
    "chunk_id": 111,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#_snippet_1\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.validate_call\n\nDecorator to validate function arguments using Pydantic models and type annotations. Purpose:\n  Allows arguments passed to a function to be parsed and validated using the function's annotations before the function is called. It simplifies applying validation with minimal boilerplate. Usage:\n  Apply the decorator directly above the function definition. @validate_call\n  def my_function(arg1: str, arg2: int):\n      # function body\n      pass\n\nParameter Types:\n  - Parameter types are inferred from type annotations on the function. - If a parameter is not annotated, it defaults to `typing.Any`. - Supports all Pydantic-compatible types, including Pydantic models and custom types. Type Coercion:\n  - By default, types are coerced before being passed to the function. - For example, a string input for a `datetime.date` annotated parameter will be automatically converted to a `date` object. - This behavior can be controlled, for instance, by enabling strict mode. Return Value Validation:\n  - By default, the return value of the function is NOT validated. - To enable return value validation, set `validate_return=True` when applying the decorator:\n    `@validate_call(validate_return=True)`\n\nDependencies:\n  - Requires Pydantic library. Error Handling:\n  - Raises `pydantic.ValidationError` if argument validation fails. - The exception object contains details about the validation errors, including input values and expected types. Related Concepts:\n  - Validators (see Pydantic documentation for details on underlying validation mechanisms). - Type Annotations (PEP 526). - Data Conversion in Pydantic Models. - Strict Mode for Pydantic validation. ```\n\n----------------------------------------\n\nTITLE: Use Stdlib Dataclasses with Pydantic BaseModel\nDESCRIPTION: Explains how standard library dataclasses used within Pydantic models undergo validation. Covers the use of `ConfigDict(revalidate_instances='always')` and handling frozen dataclasses.",
    "chunk_length": 2109
  },
  {
    "chunk_id": 112,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\n@dataclasses.dataclass(frozen=True)\nclass User:\n    name: str\n\n\nclass Foo(BaseModel):\n    # Required so that pydantic revalidates the model attributes:\n    model_config = ConfigDict(revalidate_instances='always')\n\n    user: Optional[User] = None\n\n\n# nothing is validated as expected:\nuser = User(name=['not', 'a', 'string'])\nprint(user)\n#> User(name=['not', 'a', 'string'])\n\n\ntry:\n    Foo(user=user)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    user.name\n      Input should be a valid string [type=string_type, input_value=['not', 'a', 'string'], input_type=list]\n    \"\"\"\n\nfoo = Foo(user=User(name='pika'))\ntry:\n    foo.user.name = 'bulbi'\nexcept dataclasses.FrozenInstanceError as e:\n    print(e)\n    #> cannot assign to field 'name'\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Core Schema and Validation API References\nDESCRIPTION: This section provides references to key classes and methods within Pydantic and `pydantic-core` that are central to schema generation, validation, and serialization. It outlines their roles in handling core schemas, JSON schemas, and model operations. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#_snippet_8\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.json_schema.GenerateJsonSchema:\n  Description: Class responsible for generating JSON Schema from a core schema. Methods:\n    generate(core_schema: CoreSchema) -> dict: Main entry point for JSON Schema generation. bool_schema(bool_core_schema: CoreSchema) -> dict: Generates JSON Schema for boolean types. pydantic_core.SchemaValidator:\n  Description: Class for validating data against a core schema. Methods:\n    validate_python(data: Any) -> Any: Validates Python data against the model's core schema. pydantic_core.SchemaSerializer:\n  Description: Class for serializing data from a core schema.",
    "chunk_length": 2109
  },
  {
    "chunk_id": 113,
    "source": "pydantic_llms_data",
    "content": "Methods:\n    to_python(instance: Any) -> Any: Serializes a model instance's data based on its core schema. pydantic.GetCoreSchemaHandler:\n  Description: Handler passed to __get_pydantic_core_schema__ for recursive schema generation. Methods:\n    __call__(source: Any) -> CoreSchema: Recursively calls other __get_pydantic_core_schema__ methods. ```\n\n----------------------------------------\n\nTITLE: Pydantic create_model Default Module\nDESCRIPTION: Changes the default value of the `__module__` argument in `create_model` from `None` to `'pydantic.main'`, improving pickling support for created models. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_211\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import create_model\n\n# Previously, __module__ defaulted to None, which could cause pickling issues. # Now, it defaults to 'pydantic.main' for better pickling. MyDynamicModel = create_model('MyDynamicModel', __module__='my_app.models', field1=(str, ...))\n\n# If __module__ is not provided, it will be 'pydantic.main' by default. # AnotherDynamicModel = create_model('AnotherDynamicModel', field2=(int, 0))\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Schema Ref Template\nDESCRIPTION: Introduces support for `ref_template` when creating schema `$ref`s, allowing customization of how references are formatted in generated schemas. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_215\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass Item(BaseModel):\n    name: str\n\nclass Container(BaseModel):\n    item: Item\n\n    class Config:\n        # Custom template for schema references\n        # Example: Use a specific prefix for all internal references\n        ref_template = '#/components/schemas/{model}'\n\n# When generating schema for Container, the reference to Item will use the custom template. ```\n\n----------------------------------------\n\nTITLE: Pydantic Mypy Plugin Setting: warn_required_dynamic_aliases\nDESCRIPTION: Documentation for the `warn_required_dynamic_aliases` setting, explaining its purpose when using dynamically-determined aliases or alias generators on a model with `validate_by_name` set to `False`.",
    "chunk_length": 2205
  },
  {
    "chunk_id": 114,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#_snippet_6\n\nLANGUAGE: APIDOC\nCODE:\n```\nwarn_required_dynamic_aliases: bool\n  Description: Whether to error when using a dynamically-determined alias or alias generator on a model with `validate_by_name` set to `False`. Impact: If such aliases are present, mypy cannot properly type check calls to `__init__`. In this case, it will default to treating all arguments as not required. ```\n\n----------------------------------------\n\nTITLE: Pydantic: ConfigDict Extra Data Options\nDESCRIPTION: Details the three possible values for the `extra` configuration option in Pydantic's `ConfigDict`: 'ignore' (default), 'forbid', and 'allow'. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_15\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydanticConfigDict.extra:\n  Controls how Pydantic handles fields not defined in the model. Values:\n  - 'ignore': (Default) Extra fields are ignored and not stored. - 'forbid': Extra fields cause a validation error. - 'allow': Extra fields are allowed and stored in the `__pydantic_extra__` attribute. Example:\n  ```python\n  from pydantic import BaseModel, ConfigDict\n\n  class MyModel(BaseModel):\n      id: int\n      model_config = ConfigDict(extra='allow')\n  \n  # Instance with extra data\n  m = MyModel(id=1, name='test', value=100)\n  # m.model_dump() -> {'id': 1, 'name': 'test', 'value': 100}\n  # m.__pydantic_extra__ -> {'name': 'test', 'value': 100}\n  ```\n```\n\n----------------------------------------\n\nTITLE: Pydantic V2 Regex Engine and Performance\nDESCRIPTION: Explains that Pydantic V2 uses the Rust `regex` crate instead of Python's `re` library for pattern validation. This change offers linear time searching and drops lookarounds/backreferences for performance and security, with an option to revert to Python's regex via `regex_engine` config. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_25\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Regex Engine:\n  - Uses Rust `regex` crate by default.",
    "chunk_length": 2063
  },
  {
    "chunk_id": 115,
    "source": "pydantic_llms_data",
    "content": "- Offers linear time searching. - Drops lookarounds and backreferences for performance/security. - For Python `re` compatibility: use `ConfigDict(regex_engine='python')`. ```\n\n----------------------------------------\n\nTITLE: TypeAdapter for Parsing Data into BaseModel Lists\nDESCRIPTION: Illustrates using TypeAdapter to parse raw data into a list of Pydantic BaseModel instances. This functionality is similar to BaseModel.model_validate but works with any Pydantic-compatible type, including lists of models. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/type_adapter.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass Item(BaseModel):\n    id: int\n    name: str\n\n\n# `item_data` could come from an API call, eg., via something like:\n# item_data = requests.get('https://my-api.com/items').json()\nitem_data = [{'id': 1, 'name': 'My Item'}]\n\nitems = TypeAdapter(list[Item]).validate_python(item_data)\nprint(items)\n#> [Item(id=1, name='My Item')]\n```\n\n----------------------------------------\n\nTITLE: Disabling Pydantic Experimental Warnings\nDESCRIPTION: Provides a Python code snippet to suppress `PydanticExperimentalWarning` messages. This is useful for users who want to avoid repeated warnings when working with experimental features. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/version-policy.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\n\nfrom pydantic import PydanticExperimentalWarning\n\nwarnings.filterwarnings('ignore', category=PydanticExperimentalWarning)\n```\n\n----------------------------------------\n\nTITLE: Pydantic Typing Utilities\nDESCRIPTION: A collection of type aliases and utility functions for working with Python's typing system within Pydantic. These include custom type definitions and helper functions for introspection and manipulation of type hints. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_36\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.typing:\n  AbstractSetIntStr: Alias for typing.AbstractSet[IntStr]\n  AnyCallable: Alias for typing.Callable\n  AnyClassMethod: Alias for typing.Callable[..., Any]\n  CallableGenerator: Alias for typing.Callable[..., Generator[Any, None, None]]\n  DictAny: Alias for typing.Dict[Any, Any]\n  DictIntStrAny: Alias for typing.Dict[IntStr, Any]\n  DictStrAny: Alias for typing.Dict[str, Any]\n  IntStr: Alias for typing.Union[int, str]\n  ListStr: Alias for typing.List[str]\n  MappingIntStrAny: Alias for typing.Mapping[IntStr, Any]\n  NoArgAnyCallable: Alias for typing.Callable[[], Any]\n  NoneType: Alias for type(None)\n  ReprArgs: Alias for typing.Tuple[str, ...]\n  SetStr: Alias for typing.Set[str]\n  StrPath: Alias for typing.Union[str, pathlib.Path]\n  TupleGenerator: Alias for typing.Tuple[Generator[Any, None, None], ...]\n  WithArgsTypes: Alias for typing.Union[typing.Tuple[type, ...], typing.Tuple[typing.TypeVar, ...]]\n  all_literal_values(tp: type) -> typing.List[Any]\n    Returns a list of all values for a Literal type.",
    "chunk_length": 3011
  },
  {
    "chunk_id": 116,
    "source": "pydantic_llms_data",
    "content": "display_as_type(tp: type) -> str\n    Returns a string representation of a type. get_all_type_hints(tp: type, include_extras: bool = False) -> typing.Dict[str, type]\n    Get all type hints for a class, including inherited ones. get_args(tp: type) -> typing.Tuple[type, ...]\n    Get the arguments of a generic type. get_origin(tp: type) -> typing.Optional[type]\n    Get the origin of a generic type. get_sub_types(tp: type) -> typing.List[type]\n    Get the subtypes of a union type. is_callable_type(tp: type) -> bool\n    Check if a type is a callable type. is_classvar(tp: type) -> bool\n    Check if a type is a ClassVar. is_finalvar(tp: type) -> bool\n    Check if a type is a Final variable. is_literal_type(tp: type) -> bool\n    Check if a type is a Literal type. is_namedtuple(tp: type) -> bool\n    Check if a type is a namedtuple. is_new_type(tp: type) -> bool\n    Check if a type is a NewType. is_none_type(tp: type) -> bool\n    Check if a type is None. is_typeddict(tp: type) -> bool\n    Check if a type is a TypedDict. is_typeddict_special(tp: type) -> bool\n    Check if a type is a special TypedDict. is_union(tp: type) -> bool\n    Check if a type is a Union. new_type_supertype(tp: type) -> type\n    Get the supertype of a NewType. resolve_annotations(tp: type) -> typing.Dict[str, type]\n    Resolve forward references in type annotations. typing_base(tp: type) -> type\n    Get the base type of a generic type. update_field_forward_refs(tp: type, **localns: typing.Any) -> None\n    Update forward references in a model's fields. update_model_forward_refs(tp: type, **localns: typing.Any) -> None\n    Update forward references in a model's fields. ```\n\n----------------------------------------\n\nTITLE: Fix configuration declarations as kwargs\nDESCRIPTION: Corrects a bug where configuration declarations passed as keyword arguments during class creation were not handled properly. This ensures configurations are applied as expected. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_129\n\nLANGUAGE: python\nCODE:\n```\nFix bug with configurations declarations that are passed as\n  keyword arguments during class creation, [#2532](https://github.com/pydantic/pydantic/pull/2532) by @uriyyo\n```\n\n----------------------------------------\n\nTITLE: Partial JSON Validation with `experimental_allow_partial`\nDESCRIPTION: Demonstrates using `TypeAdapter` with `experimental_allow_partial=True` to validate JSON strings where the last field might be incomplete or invalid.",
    "chunk_length": 2492
  },
  {
    "chunk_id": 117,
    "source": "pydantic_llms_data",
    "content": "Errors in the last field are ignored, allowing partial data to pass validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict, total=False):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\n\nta = TypeAdapter(Foobar)\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12', experimental_allow_partial=True  # (1)! )\nprint(v)\n#> {'a': 1}\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12\"}', experimental_allow_partial=True  # (2)! )\nprint(v)\n#> {'a': 1}\n```\n\n----------------------------------------\n\nTITLE: JSON Schema for String Constraints\nDESCRIPTION: Illustrates the JSON schema generated by Pydantic for string constraints, showing how 'min_length', 'max_length', and 'pattern' are translated to 'minLength', 'maxLength', and 'pattern' respectively. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"title\": \"Foo\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"short\": {\n      \"title\": \"Short\",\n      \"type\": \"string\",\n      \"minLength\": 3\n    },\n    \"long\": {\n      \"title\": \"Long\",\n      \"type\": \"string\",\n      \"maxLength\": 10\n    },\n    \"regex\": {\n      \"title\": \"Regex\",\n      \"type\": \"string\",\n      \"pattern\": \"^\\\\d*$\"\n    }\n  },\n  \"required\": [\n    \"short\",\n    \"long\",\n    \"regex\"\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Pydantic Handling of `typing.Any`\nDESCRIPTION: Describes Pydantic's behavior when encountering `typing.Any`, indicating it allows any value, including `None`, without performing specific validation beyond basic type checking. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_31\n\nLANGUAGE: APIDOC\nCODE:\n```\ntyping.Any:\n  Description: Allows any value, including `None`. ```\n\n----------------------------------------\n\nTITLE: Pydantic Annotated Field Constraints\nDESCRIPTION: Demonstrates using `Annotated` with Pydantic `Field` for constraints, highlighting potential issues with compound types and recommending `Annotated` for safety.",
    "chunk_length": 2233
  },
  {
    "chunk_id": 118,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    positive: Optional[Annotated[int, Field(gt=0)]]\n    # Can error in some cases, not recommended:\n    non_negative: Optional[int] = Field(ge=0)\n\n```\n\n----------------------------------------\n\nTITLE: Settings and Aliases\nDESCRIPTION: Fixes and improvements related to the use of aliases within Pydantic settings. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_297\n\nLANGUAGE: APIDOC\nCODE:\n```\nSettings Aliases:\n  - Fixed alias use in settings. ```\n\n----------------------------------------\n\nTITLE: Pydantic Data Validation Methods\nDESCRIPTION: This section documents the primary methods Pydantic offers for validating and parsing data into model instances. It covers their purpose, typical usage, and how they handle validation errors. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_20\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Data Validation:\n\nProvides methods on model classes for parsing and validating data. 1. model_validate(data: Any, *, strict: bool | None = None, context: dict | None = None)\n   - Parses and validates data from a dictionary or object into a Pydantic model instance. - Similar to the model's __init__ but accepts a dictionary or object directly. - Raises ValidationError if the data cannot be validated or is not a dictionary/model instance. - Parameters:\n     - data: The dictionary or object to validate. - strict: If True, disables all coercion and validation. - context: Optional context to pass to validators. - Returns: A validated model instance. - Example:\n     ```python\n     from pydantic import BaseModel\n     class User(BaseModel):\n         id: int\n     m = User.model_validate({'id': 123})\n     ```\n\n2. model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, context: dict | None = None)\n   - Parses and validates data from a JSON string or bytes object into a Pydantic model instance.",
    "chunk_length": 2140
  },
  {
    "chunk_id": 119,
    "source": "pydantic_llms_data",
    "content": "- Generally faster than manually parsing JSON to a dictionary before validation. - Raises ValidationError for invalid JSON or validation failures. - Parameters:\n     - json_data: The JSON string or bytes to validate. - strict: If True, disables all coercion and validation. - context: Optional context to pass to validators. - Returns: A validated model instance. - Example:\n     ```python\n     from pydantic import BaseModel\n     class User(BaseModel):\n         id: int\n     m = User.model_validate_json('{\"id\": 123}')\n     ```\n\n3. model_validate_strings(data: dict, *, strict: bool | None = None, context: dict | None = None)\n   - Parses and validates data from a dictionary with string keys and values. - Validates data in JSON mode, allowing strings to be coerced into correct types. - Useful for data originating from non-JSON sources where values might be strings. - Raises ValidationError for validation failures. - Parameters:\n     - data: The dictionary with string keys and values to validate. - strict: If True, disables all coercion and validation. - context: Optional context to pass to validators. - Returns: A validated model instance. - Example:\n     ```python\n     from pydantic import BaseModel\n     class User(BaseModel):\n         id: int\n     m = User.model_validate_strings({'id': '123'})\n     ```\n\nRelated Concepts:\n- ValidationError: Raised when data validation fails. - ConfigDict.revalidate_instances: Controls whether model instances passed to model_validate are re-validated. ```\n\n----------------------------------------\n\nTITLE: Validate INI Data with Pydantic in Python\nDESCRIPTION: Validates data from an INI file using Pydantic. It uses Python's `configparser` to read the INI file and then validates a specific section against a Pydantic model. Requires `pydantic` library. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport configparser\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nconfig = configparser.ConfigParser()\nconfig.read('person.ini')\nperson = Person.model_validate(config['PERSON'])\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```\n\n----------------------------------------\n\nTITLE: Fetch and Validate List of Users with httpx and TypeAdapter\nDESCRIPTION: Retrieves a list of users from the JSONPlaceholder API using httpx and validates the entire list using Pydantic's TypeAdapter.",
    "chunk_length": 2512
  },
  {
    "chunk_id": 120,
    "source": "pydantic_llms_data",
    "content": "This showcases handling collections of Pydantic models efficiently. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/requests.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pprint import pprint\n\nimport httpx\n\nfrom pydantic import BaseModel, EmailStr, TypeAdapter\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nurl = 'https://jsonplaceholder.typicode.com/users/'  # (1)! response = httpx.get(url)\nresponse.raise_for_status()\n\nusers_list_adapter = TypeAdapter(list[User])\n\nusers = users_list_adapter.validate_python(response.json())\npprint([u.name for u in users])\n\"\"\"\n['Leanne Graham',\n 'Ervin Howell',\n 'Clementine Bauch',\n 'Patricia Lebsack',\n 'Chelsey Dietrich',\n 'Mrs. Dennis Schulist',\n 'Kurtis Weissnat',\n 'Nicholas Runolfsdottir V',\n 'Glenna Reichert',\n 'Clementina DuBuque']\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Pydantic JSON in Environment Variables\nDESCRIPTION: Explains the feature allowing JSON strings in environment variables to be parsed for complex Pydantic types, simplifying configuration management. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_306\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic JSON in Environment Variables:\n\nAllows complex types (like lists or dictionaries) to be configured via environment variables by providing their values as JSON strings. Example:\n  MY_SETTING='{\"key\": \"value\"}'\n  MY_LIST='[1, 2, 3]'\n```\n\n----------------------------------------\n\nTITLE: Update Version and Lock File\nDESCRIPTION: Manually edits the `pydantic/version.py` file to set the new version number. Subsequently, it updates the lock file using `uv lock` to reflect these changes. SOURCE: https://github.com/pydantic/pydantic/blob/main/release/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nuv lock -P pydantic\n```\n\n----------------------------------------\n\nTITLE: Partial JSON Dictionary Parsing with pydantic_core.from_json\nDESCRIPTION: Illustrates parsing incomplete JSON dictionaries using `pydantic_core.from_json` with `allow_partial=True`.",
    "chunk_length": 2052
  },
  {
    "chunk_id": 121,
    "source": "pydantic_llms_data",
    "content": "This enables deserialization of JSON objects even when they are missing closing braces or trailing commas. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import from_json\n\npartial_dog_json = '{\"breed\": \"lab\", \"name\": \"fluffy\", \"friends\": [\"buddy\", \"spot\", \"rufus\"], \"age'\n\ndog_dict = from_json(partial_dog_json, allow_partial=True)\nprint(dog_dict)\n#> {'breed': 'lab', 'name': 'fluffy', 'friends': ['buddy', 'spot', 'rufus']}\n```\n\n----------------------------------------\n\nTITLE: JSON Schema Generation Customization with GenerateJsonSchema\nDESCRIPTION: Shows how to customize JSON schema generation in Pydantic V2 by subclassing `GenerateJsonSchema` and passing the custom generator to methods like `model_json_schema` or `TypeAdapter.json_schema`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.json_schema import GenerateJsonSchema\n\nclass CustomSchemaGenerator(GenerateJsonSchema):\n    # Override methods here to customize schema generation\n    pass\n\n# Example usage with BaseModel\n# MyModel.model_json_schema(schema_generator=CustomSchemaGenerator)\n\n# Example usage with TypeAdapter\n# adapter.json_schema(schema_generator=CustomSchemaGenerator)\n```\n\n----------------------------------------\n\nTITLE: Type Support and Additions\nDESCRIPTION: Information on new types supported by Pydantic, including custom types and standard library types. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_295\n\nLANGUAGE: APIDOC\nCODE:\n```\nNew Types:\n  - Added `UrlStr` and `urlstr` types. - Added `FilePath` and `DirectoryPath` types. - Added `Json` type support. - Added `NewType` support. - Allowed `Pattern` type. - Allowed arbitrary types in models. Type Handling:\n  - Allowed `timedelta` objects as values for properties of type `timedelta`. - Supported tuples. ```\n\n----------------------------------------\n\nTITLE: Import Pydantic V1 BaseModel\nDESCRIPTION: Shows how to import the BaseModel class from the Pydantic V1 namespace.",
    "chunk_length": 2111
  },
  {
    "chunk_id": 122,
    "source": "pydantic_llms_data",
    "content": "This is part of the strategy to use Pydantic V1 features within a Pydantic V2 environment. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.v1 import BaseModel\n```\n\n----------------------------------------\n\nTITLE: ConfigDict validate_by_alias and validate_by_name\nDESCRIPTION: Demonstrates using both `validate_by_alias=True` and `validate_by_name=True`, allowing validation via either alias or attribute name. Shows validation using `my_alias` and `my_field`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=True, validate_by_name=True)\n\n\nprint(repr(Model(my_alias='foo')))  # (1)! #> Model(my_field='foo')\n\nprint(repr(Model(my_field='foo')))  # (2)! #> Model(my_field='foo')\n```\n\n----------------------------------------\n\nTITLE: Static Model with Aliases, Descriptions, and Private Attributes\nDESCRIPTION: Defines a static Pydantic model with field aliases, descriptions via `Annotated`, and private attributes. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, PrivateAttr\nfrom typing import Annotated\n\nclass StaticModel(BaseModel):\n    foo: str = Field(alias='FOO')\n    bar: Annotated[str, Field(description='Bar field')]\n    _private: int = PrivateAttr(default=1)\n```\n\n----------------------------------------\n\nTITLE: Pydantic TypeVar Support\nDESCRIPTION: Demonstrates Pydantic's support for Python's TypeVar, including unconstrained, bound, and constrained TypeVars. Shows how these generic types are used within Pydantic models for flexible data validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nfrom pydantic import BaseModel\n\nFoobar = TypeVar('Foobar')\nBoundFloat = TypeVar('BoundFloat', bound=float)\nIntStr = TypeVar('IntStr', int, str)\n\n\nclass Model(BaseModel):\n    a: Foobar  # equivalent of \": Any\"\n    b: BoundFloat  # equivalent of \": float\"\n    c: IntStr  # equivalent of \": Union[int, str]\"\n\n\nprint(Model(a=[1], b=4.2, c='x'))\n#> a=[1] b=4.2 c='x'\n\n# a may be None\nprint(Model(a=None, b=1, c=1))\n#> a=None b=1.0 c=1\n```\n\n----------------------------------------\n\nTITLE: Use Any to Skip Validation\nDESCRIPTION: When a value does not require validation and should be kept unchanged, use `typing.Any`.",
    "chunk_length": 2669
  },
  {
    "chunk_id": 123,
    "source": "pydantic_llms_data",
    "content": "This avoids unnecessary processing and potential errors from strict type checking. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/performance.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel\n\n\nclass ModelWithAny(BaseModel):\n    a: Any\n\n\nmodel = ModelWithAny(a=1)\n# model.a will be 1, no validation performed on 'a'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Backward Compatibility: Dataclass and BaseModel Interaction\nDESCRIPTION: Illustrates Pydantic's backward compatibility logic for schema generation when a dataclass references a BaseModel that is not yet defined in the current scope. It shows how Pydantic includes the parent namespace and the BaseModel itself in locals to resolve annotations like 'Bar | None'. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass Foo:\n    a: 'Bar | None' = None\n\n\nclass Bar(BaseModel):\n    b: Foo\n```\n\n----------------------------------------\n\nTITLE: Apply Pydantic Decorator to Stdlib Dataclass\nDESCRIPTION: Illustrates applying the Pydantic dataclass decorator directly to an existing standard library dataclass. This creates a Pydantic-enhanced subclass, enabling validation on instantiation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass A:\n    a: int\n\nPydanticA = pydantic.dataclasses.dataclass(A)\nprint(PydanticA(a='1'))\n#> A(a=1)\n\n```\n\n----------------------------------------\n\nTITLE: Root Model with Customization\nDESCRIPTION: Illustrates how to customize Root Model behavior, such as defining custom serialization or adding extra attributes that are not part of the root value. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/root_model.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import RootModel, Field\nfrom typing import List\n\nclass ItemList(RootModel[List[str]]):\n    item_count: int = Field(default=0)\n\n    def __init__(self, **data):\n        super().__init__(**data)\n        self.item_count = len(self.root)\n\n# Example usage:\nitems = ItemList([\"apple\", \"banana\"])\nprint(items.root)\nprint(items.item_count)\n# Output:\n# ['apple', 'banana']\n# 2\n```\n\n----------------------------------------\n\nTITLE: ConfigDict validate_by_name\nDESCRIPTION: Shows how `ConfigDict.validate_by_name=True` allows validation using the attribute name, overriding alias usage.",
    "chunk_length": 2635
  },
  {
    "chunk_id": 124,
    "source": "pydantic_llms_data",
    "content": "Demonstrates validation with `my_field`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=False, validate_by_name=True)\n\n\nprint(repr(Model(my_field='foo')))  # (1)! #> Model(my_field='foo')\n```\n\n----------------------------------------\n\nTITLE: Enable Mypy Linting in VS Code\nDESCRIPTION: Configures VS Code to use mypy for static type checking, which can detect errors missed by Pylance. This integration allows inline display of mypy errors, including those from the Pydantic mypy plugin. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#_snippet_1\n\nLANGUAGE: VSCode Settings\nCODE:\n```\n{\n  \"python.linting.mypyEnabled\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Percent Encoding in AnyUrl\nDESCRIPTION: Implements percent encoding for `AnyUrl` and its descendant types, ensuring URLs are correctly formatted and safe for network transmission. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_112\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import AnyUrl\n\nclass UrlModel(BaseModel):\n    url: AnyUrl\n\n# Example:\n# url_with_space = UrlModel(url='http://example.com/path with spaces')\n# print(url_with_space.url) # Output: http://example.com/path%20with%20spaces\n# This ensures proper URL encoding. ```\n\n----------------------------------------\n\nTITLE: Pydantic Strict Mode vs. Lax Mode Validation\nDESCRIPTION: Demonstrates Pydantic's strict mode by comparing validation behavior with and without the `strict=True` parameter. It shows how strict mode prevents type coercion for integer fields, raising a ValidationError for string inputs. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nprint(MyModel.model_validate({'x': '123'}))  # lax mode\n#> x=123\n\ntry:\n    MyModel.model_validate({'x': '123'}, strict=True)  # strict mode\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for MyModel\n    x\n      Input should be a valid integer [type=int_type, input_value='123', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Field vs.",
    "chunk_length": 2489
  },
  {
    "chunk_id": 125,
    "source": "pydantic_llms_data",
    "content": "Type Metadata with Annotated\nDESCRIPTION: Highlights the difference in applying metadata to fields versus types using Annotated and Field(), and the impact on features like deprecation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass Model(BaseModel):\n    field_bad: Annotated[int, Field(deprecated=True)] | None = None  # (1)! field_ok: Annotated[int | None, Field(deprecated=True)] = None  # (2)! # 1. The [`Field()`][pydantic.fields.Field] function is applied to `int` type, hence the\n      #    `deprecated` flag won't have any effect. While this may be confusing given that the name of\n      #    the [`Field()`][pydantic.fields.Field] function would imply it should apply to the field, \n      #    the API was designed when this function was the only way to provide metadata. You can\n      #    alternatively make use of the [`annotated_types`](https://github.com/annotated-types/annotated-types)\n      #    library which is now supported by Pydantic. #\n      # 2. The [`Field()`][pydantic.fields.Field] function is applied to the \"top-level\" union type, \n      #    hence the `deprecated` flag will be applied to the field. ```\n\n----------------------------------------\n\nTITLE: Pydantic: Root validator `pre=False` and `skip_on_failure`\nDESCRIPTION: When using `@root_validator` with `pre=False` (the default), `skip_on_failure` must be set to `True`. The option `skip_on_failure=False` is deprecated and will raise an error. Setting it to `True` prevents the validator from running if any field validation fails. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n# Example illustrating the rule, not a direct error-raising snippet\n# from pydantic import BaseModel, root_validator\n#\n# class Model(BaseModel):\n#     a: int\n#     b: str\n#\n#     @root_validator(pre=False, skip_on_failure=True)\n#     def check_model(cls, values):\n#         # ... validation logic ... #         return values\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Validation\nDESCRIPTION: Function for validating Pydantic models.",
    "chunk_length": 2178
  },
  {
    "chunk_id": 126,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_38\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.validate_model(model: type, **kwargs: typing.Any) -> typing.Any\n  Validate a model with given keyword arguments. ```\n\n----------------------------------------\n\nTITLE: Use TypedDict Over Nested Models for Performance\nDESCRIPTION: For nested data structures, using `typing_extensions.TypedDict` can offer significant performance improvements compared to deeply nested Pydantic `BaseModel` classes. Benchmarks show `TypedDict` can be approximately 2.5x faster. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/performance.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom timeit import timeit\n\nfrom typing_extensions import TypedDict\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\n# Define nested structure using TypedDict\nclass TypedDictA(TypedDict):\n    a: str\n    b: int\n\n\nclass TypedDictModel(TypedDict):\n    a: TypedDictA\n\n\n# Define equivalent structure using Pydantic BaseModel\nclass BaseModelB(BaseModel):\n    a: str\n    b: int\n\n\nclass BaseModelNested(BaseModel):\n    b: BaseModelB\n\n\n# Performance comparison using timeit\nta = TypeAdapter(TypedDictModel)\n\n# Validate data using TypedDict\nresult_typeddict = timeit(\n    lambda: ta.validate_python({'a': {'a': 'a', 'b': 2}}), number=10000\n)\n\n# Validate data using Pydantic BaseModel\nresult_basemodel = timeit(\n    lambda: BaseModelNested.model_validate({'b': {'a': 'a', 'b': 2}}), number=10000\n)\n\n# Print the performance ratio (BaseModel vs TypedDict)\nprint(f\"Performance ratio (BaseModel/TypedDict): {result_basemodel / result_typeddict:.2f}\")\n```\n\n----------------------------------------\n\nTITLE: Performance Improvements\nDESCRIPTION: Specific optimizations implemented to enhance build time performance, particularly in the creation of Pydantic models and core schema generation. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nCreate a single dictionary when creating a `CoreConfig` instance\n```\n\n----------------------------------------\n\nTITLE: Pydantic Handling of `typing.Pattern`\nDESCRIPTION: Explains how Pydantic processes `typing.Pattern` types, indicating that the input value will be passed to `re.compile(v)` to create a regular expression pattern for validation.",
    "chunk_length": 2326
  },
  {
    "chunk_id": 127,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_34\n\nLANGUAGE: APIDOC\nCODE:\n```\ntyping.Pattern:\n  Behavior: Will cause the input value to be passed to `re.compile(v)` to create a regular expression pattern. ```\n\n----------------------------------------\n\nTITLE: Adding a New Test Case to Mypy Configuration\nDESCRIPTION: Demonstrates how to add a new Python test file to the Mypy test suite. This involves placing the file in the modules directory and referencing it within the `cases` list in the main test file, alongside its corresponding Mypy configuration. SOURCE: https://github.com/pydantic/pydantic/blob/main/tests/mypy/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# modules/new_test.py\n\nfrom pydantic import BaseModel\n\nclass Model(BaseModel):\n    a: int\n\n\nmodel = Model(a=1, b=2)\n```\n\nLANGUAGE: python\nCODE:\n```\ncases: list[ParameterSet | tuple[str, str]] = [\n    ... # One-off cases\n    *[\n            ('mypy-plugin.ini', 'custom_constructor.py'),\n            ('mypy-plugin.ini', 'config_conditional_extra.py'),\n            ... ('mypy-plugin.ini', 'new_test.py'),  # <-- new test added. ]\n    ]\n```\n\n----------------------------------------\n\nTITLE: Basic Static Model Definition\nDESCRIPTION: Defines a static Pydantic model with simple field types and default values. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nclass StaticFoobarModel(BaseModel):\n    foo: str\n    bar: int = 123\n```\n\n----------------------------------------\n\nTITLE: Pydantic Generics with TypeVar Bounds\nDESCRIPTION: Illustrates the use of `typing.TypeVar` with bounds and without bounds in generic Pydantic models. Shows how generic types can be inferred or explicitly parameterized, and their serialization behavior. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTBound = TypeVar('TBound', bound=BaseModel)\nTNoBound = TypeVar('TNoBound')\n\n\nclass IntValue(BaseModel):\n    value: int\n\n\nclass ItemBound(BaseModel, Generic[TBound]):\n    item: TBound\n\n\nclass ItemNoBound(BaseModel, Generic[TNoBound]):\n    item: TNoBound\n\n\nitem_bound_inferred = ItemBound(item=IntValue(value=3))\nitem_bound_explicit = ItemBound[IntValue](item=IntValue(value=3))\nitem_no_bound_inferred = ItemNoBound(item=IntValue(value=3))\nitem_no_bound_explicit = ItemNoBound[IntValue](item=IntValue(value=3))\n\n# calling `print(x.model_dump())` on any of the above instances results in the following:\n#> {'item': {'value': 3}}\n```\n\n----------------------------------------\n\nTITLE: RootModel with Custom Iteration and Item Access\nDESCRIPTION: Shows how to implement `__iter__` and `__getitem__` on a `RootModel` subclass to allow direct iteration and item access.",
    "chunk_length": 2873
  },
  {
    "chunk_id": 128,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import RootModel\n\n\nclass Pets(RootModel):\n    root: list[str]\n\n    def __iter__(self):\n        return iter(self.root)\n\n    def __getitem__(self, item):\n        return self.root[item]\n\n\npets = Pets.model_validate(['dog', 'cat'])\nprint(pets[0])\n#> dog\nprint([pet for pet in pets])\n#> ['dog', 'cat']\n```\n\n----------------------------------------\n\nTITLE: create_model with __config__\nDESCRIPTION: Fixed the `create_model` function to correctly use the passed `__config__` attribute, ensuring proper model configuration when dynamically creating models. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_292\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import create_model, BaseModel\n\nclass MyConfig:\n    extra = 'allow'\n\nDynamicModel = create_model('DynamicModel', __config__=MyConfig, field1=(str, ...))\n```\n\n----------------------------------------\n\nTITLE: Ad-hoc Parsing Functions\nDESCRIPTION: Introduces `parse_obj_as` and `parse_file_as` functions for ad-hoc parsing of data into arbitrary pydantic-compatible types. These functions are useful for validating and transforming data without needing to define a full Pydantic model. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_249\n\nLANGUAGE: APIDOC\nCODE:\n```\nparse_obj_as(type_, obj)\nparse_file_as(type_, file_path, **kwargs)\n\n# Example:\nfrom typing import List\nfrom pydantic import parse_obj_as\n\ndata = [1, 2, 3]\nnumbers = parse_obj_as(List[int], data)\nprint(numbers)\n# Output: [1, 2, 3]\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Annotated Pattern for Type Constraints\nDESCRIPTION: Demonstrates applying validation constraints to elements within a list using the Annotated pattern with Field(). SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    int_list: list[Annotated[int, Field(gt=0)]]\n    # Valid: [1, 3]\n    # Invalid: [-1, 2]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Validator Ordering with Annotated Pattern\nDESCRIPTION: Demonstrates the execution order of validators when using the annotated pattern in Pydantic.",
    "chunk_length": 2365
  },
  {
    "chunk_id": 129,
    "source": "pydantic_llms_data",
    "content": "'WrapValidator' and 'BeforeValidator' run right-to-left, while 'AfterValidator' runs left-to-right. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\nfrom pydantic import AfterValidator, BaseModel, BeforeValidator, WrapValidator\n\ndef runs_1st(): pass\ndef runs_2nd(): pass\ndef runs_3rd(): pass\ndef runs_4th(): pass\n\nclass Model(BaseModel):\n    name: Annotated[\n        str,\n        AfterValidator(runs_3rd),\n        AfterValidator(runs_4th),\n        BeforeValidator(runs_2nd),\n        WrapValidator(runs_1st),\n    ]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Strict Mode Configuration and Usage\nDESCRIPTION: Provides a comprehensive overview of Pydantic's strict mode, detailing its purpose in preventing data coercion and outlining various methods for its implementation. This includes using `strict=True` in validation methods, `Field(strict=True)`, `pydantic.types.Strict` annotations, and `ConfigDict(strict=True)`. It also discusses type coercion nuances between JSON and Python inputs in strict mode. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#_snippet_2\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Strict Mode\n\nPurpose:\nBy default, Pydantic attempts to coerce values to the desired type (e.g., string '123' to int 123). Strict mode disables or reduces this coercion, causing validation to error if data is not of the exact correct type. Enabling Strict Mode:\nStrict mode can be enabled on a per-model, per-field, or per-validation-call basis. Methods to Enable Strict Mode:\n1. **Passing `strict=True` to validation methods**: Apply to methods like `BaseModel.model_validate`, `TypeAdapter.validate_python`, and similar JSON validation methods. 2. **Using `Field(strict=True)`**: Set `strict=True` when defining fields within `BaseModel`, `dataclass`, or `TypedDict`. 3. **Using `pydantic.types.Strict` as a type annotation**: Annotate fields with `Strict` or Pydantic's provided strict type aliases like `pydantic.types.StrictInt`.",
    "chunk_length": 2093
  },
  {
    "chunk_id": 130,
    "source": "pydantic_llms_data",
    "content": "4. **Using `ConfigDict(strict=True)`**: Set `strict=True` within the `ConfigDict` for a model to apply strict mode globally to that model. Type Coercions in Strict Mode:\n-   **Python Input**: For most types, only instances of the exact type are accepted. Passing floats or strings to an int field will raise `ValidationError`. -   **JSON Input**: Pydantic is looser when validating from JSON in strict mode. For example, `UUID` fields accept string inputs from JSON, but not from Python. Refer to the [Conversion Table](conversion_table.md) for detailed type allowances in strict mode. ```\n\n----------------------------------------\n\nTITLE: Pydantic: Validate Password Match with ValidationInfo.data\nDESCRIPTION: Demonstrates how to use `ValidationInfo.data` within a Pydantic field validator to access previously validated data, specifically for comparing password fields. It requires `pydantic` and `ValidationInfo` and shows how to raise a `ValueError` if passwords do not match. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass UserModel(BaseModel):\n    password: str\n    password_repeat: str\n    username: str\n\n    @field_validator('password_repeat', mode='after')\n    @classmethod\n    def check_passwords_match(cls, value: str, info: ValidationInfo) -> str:\n        if value != info.data['password']:\n            raise ValueError('Passwords do not match')\n        return value\n```\n\n----------------------------------------\n\nTITLE: TypeAdapter with Union and JSON Schema\nDESCRIPTION: Demonstrates how to use Pydantic's TypeAdapter to handle union types (e.g., Union[Cat, Dog]) and generate a corresponding JSON schema. This is useful for defining schemas that can accept multiple distinct data structures. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom typing import Union\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass Cat(BaseModel):\n    name: str\n    color: str\n\n\nclass Dog(BaseModel):\n    name: str\n    breed: str\n\n\nta = TypeAdapter(Union[Cat, Dog])\nta_schema = ta.json_schema()\nprint(json.dumps(ta_schema, indent=2))\n```\n\n----------------------------------------\n\nTITLE: Pydantic Data Loading Deprecations and Replacements\nDESCRIPTION: Details the deprecation of `parse_raw` and `parse_file` in Pydantic V2.",
    "chunk_length": 2461
  },
  {
    "chunk_id": 131,
    "source": "pydantic_llms_data",
    "content": "`model_validate_json` is the direct replacement for `parse_raw`, while other data loading should involve loading data first and then using `model_validate`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_9\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Data Loading API Changes:\n\n- `parse_raw` (Deprecated in V2)\n  - Purpose: Load data from a JSON string. - V2 Replacement: `model_validate_json(json_string)`\n\n- `parse_file` (Deprecated in V2)\n  - Purpose: Load data from a file. - V2 Approach: Load data from the file (e.g., using `json.load`), then pass to `model_validate`. - `from_orm` (Deprecated in V2)\n  - Purpose: Load data from ORM objects or arbitrary attributes. - V2 Replacement: `model_validate(obj, from_attributes=True)`\n\nExample Usage (V2):\n```python\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    name: str\n\n# Equivalent to V1's parse_raw\nmodel_instance = MyModel.model_validate_json('{\"name\": \"Alice\"}')\n\n# Equivalent to V1's parse_obj with from_attributes=True\nclass MyORMObject:\n    name: str = 'Bob'\n\nmodel_instance_from_attributes = MyModel.model_validate(MyORMObject(), from_attributes=True)\n```\n```\n\n----------------------------------------\n\nTITLE: Pydantic v1.0 Fixes and Improvements\nDESCRIPTION: Details bug fixes and improvements made in Pydantic v1.0. This includes addressing issues with default values, settings inheritance, string representations, recursive merging for `BaseSettings`, and schema generation for constrained types. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_258\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Fixes and Improvements (v1.0):\n\n- Fix field of a type with a default value. - Use `FutureWarning` instead of `DeprecationWarning` for `alias` vs `env` in settings models. - Fix issue with `BaseSettings` inheritance and `alias` being set to `None`. - Fix `ConstrainedList` and update schema generation for `min_items`/`max_items` `Field()` arguments. - Allow abstract sets in `dict()`'s `include`/`exclude` arguments. - Fix JSON serialization errors on `ValidationError.json()` using `pydantic_encoder`.",
    "chunk_length": 2121
  },
  {
    "chunk_id": 132,
    "source": "pydantic_llms_data",
    "content": "- Clarify usage of `remove_untouched` and improve error messages for types with no validators. - Improve `str`/`repr` logic for `ModelField`. ```\n\n----------------------------------------\n\nTITLE: Validate Incomplete JSON List with Partial Validation\nDESCRIPTION: Demonstrates using TypeAdapter.validate_json with experimental_allow_partial=True to validate a JSON string representing an incomplete list of TypedDict objects. Shows how partial data is handled when fields are missing or truncated. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict):\n    a: int\n    b: NotRequired[float]\n    c: NotRequired[Annotated[str, MinLen(5)]]\n\n\nta = TypeAdapter(list[Foobar])\n\nv = ta.validate_json('[{\"a\": 1, \"b\"', experimental_allow_partial=True)\nprint(v)\n#> [{'a': 1}]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pydantic MISSING Sentinel Usage\nDESCRIPTION: This snippet illustrates the use of Pydantic's `MISSING` sentinel as a default value for a field. It shows how fields with `MISSING` are excluded from serialization and how to check for the sentinel value during runtime. The feature is experimental and relies on PEP 661. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\nfrom pydantic import BaseModel\nfrom pydantic.experimental.missing_sentinel import MISSING\n\n\nclass Configuration(BaseModel):\n    timeout: Union[int, None, MISSING] = MISSING\n\n\n# configuration defaults, stored somewhere else:\ndefaults = {'timeout': 200}\n\nconf = Configuration()\n\n# `timeout` is excluded from the serialization output:\nprint(conf.model_dump())\n# Expected output: {}\n\n# The `MISSING` value doesn't appear in the JSON Schema:\n# print(Configuration.model_json_schema()['properties']['timeout'])\n# Expected output: {'anyOf': [{'type': 'integer'}, {'type': 'null'}], 'title': 'Timeout'}\n\n\n# `is` can be used to discriminate between the sentinel and other values:\ntimeout_value = conf.timeout if conf.timeout is not MISSING else defaults['timeout']\nprint(f\"Resolved timeout: {timeout_value}\")\n# Expected output: Resolved timeout: 200\n\n```\n\n----------------------------------------\n\nTITLE: Advanced Include/Exclude with Sequences in Pydantic\nDESCRIPTION: Illustrates advanced usage of `exclude` and `include` with sequences (lists) in Pydantic models.",
    "chunk_length": 2604
  },
  {
    "chunk_id": 133,
    "source": "pydantic_llms_data",
    "content": "It shows how to exclude specific items within a list or include specific fields of items in a list. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Hobby(BaseModel):\n    name: str\n    info: str\n\n\nclass User(BaseModel):\n    hobbies: list[Hobby]\n\n\nuser = User(\n    hobbies=[\n        Hobby(name='Programming', info='Writing code and stuff'),\n        Hobby(name='Gaming', info='Hell Yeah!!!'),\n    ],\n)\n\nprint(user.model_dump(exclude={'hobbies': {-1: {'info'}}}))  # (1)! \"\"\"\n{\n    'hobbies': [\n        {'name': 'Programming', 'info': 'Writing code and stuff'},\n        {'name': 'Gaming'},\n    ]\n}\n\"\"\"\n\nuser.model_dump(\n   include={'hobbies': {0: True, -1: {'name'}}}\n)\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic BeforeValidator with Decorator\nDESCRIPTION: Shows an alternative way to use `BeforeValidator` by applying it as a decorator to a class method. This achieves the same preprocessing as the `Annotated` pattern for ensuring a value is a list before Pydantic's validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    numbers: list[int]\n\n    @field_validator('numbers', mode='before')\n    @classmethod\n    def ensure_list(cls, value: Any) -> Any:  # (1)! if not isinstance(value, list):  # (2)! return [value]\n        else:\n            return value\n\n\nprint(Model(numbers=2))\n#> numbers=[2]\ntry:\n    Model(numbers='str')\nexcept ValidationError as err:\n    print(err)  # (3)! \"\"\"\n    1 validation error for Model\n    numbers.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='str', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Dataclass Init and InitVar Mutual Exclusion in Pydantic\nDESCRIPTION: The `init=False` and `init_var=True` settings for dataclass fields are mutually exclusive.",
    "chunk_length": 2115
  },
  {
    "chunk_id": 134,
    "source": "pydantic_llms_data",
    "content": "Using both simultaneously results in a `PydanticUserError`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    bar: str = Field(init=False, init_var=True)\n```\n\n----------------------------------------\n\nTITLE: Support for PEP 695 Generics Syntax\nDESCRIPTION: Implements full support for the generics syntax introduced in PEP 695. This allows for more modern and cleaner definition of generic types in Python. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n# PEP 695 syntax example:\ndef process_items[T](items: list[T]) -> list[T]:\n    return items\n\n# Pydantic models can now leverage this syntax directly. ```\n\n----------------------------------------\n\nTITLE: Configure Pylance Type Checking Mode\nDESCRIPTION: Enables Pydantic type error checks within VS Code using the Pylance extension. Setting the 'Type Checking Mode' to 'basic' or 'strict' provides inline error feedback for type mismatches and missing arguments. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#_snippet_0\n\nLANGUAGE: VSCode Settings\nCODE:\n```\n{\n  \"python.analysis.typeCheckingMode\": \"basic\" \n}\n\n// or\n\n{\n  \"python.analysis.typeCheckingMode\": \"strict\"\n}\n```\n\n----------------------------------------\n\nTITLE: Pydantic NamedTuple and TypedDict Support\nDESCRIPTION: Introduces comprehensive support for `NamedTuple` and `TypedDict` types within `BaseModel` and Pydantic `dataclass`. Utility functions `create_model_from_namedtuple` and `create_model_from_typeddict` are also provided for easier integration. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_152\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic NamedTuple and TypedDict Support:\n\n- Handles and validates `NamedTuple` and `TypedDict` types within `BaseModel` or Pydantic `dataclass`. - Provides utility functions: `create_model_from_namedtuple` and `create_model_from_typeddict`.",
    "chunk_length": 2100
  },
  {
    "chunk_id": 135,
    "source": "pydantic_llms_data",
    "content": "```\n\n----------------------------------------\n\nTITLE: Pydantic: Hypothesis Plugin for Property-Based Testing\nDESCRIPTION: Introduces a Hypothesis plugin for Pydantic, simplifying property-based testing with Pydantic's custom types. Detailed usage is available in the Pydantic documentation. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_175\n\nLANGUAGE: python\nCODE:\n```\n# Installation:\n# pip install pydantic[hypothesis]\n\nfrom pydantic import BaseModel\nfrom hypothesis import given\nfrom pydantic_hypothesis import from_type\n\nclass MyModel(BaseModel):\n    name: str\n    age: int\n\n@given(from_type(MyModel))\ndef test_my_model(model):\n    assert isinstance(model, MyModel)\n    assert model.age >= 0 # Example assertion\n\n# To run this test, you would typically use pytest or another test runner. ```\n\n----------------------------------------\n\nTITLE: Discriminator with Discriminator Instance\nDESCRIPTION: Illustrates using the `discriminator` parameter with a `Discriminator` instance for more complex discrimination logic in Pydantic unions. This allows custom functions to determine the correct model based on input data. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Field, Tag\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_kind: Literal['dog']\n    age: int\n\ndef pet_discriminator(v):\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n\n\nclass Model(BaseModel):\n    pet: Union[Annotated[Cat, Tag('cat')], Annotated[Dog, Tag('dog')]] = Field(\n        discriminator=Discriminator(pet_discriminator)\n    )\n\n\nprint(repr(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}})))\n#> Model(pet=Cat(pet_type='cat', age=12))\n\nprint(repr(Model.model_validate({'pet': {'pet_kind': 'dog', 'age': 12}})))\n#> Model(pet=Dog(pet_kind='dog', age=12))\n```\n\n----------------------------------------\n\nTITLE: AliasGenerator with Validation and Serialization Aliases\nDESCRIPTION: Demonstrates using `AliasGenerator` to define separate uppercase aliases for validation and title-case aliases for serialization within a Pydantic model.",
    "chunk_length": 2355
  },
  {
    "chunk_id": 136,
    "source": "pydantic_llms_data",
    "content": "Shows how to validate data with aliases and dump the model using aliases. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom pydantic import AliasGenerator, BaseModel, ConfigDict\n\n\nclass Tree(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=AliasGenerator(\n            validation_alias=lambda field_name: field_name.upper(),\n            serialization_alias=lambda field_name: field_name.title(),\n        )\n    )\n\n    age: int\n    height: float\n    kind: str\n\n\nt = Tree.model_validate({'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'})\nprint(t.model_dump(by_alias=True))\n#> {'Age': 12, 'Height': 1.2, 'Kind': 'oak'}\n```\n\n----------------------------------------\n\nTITLE: Pydantic BaseModel API Reference\nDESCRIPTION: The core class for defining Pydantic data models. Models are created by inheriting from BaseModel and defining fields using annotated attributes. This reference lists key members available on BaseModel instances. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/base_model.md#_snippet_0\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.BaseModel\n  options:\n    show_root_heading: true\n    merge_init_into_class: false\n    group_by_category: false\n    members:\n      - __init__\n      - model_config\n      - model_fields\n      - model_computed_fields\n      - __pydantic_core_schema__\n      - model_extra\n      - model_fields_set\n      - model_construct\n      - model_copy\n      - model_dump\n      - model_dump_json\n      - model_json_schema\n      - model_parametrized_name\n      - model_post_init\n      - model_rebuild\n      - model_validate\n      - model_validate_json\n      - model_validate_strings\n```\n\n----------------------------------------\n\nTITLE: Pydantic JSON Schema Type Mapping Priority\nDESCRIPTION: Details the priority order Pydantic uses when mapping Python types, custom field types, and constraints to JSON Schema Core, JSON Schema Validation, and OpenAPI Data Types. It also mentions the use of `format` for Pydantic extensions. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_27\n\nLANGUAGE: APIDOC\nCODE:\n```\nTypes, custom field types, and constraints (like `max_length`) are mapped to the corresponding spec formats in the following priority order (when there is an equivalent available):\n\n1.",
    "chunk_length": 2351
  },
  {
    "chunk_id": 137,
    "source": "pydantic_llms_data",
    "content": "JSON Schema Core (https://json-schema.org/draft/2020-12/json-schema-core)\n2. JSON Schema Validation (https://json-schema.org/draft/2020-12/json-schema-validation)\n3. OpenAPI Data Types (https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#data-types)\n4. The standard `format` JSON field is used to define Pydantic extensions for more complex `string` sub-types. The field schema mapping from Python or Pydantic to JSON schema is done as follows:\n\n{{ schema_mappings_table }}\n```\n\n----------------------------------------\n\nTITLE: Pydantic typing-extensions Dependency\nDESCRIPTION: Makes the `typing-extensions` package a required dependency for Pydantic. This ensures access to necessary backported typing features for broader Python version compatibility. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_162\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic typing-extensions Dependency:\n\n`typing-extensions` is now a required dependency. ```\n\n----------------------------------------\n\nTITLE: Model with Unresolved Forward Reference\nDESCRIPTION: Demonstrates a Pydantic model with a forward reference ('MyType') that has not yet been defined. Inspecting the `__pydantic_core_schema__` at this stage shows a mock object, indicating the schema generation failed due to the unresolved annotation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    f: 'MyType'\n\n\nFoo.__pydantic_core_schema__\n```\n\n----------------------------------------\n\nTITLE: Pydantic JSON Serialization Methods\nDESCRIPTION: Provides access to methods for serializing Pydantic models and data structures into JSON format. These include methods on BaseModel, TypeAdapter, and the underlying pydantic_core library. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#_snippet_5\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.main.BaseModel.model_dump_json\n  Serializes the model instance to a JSON string.",
    "chunk_length": 2062
  },
  {
    "chunk_id": 138,
    "source": "pydantic_llms_data",
    "content": "Parameters:\n    - include: Fields to include. - exclude: Fields to exclude. - by_alias: Use alias names instead of field names. - exclude_unset: Exclude fields that were not set. - exclude_defaults: Exclude fields that have their default value. - exclude_none: Exclude fields that are None. - encoder: Custom JSON encoder. - mode: Serialization mode ('json' or 'python'). - indent: Number of spaces for indentation. - separators: Tuple of separators. - sort_keys: Whether to sort keys. Returns: JSON string. pydantic.type_adapter.TypeAdapter.dump_json\n  Serializes data using the type adapter's configuration to a JSON string. Parameters:\n    - value: The data to serialize. - include: Fields to include. - exclude: Fields to exclude. - by_alias: Use alias names instead of field names. - exclude_unset: Exclude fields that were not set. - exclude_defaults: Exclude fields that have their default value. - exclude_none: Exclude fields that are None. - encoder: Custom JSON encoder. - mode: Serialization mode ('json' or 'python'). - indent: Number of spaces for indentation. - separators: Tuple of separators. - sort_keys: Whether to sort keys. Returns: JSON string. pydantic_core.to_json\n  Serializes Python data structures to JSON using pydantic-core. Parameters:\n    - value: The data to serialize. - mode: Serialization mode ('json' or 'python'). - encoder: Custom JSON encoder. - indent: Number of spaces for indentation. - separators: Tuple of separators. - sort_keys: Whether to sort keys. Returns: JSON string. ```\n\n----------------------------------------\n\nTITLE: Schema Generation Logic Moved to GenerateSchema Class\nDESCRIPTION: Core schema generation logic for path types and `deque` has been moved into the `GenerateSchema` class. This consolidates schema generation logic and removes workarounds. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import Schema\n\n# Internal refactoring: Schema generation for specific types is now centralized. # This impacts the internal implementation of schema building.",
    "chunk_length": 2094
  },
  {
    "chunk_id": 139,
    "source": "pydantic_llms_data",
    "content": "```\n\n----------------------------------------\n\nTITLE: Pydantic: Correct validator usage with fields\nDESCRIPTION: Demonstrates the correct way to define a validator using `@field_validator` by explicitly passing the field name(s) as arguments. This ensures the validator is correctly applied to the intended model fields. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    a: str\n\n    @field_validator('a')\n    def checker(cls, v):\n        return v\n```\n\n----------------------------------------\n\nTITLE: TypeAdapter Strict Validation for Boolean\nDESCRIPTION: Demonstrates using TypeAdapter with strict=True for boolean validation. It shows how strict mode rejects non-strict boolean inputs like the string 'yes', raising a ValidationError. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter, ValidationError\n\nprint(TypeAdapter(bool).validate_python('yes'))  # OK: lax\n#> True\n\ntry:\n    TypeAdapter(bool).validate_python('yes', strict=True)  # Not OK: strict\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for bool\n      Input should be a valid boolean [type=bool_type, input_value='yes', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Field Constraints and Schema Generation\nDESCRIPTION: Illustrates how Pydantic handles field constraints, including cases where constraints might not be enforced by default and how to explicitly include them in the JSON schema using Field arguments. It shows how to use Field with raw schema attributes for unenforced constraints. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, PositiveInt\n\ntry:\n    # this won't work since `PositiveInt` takes precedence over the\n    # constraints defined in `Field`, meaning they're ignored\n    class Model(BaseModel):\n        foo: PositiveInt = Field(lt=10)\n\nexcept ValueError as e:\n    print(e)\n\n\n# if you find yourself needing this, an alternative is to declare\n# the constraints in `Field` (or you could use `conint()`)\n# here both constraints will be enforced:\nclass ModelB(BaseModel):\n    # Here both constraints will be applied and the schema\n    # will be generated correctly\n    foo: int = Field(gt=0, lt=10)\n\n\nprint(ModelB.model_json_schema())\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"properties\": {\n        \"foo\": {\n            \"exclusiveMaximum\": 10,\n            \"exclusiveMinimum\": 0,\n            \"title\": \"Foo\",\n            \"type\": \"integer\"\n        }\n    },\n    \"required\": [\"foo\"],\n    \"title\": \"ModelB\",\n    \"type\": \"object\"\n}\n```\n\n----------------------------------------\n\nTITLE: Validate and Serialize Data with Redis Queue (Python)\nDESCRIPTION: This snippet shows how to use Pydantic models to serialize Python objects into JSON strings for storage in a Redis list (acting as a queue).",
    "chunk_length": 3109
  },
  {
    "chunk_id": 140,
    "source": "pydantic_llms_data",
    "content": "It also demonstrates deserializing and validating incoming JSON data from Redis back into Pydantic models. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/queues.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport redis\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nr = redis.Redis(host='localhost', port=6379, db=0)\nQUEUE_NAME = 'user_queue'\n\n\ndef push_to_queue(user_data: User) -> None:\n    serialized_data = user_data.model_dump_json()\n    r.rpush(QUEUE_NAME, serialized_data)\n    print(f'Added to queue: {serialized_data}')\n\n\nuser1 = User(id=1, name='John Doe', email='john@example.com')\nuser2 = User(id=2, name='Jane Doe', email='jane@example.com')\n\npush_to_queue(user1)\n# > Added to queue: {\"id\":1,\"name\":\"John Doe\",\"email\":\"john@example.com\"}\n\npush_to_queue(user2)\n# > Added to queue: {\"id\":2,\"name\":\"Jane Doe\",\"email\":\"jane@example.com\"}\n\n\ndef pop_from_queue() -> None:\n    data = r.lpop(QUEUE_NAME)\n\n    if data:\n        user = User.model_validate_json(data)\n        print(f'Validated user: {repr(user)}')\n    else:\n        print('Queue is empty')\n\n\npop_from_queue()\n# > Validated user: User(id=1, name='John Doe', email='john@example.com')\n\npop_from_queue()\n# > Validated user: User(id=2, name='Jane Doe', email='jane@example.com')\n\npop_from_queue()\n# > Queue is empty\n```\n\n----------------------------------------\n\nTITLE: Pydantic Optional[conset/conlist] Handling\nDESCRIPTION: Fixes an issue where `None` was not correctly allowed for types like `Optional[conset]` or `Optional[conlist]`. This ensures proper validation for optional constrained sets and lists. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_146\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Optional[conset/conlist] Handling:\n\nAllows `None` for types `Optional[conset]` and `Optional[conlist]`. ```\n\n----------------------------------------\n\nTITLE: Pydantic v2.11.0b1 Packaging Updates\nDESCRIPTION: Details packaging changes in Pydantic v2.11.0b1, including the addition of a `check_pydantic_core_version()` function, removal of the `greenlet` development dependency, adoption of the `typing-inspection` library, and bumping `pydantic-core` to v2.31.1.",
    "chunk_length": 2237
  },
  {
    "chunk_id": 141,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n# Packaging Updates in v2.11.0b1\n# Add a check_pydantic_core_version() function\n# Remove greenlet development dependency\n# Use the typing-inspection library\n# Bump pydantic-core to v2.31.1\n```\n\n----------------------------------------\n\nTITLE: Generate Model Signature with Pydantic\nDESCRIPTION: Demonstrates how Pydantic automatically generates a model's signature based on its fields, respecting aliases and default values. This signature is crucial for introspection and integration with libraries like FastAPI. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\nfrom pydantic import BaseModel, Field\n\n\nclass FooModel(BaseModel):\n    id: int\n    name: str = None\n    description: str = 'Foo'\n    apple: int = Field(alias='pear')\n\n\nprint(inspect.signature(FooModel))\n#> (*, id: int, name: str = None, description: str = 'Foo', pear: int) -> None\n```\n\n----------------------------------------\n\nTITLE: Custom Root Models with Mapping Types\nDESCRIPTION: Adds support for mapping types when defining custom root models. This allows custom root models to be constructed from or validated against dictionary-like structures more flexibly. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_254\n\nLANGUAGE: APIDOC\nCODE:\n```\nfrom typing import Dict, List\nfrom pydantic import BaseModel\n\nclass MyRootModel(BaseModel):\n    __root__: Dict[str, int]\n\n\n# Example usage:\ndata = {'a': 1, 'b': 2}\nroot_model = MyRootModel(__root__=data)\nprint(root_model.__root__)\n# Output: {'a': 1, 'b': 2}\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Models with Abstract Base Classes\nDESCRIPTION: Demonstrates how Pydantic models can inherit from Python's `abc.ABC` to function as abstract base classes. This allows defining abstract methods that must be implemented by concrete subclasses. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nimport abc\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel, abc.ABC):\n    a: str\n    b: int\n\n    @abc.abstractmethod\n    def my_abstract_method(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Input Type Preservation for BaseModel and Dataclasses\nDESCRIPTION: Shows that Pydantic V2 preserves input types for subclasses of BaseModel and for dataclasses, unlike generic collections where input types are not guaranteed.",
    "chunk_length": 2570
  },
  {
    "chunk_id": 142,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport pydantic.dataclasses\nfrom pydantic import BaseModel\n\n\nclass InnerModel(BaseModel):\n    x: int\n\n\nclass OuterModel(BaseModel):\n    inner: InnerModel\n\n\nclass SubInnerModel(InnerModel):\n    y: int\n\n\nm = OuterModel(inner=SubInnerModel(x=1, y=2))\nprint(m)\n#> inner=SubInnerModel(x=1, y=2)\n\n\n@pydantic.dataclasses.dataclass\nclass InnerDataclass:\n    x: int\n\n\n@pydantic.dataclasses.dataclass\nclass SubInnerDataclass(InnerDataclass):\n    y: int\n\n\n@pydantic.dataclasses.dataclass\nclass OuterDataclass:\n    inner: InnerDataclass\n\n\nd = OuterDataclass(inner=SubInnerDataclass(x=1, y=2))\nprint(d)\n#> OuterDataclass(inner=SubInnerDataclass(x=1, y=2))\n```\n\n----------------------------------------\n\nTITLE: JSON Serialization for Infinity and NaN\nDESCRIPTION: Adds a mode to Pydantic-core for serializing JSON infinity and NaN values as strings ('Infinity', 'NaN') to ensure valid JSON output. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_40\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic_core.PydanticCustomError(\n  \"JsonSchemaError\",\n  \"Error serializing JSON schema: {error}\",\n  {\n    \"ser_json_inf_nan\": \"strings\"\n  }\n)\n\n# This setting affects how float('inf'), float('-inf'), and float('nan') are serialized. # When 'strings' is used, they become \"Infinity\", \"-Infinity\", and \"NaN\" respectively. # This is a pydantic-core setting, often configured via Pydantic's BaseModel.model_config. ```\n\n----------------------------------------\n\nTITLE: Pydantic v2.11.0b2 New Features\nDESCRIPTION: Introduces experimental support for free threading in Pydantic v2.11.0b2. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# New Features in v2.11.0b2\n# Add experimental support for free threading\n```\n\n----------------------------------------\n\nTITLE: Pydantic V2 Serialization Customization\nDESCRIPTION: Introduces new decorators for customizing serialization in Pydantic V2, replacing the older `json_encoders` config option.",
    "chunk_length": 2097
  },
  {
    "chunk_id": 143,
    "source": "pydantic_llms_data",
    "content": "These decorators offer more granular control over how model fields and entire models are serialized. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_10\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic V2 Serialization Decorators:\n\n- `@field_serializer(field_name, mode='wrap'|'plain'|'before'|'after')`\n  - Purpose: Customize serialization for specific fields. - Parameters:\n    - `field_name`: The name of the field to serialize. - `mode`: Controls when the serializer is called (e.g., 'wrap' for custom serialization logic, 'plain' for direct value return). - Usage: Apply to a method within the model class. - `@model_serializer(mode='wrap'|'plain'|'before'|'after')`\n  - Purpose: Customize serialization for the entire model instance. - Parameters:\n    - `mode`: Controls when the serializer is called. - Usage: Apply to a method within the model class. - `@computed_field`\n  - Purpose: Define fields whose values are computed dynamically. - Usage: Apply to a method within the model class, which will be treated as a field. Deprecated Feature:\n- `json_encoders` in model config is deprecated due to performance and complexity. Use the new decorators instead. Example Usage:\n```python\nfrom pydantic import BaseModel, field_serializer, computed_field\nfrom datetime import datetime\n\nclass Event(BaseModel):\n    name: str\n    timestamp: datetime\n\n    @field_serializer('timestamp', mode='iso')\n    def serialize_timestamp(self, dt: datetime) -> str:\n        return dt.isoformat()\n\n    @computed_field\n    @property\n    def display_name(self) -> str:\n        return f\"Event: {self.name}\"\n\n# Example of model_serializer (not shown in original text, but implied by context)\n# @model_serializer(mode='wrap')\n# def serialize_model(self, handler):\n#     data = handler(self)\n#     return {\"custom_data\": data}\n\n\nevent = Event(name='Meeting', timestamp=datetime.now())\nprint(event.model_dump())\n# Expected output might include: {'name': 'Meeting', 'timestamp': '2023-10-27T10:00:00.000000', 'display_name': 'Event: Meeting'}\n```\n```\n\n----------------------------------------\n\nTITLE: Serialize Pydantic Model to Dictionary\nDESCRIPTION: Explains how to serialize a Pydantic model instance into a dictionary using the `model_dump()` method.",
    "chunk_length": 2253
  },
  {
    "chunk_id": 144,
    "source": "pydantic_llms_data",
    "content": "This method is preferred over the built-in `dict()` for recursive conversion and offers customization options. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nassert user.model_dump() == {'id': 123, 'name': 'Jane Doe'}\n```\n\n----------------------------------------\n\nTITLE: Validate Dictionaries with dict[str, int]\nDESCRIPTION: Shows how to use Pydantic's support for standard Python dictionaries with type hints. The `dict` type attempts to convert input into a dictionary with specified key and value types. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: dict[str, int]\n\n\nm = Model(x={'foo': 1})\nprint(m.model_dump())\n# Expected output: {'x': {'foo': 1}}\n\ntry:\n    Model(x={'foo': '1'})\nexcept ValidationError as e:\n    print(e)\n    # Expected output:\n    # 1 validation error for Model\n    # x\n    #   Input should be a valid dictionary [type=dict_type, input_value='test', input_type=str]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Handling of `typing.Hashable`\nDESCRIPTION: Explains how Pydantic validates `typing.Hashable` types, distinguishing between Python native checks (using `isinstance`) and JSON input processing, where data is first loaded via an `Any` validator before checking for hashability. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_32\n\nLANGUAGE: APIDOC\nCODE:\n```\ntyping.Hashable:\n  From Python: Supports any data that passes an `isinstance(v, Hashable)` check. From JSON: First loads the data via an `Any` validator, then checks if the data is hashable with `isinstance(v, Hashable)`. ```\n\n----------------------------------------\n\nTITLE: Ignoring Specific Parameters in Argument Validation Schema\nDESCRIPTION: Demonstrates how to customize argument schema generation by providing a `parameters_callback` to `generate_arguments_schema`.",
    "chunk_length": 2068
  },
  {
    "chunk_id": 145,
    "source": "pydantic_llms_data",
    "content": "This callback function can specify which parameters to skip during schema creation, allowing for more flexible argument validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic_core import SchemaValidator\n\nfrom pydantic.experimental.arguments_schema import generate_arguments_schema\n\n\ndef func(p: bool, *args: str, **kwargs: int) -> None: ... def skip_first_parameter(index: int, name: str, annotation: Any) -> Any:\n    if index == 0:\n        return 'skip'\n\n\narguments_schema = generate_arguments_schema(\n    func=func,\n    parameters_callback=skip_first_parameter,\n)\n\nval = SchemaValidator(arguments_schema)\n\nargs, kwargs = val.validate_json('{\"args\": [\"arg1\"], \"kwargs\": {\"extra\": 1}}')\nprint(args, kwargs)\n#> ('arg1',) {'extra': 1}\n```\n\n----------------------------------------\n\nTITLE: Fixes and Enhancements\nDESCRIPTION: A collection of fixes and minor enhancements addressing issues in JSON Schema generation, serialization behavior, exception messages, and handling of arbitrary schemas. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nUse the correct JSON Schema mode when handling function schemas\nFix JSON Schema reference logic with `examples` keys\nImprove exception message when encountering recursion errors during type evaluation\nAlways include `additionalProperties: True` for arbitrary dictionary schemas\nExpose `fallback` parameter in serialization methods\nFix path serialization behavior\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model with Strict Boolean Field\nDESCRIPTION: Illustrates defining a Pydantic `BaseModel` with a boolean field (`foo`) configured to be strictly validated using `Field(strict=True)`. This demonstrates how Python model definitions translate into core schema configurations. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    foo: bool = Field(strict=True)\n```\n\n----------------------------------------\n\nTITLE: Pydantic Structural Pattern Matching (PEP 636)\nDESCRIPTION: Illustrates Pydantic's support for structural pattern matching as introduced in Python 3.10 (PEP 636).",
    "chunk_length": 2356
  },
  {
    "chunk_id": 146,
    "source": "pydantic_llms_data",
    "content": "Pydantic models can be directly used in `match` statements for declarative data validation and attribute extraction. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_58\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n\na = Pet(name='Bones', species='dog')\n\nmatch a:\n    # match `species` to 'dog', declare and initialize `dog_name`\n    case Pet(species='dog', name=dog_name):\n        print(f'{dog_name} is a dog')\n#> Bones is a dog\n    # default case\n    case _:\n        print('No dog matched')\n```\n\n----------------------------------------\n\nTITLE: Generate JSON Schema from Pydantic TypeAdapter\nDESCRIPTION: Shows how to generate a JSON schema for arbitrary types using Pydantic's `TypeAdapter`. This method is a replacement for older schema generation functions and is useful for types not defined as Pydantic models. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\nprint(adapter.json_schema())\n#> {'items': {'type': 'integer'}, 'type': 'array'}\n```\n\n----------------------------------------\n\nTITLE: Custom Type Definition Hooks\nDESCRIPTION: Details the replacement of Pydantic V1's `__get_validators__` with `__get_pydantic_core_schema__` and `__modify_schema__` with `__get_pydantic_json_schema__` for defining custom types and generating schemas. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n# Pydantic V1 hook (deprecated)\n# __get_validators__\n\n# Pydantic V2 hooks\n# __get_pydantic_core_schema__\n# __get_pydantic_json_schema__\n```\n\n----------------------------------------\n\nTITLE: Model Serializer - Wrap Mode\nDESCRIPTION: Demonstrates the 'wrap' mode for @model_serializer, which provides more flexibility by allowing custom logic before or after Pydantic's default serialization. It requires a 'handler' parameter to delegate serialization.",
    "chunk_length": 2063
  },
  {
    "chunk_id": 147,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, SerializerFunctionWrapHandler, model_serializer\n\n\nclass UserModel(BaseModel):\n    username: str\n    password: str\n\n    @model_serializer(mode='wrap')\n    def serialize_model(self, handler: SerializerFunctionWrapHandler) -> dict[str, object]:\n        serialized = handler(self)\n        serialized['fields'] = list(serialized)\n        return serialized\n\n\nprint(UserModel(username='foo', password='bar').model_dump())\n#> {'username': 'foo', 'password': 'bar', 'fields': ['username', 'password']}\n```\n\n----------------------------------------\n\nTITLE: Pydantic Annotated Pattern for Field Metadata\nDESCRIPTION: Illustrates using the Annotated typing construct to attach metadata like Field() and WithJsonSchema to model fields. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, WithJsonSchema\n\n\nclass Model(BaseModel):\n    name: Annotated[str, Field(strict=True), WithJsonSchema({'extra': 'data'})]\n```\n\n----------------------------------------\n\nTITLE: Default Factory with Callable\nDESCRIPTION: Shows how to use `default_factory` with a lambda function to generate a default value, such as a UUID. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom uuid import uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: str = Field(default_factory=lambda: uuid4().hex)\n```\n\n----------------------------------------\n\nTITLE: Pydantic ValidationError Handling\nDESCRIPTION: Demonstrates catching and printing Pydantic's `ValidationError` when data fails validation. The exception object contains details about all validation errors encountered. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    list_of_ints: list[int]\n    a_float: float\n\n\ndata = dict(\n    list_of_ints=['1', 2, 'bad'],\n    a_float='not a float',\n)\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    # > 2 validation errors for Model\n    # > list_of_ints.2\n    # >   Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]\n    # > a_float\n    # >   Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='not a float', input_type=str]\n    # >\n\n```\n\n----------------------------------------\n\nTITLE: Stdlib Dataclass Integration\nDESCRIPTION: Facilitates seamless integration between standard library `dataclasses` and Pydantic's `dataclasses`.",
    "chunk_length": 2865
  },
  {
    "chunk_id": 148,
    "source": "pydantic_llms_data",
    "content": "This includes converting standard library dataclasses into Pydantic dataclasses and allowing the use of standard library dataclasses within Pydantic models. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_194\n\nLANGUAGE: python\nCODE:\n```\n# Convert stdlib dataclasses to pydantic dataclasses\n# Use stdlib dataclasses in models\n```\n\n----------------------------------------\n\nTITLE: Handling Third-Party Types with Pydantic Annotations\nDESCRIPTION: Illustrates how to integrate third-party classes into Pydantic models using Annotated types. It defines `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` to specify parsing, validation, and serialization logic for the external type. Dependencies include `pydantic`, `pydantic_core`, and `typing`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import (\n    BaseModel,\n    GetCoreSchemaHandler,\n    GetJsonSchemaHandler,\n    ValidationError,\n)\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass ThirdPartyType:\n    \"\"\"\n    This is meant to represent a type from a third-party library that wasn't designed with Pydantic\n    integration in mind, and so doesn't have a `pydantic_core.CoreSchema` or anything. \"\"\"\n\n    x: int\n\n    def __init__(self):\n        self.x = 0\n\n\nclass _ThirdPartyTypePydanticAnnotation:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: GetCoreSchemaHandler,\n    ) -> core_schema.CoreSchema:\n        \"\"\"\n        We return a pydantic_core.CoreSchema that behaves in the following ways:\n\n        * ints will be parsed as `ThirdPartyType` instances with the int as the x attribute\n        * `ThirdPartyType` instances will be parsed as `ThirdPartyType` instances without any changes\n        * Nothing else will pass validation\n        * Serialization will always return just an int\n        \"\"\"\n\n        def validate_from_int(value: int) -> ThirdPartyType:\n            result = ThirdPartyType()\n            result.x = value\n            return result\n\n        from_int_schema = core_schema.chain_schema(\n            [\n                core_schema.int_schema(),\n                core_schema.no_info_plain_validator_function(validate_from_int),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=from_int_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    # check if it's an instance first before doing any further work\n                    core_schema.is_instance_schema(ThirdPartyType),\n                    from_int_schema,\n                ]\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                lambda instance: instance.x\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        # Use the same schema that would be used for `int`\n        return handler(core_schema.int_schema())\n\n\n# We now create an `Annotated` wrapper that we'll use as the annotation for fields on `BaseModel`s, etc.",
    "chunk_length": 3303
  },
  {
    "chunk_id": 149,
    "source": "pydantic_llms_data",
    "content": "PydanticThirdPartyType = Annotated[\n    ThirdPartyType, _ThirdPartyTypePydanticAnnotation\n]\n\n\n# Create a model class that uses this annotation as a field\nclass Model(BaseModel):\n    third_party_type: PydanticThirdPartyType\n\n\n# Demonstrate that this field is handled correctly, that ints are parsed into `ThirdPartyType`, and that\n# these instances are also \"dumped\" directly into ints as expected. m_int = Model(third_party_type=1)\nassert isinstance(m_int.third_party_type, ThirdPartyType)\nassert m_int.third_party_type.x == 1\nassert m_int.model_dump() == {'third_party_type': 1}\n```\n\n----------------------------------------\n\nTITLE: RootModel with Generic Type for List\nDESCRIPTION: Illustrates using `RootModel` with a generic type parameter to define a model that wraps a list of strings. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import RootModel\n\nPets = RootModel[list[str]]\nPetsByName = RootModel[dict[str, str]]\n\n\nprint(Pets(['dog', 'cat']))\n#> root=['dog', 'cat']\nprint(Pets(['dog', 'cat']).model_dump_json())\n#> [\"dog\",\"cat\"]\nprint(Pets.model_validate(['dog', 'cat']))\n#> root=['dog', 'cat']\nprint(Pets.model_json_schema())\n\"\"\"\n{'items': {'type': 'string'}, 'title': 'RootModel[list[str]]', 'type': 'array'}\n\"\"\"\n\nprint(PetsByName({'Otis': 'dog', 'Milo': 'cat'}))\n#> root={'Otis': 'dog', 'Milo': 'cat'}\nprint(PetsByName({'Otis': 'dog', 'Milo': 'cat'}).model_dump_json())\n#> {\"Otis\":\"dog\",\"Milo\":\"cat\"}\nprint(PetsByName.model_validate({'Otis': 'dog', 'Milo': 'cat'}))\n#> root={'Otis': 'dog', 'Milo': 'cat'}\n```\n\n----------------------------------------\n\nTITLE: Using Default Values with Partial JSON Parsing\nDESCRIPTION: Demonstrates advanced partial JSON parsing by using `WrapValidator` with a custom error handler to provide default values for missing fields. This ensures that models with optional or defaultable fields can be validated even with incomplete JSON input. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any, Optional\n\nimport pydantic_core\n\nfrom pydantic import BaseModel, ValidationError, WrapValidator\n\n\ndef default_on_error(v, handler) -> Any:\n    \"\"\"\n    Raise a PydanticUseDefault exception if the value is missing.",
    "chunk_length": 2334
  },
  {
    "chunk_id": 150,
    "source": "pydantic_llms_data",
    "content": "This is useful for avoiding errors from partial\n    JSON preventing successful validation. \"\"\"\n    try:\n        return handler(v)\n    except ValidationError as exc:\n        # there might be other types of errors resulting from partial JSON parsing\n        # that you allow here, feel free to customize as needed\n        if all(e['type'] == 'missing' for e in exc.errors()):\n            raise pydantic_core.PydanticUseDefault()\n        else:\n            raise\n\n\nclass NestedModel(BaseModel):\n    x: int\n    y: str\n\n\nclass MyModel(BaseModel):\n    foo: Optional[str] = None\n    bar: Annotated[\n        Optional[tuple[str, int]], WrapValidator(default_on_error)\n    ] = None\n    nested: Annotated[\n        Optional[NestedModel], WrapValidator(default_on_error)\n    ] = None\n\n\nm = MyModel.model_validate(\n    pydantic_core.from_json('{\"foo\": \"x\", \"bar\": [\"world\",', allow_partial=True)\n)\nprint(repr(m))\n#> MyModel(foo='x', bar=None, nested=None)\n\n\nm = MyModel.model_validate(\n    pydantic_core.from_json(\n        '{\"foo\": \"x\", \"bar\": [\"world\", 1], \"nested\": {\"x\":', allow_partial=True\n    )\n)\nprint(repr(m))\n#> MyModel(foo='x', bar=('world', 1), nested=None)\n```\n\n----------------------------------------\n\nTITLE: Pydantic GenerateJsonSchema API Reference\nDESCRIPTION: Provides API documentation for the `pydantic.json_schema.GenerateJsonSchema` class. This class is the core mechanism for customizing JSON schema generation, allowing users to override specific methods to alter the schema output. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_29\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.json_schema.GenerateJsonSchema\n  Description: Base class for customizing JSON schema generation. Methods: Implements methods for translating pydantic-core schema into JSON schema, designed for easy overriding in subclasses. ```\n\n----------------------------------------\n\nTITLE: Data Handling and Serialization\nDESCRIPTION: Updates related to data parsing, serialization, and handling of specific data types like datetime and timedelta.",
    "chunk_length": 2060
  },
  {
    "chunk_id": 151,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_296\n\nLANGUAGE: APIDOC\nCODE:\n```\nDatetime Parsing:\n  - Fixed datetime parsing in `parse_date`. Timedelta Serialization:\n  - Timedelta JSON encoding supports ISO8601 and total seconds. - Custom JSON encoders for timedelta. JSON Serialization:\n  - JSON serialization of models and schemas. ```\n\n----------------------------------------\n\nTITLE: TypeAdapter for TypedDict List Validation and Serialization\nDESCRIPTION: Demonstrates using TypeAdapter to validate and serialize lists of TypedDict objects. It covers handling validation errors and highlights that dump_json returns bytes, unlike BaseModel's model_dump_json which returns str. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/type_adapter.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nuser_list_adapter = TypeAdapter(list[User])\nuser_list = user_list_adapter.validate_python([{'name': 'Fred', 'id': '3'}])\nprint(repr(user_list))\n#> [{'name': 'Fred', 'id': 3}]\n\ntry:\n    user_list_adapter.validate_python(\n        [{'name': 'Fred', 'id': 'wrong', 'other': 'no'}]\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for list[User]\n    0.id\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='wrong', input_type=str]\n    \"\"\"\n\nprint(repr(user_list_adapter.dump_json(user_list)))\n#> b'[{\"name\":\"Fred\",\"id\":3}]'\n```\n\n----------------------------------------\n\nTITLE: Handling Mutable Default Values\nDESCRIPTION: Explains and demonstrates Pydantic's behavior with mutable default values, where it creates deep copies to ensure instance isolation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    item_counts: list[dict[str, int]] = [{}]\n\n\nm1 = Model()\nm1.item_counts[0]['a'] = 1\nprint(m1.item_counts)\n#> [{'a': 1}]\n\nm2 = Model()\nprint(m2.item_counts)\n#> [{}]\n```\n\n----------------------------------------\n\nTITLE: Pydantic v2.11.0 New Features\nDESCRIPTION: Introduces new features in Pydantic v2.11.0, focusing on build time performance.",
    "chunk_length": 2335
  },
  {
    "chunk_id": 152,
    "source": "pydantic_llms_data",
    "content": "Key additions include an `encoded_string()` method for URL types, support for `defer_build` with `@validate_call`, allowing `@with_config` with keyword arguments, simplifying default value inclusion in JSON Schema, and a new `generate_arguments_schema()` function. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# New Features in v2.11.0\n# Add encoded_string() method to the URL types\n# Add support for defer_build with @validate_call decorator\n# Allow @with_config decorator to be used with keyword arguments\n# Simplify customization of default value inclusion in JSON Schema generation\n# Add generate_arguments_schema() function\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model String Representation\nDESCRIPTION: Added in v0.2.0, the `to_string` method provides a way to generate a string representation of a Pydantic model. The `pretty` argument allows for formatted output, enhancing readability for debugging and display. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_309\n\nLANGUAGE: APIDOC\nCODE:\n```\nto_string(pretty: bool = False)\n  Generates a string representation of the model. Parameters:\n    pretty: If True, formats the output for better readability (e.g., with indentation). Returns: A string representing the model's data. ```\n\n----------------------------------------\n\nTITLE: Pydantic v0.31: Performance and Error Handling Improvements\nDESCRIPTION: Introduces performance improvements by removing `change_exceptions` and altering how pydantic errors are constructed. Also includes fixes for `StrictFloat` and `StrictInt` classes, and improved handling of `None` and `Optional` validators. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_267\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic v0.31 (Pre-release/Related to v0.32 features) Notes:\n\n- Add `StrictFloat` and `StrictInt` classes. - Related to issue [#799](https://github.com/pydantic/pydantic/pull/799). - Contributed by @DerRidda. - Improve handling of `None` and `Optional`.",
    "chunk_length": 2072
  },
  {
    "chunk_id": 153,
    "source": "pydantic_llms_data",
    "content": "- Replace `whole` with `each_item` (inverse meaning, default `False`) on validators. - Related to issue [#803](https://github.com/pydantic/pydantic/pull/803). - Contributed by @samuelcolvin. - Add support for `Type[T]` type hints. - Related to issue [#807](https://github.com/pydantic/pydantic/pull/807). - Contributed by @timonbimon. - Performance improvements from removing `change_exceptions`. - Change how pydantic errors are constructed. - Related to issue [#819](https://github.com/pydantic/pydantic/pull/819). - Contributed by @samuelcolvin. - Fix error message when a `BaseModel`-type model field causes a `ValidationError`. - Related to issue [#820](https://github.com/pydantic/pydantic/pull/820). - Contributed by @dmontagu. - Allow `getter_dict` on `Config`. - Modify `GetterDict` to be more like a `Mapping` object. - Related to issue [#821](https://github.com/pydantic/pydantic/pull/821). - Contributed by @samuelcolvin. - Only check `TypeVar` param on base `GenericModel` class. - Related to issue [#842](https://github.com/pydantic/pydantic/pull/842). - Contributed by @zpencerq. - Rename internal model attributes. - `Model._schema_cache` -> `Model.__schema_cache__`\n  - `Model._json_encoder` -> `Model.__json_encoder__`\n  - `Model._custom_root_type` -> `Model.__custom_root_type__`\n  - Related to issue [#851](https://github.com/pydantic/pydantic/pull/851). - Contributed by @samuelcolvin. ```\n\n----------------------------------------\n\nTITLE: Performance: Evaluate FieldInfo Annotations Lazily\nDESCRIPTION: Optimizes schema building by evaluating `FieldInfo` annotations only when necessary. This reduces overhead during the schema generation process. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import Field\n\n# This change improves performance by deferring annotation evaluation. ```\n\n----------------------------------------\n\nTITLE: Field Strictness Affecting Model Instantiation\nDESCRIPTION: Shows that setting strict=True on a Field affects validation during direct model instantiation.",
    "chunk_length": 2084
  },
  {
    "chunk_id": 154,
    "source": "pydantic_llms_data",
    "content": "It demonstrates that a field marked as strict will reject string inputs, while a field marked as strict=False will accept them. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(strict=True)\n    y: int = Field(strict=False)\n\n\ntry:\n    Model(x='1', y='2')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid integer [type=int_type, input_value='1', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Default Factory with Data Argument\nDESCRIPTION: Illustrates using `default_factory` with a lambda that accepts the validated data dictionary as an argument to derive a default value. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, EmailStr, Field\n\n\nclass User(BaseModel):\n    email: EmailStr\n    username: str = Field(default_factory=lambda data: data['email'])\n\n\nuser = User(email='user@example.com')\nprint(user.username)\n#> user@example.com\n```\n\n----------------------------------------\n\nTITLE: Pydantic Alias Generator with Callable\nDESCRIPTION: Shows how to use an alias generator with a callable (e.g., a lambda function) to automatically convert field names to uppercase for serialization. This simplifies consistent naming conventions across models. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Tree(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=lambda field_name: field_name.upper()\n    )\n\n    age: int\n    height: float\n    kind: str\n\n\nt = Tree.model_validate({'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'})\nprint(t.model_dump(by_alias=True))\n#> {'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'}\n```\n\n----------------------------------------\n\nTITLE: Constrained Strings as Dict Keys\nDESCRIPTION: Added support for using constrained strings as dictionary keys in schema generation, allowing for more specific key validation.",
    "chunk_length": 2236
  },
  {
    "chunk_id": 155,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_286\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, conint, constr\n\nclass ConstrainedKeyModel(BaseModel):\n    # This example demonstrates the concept, actual key validation might differ\n    # Pydantic primarily validates values, but schema generation reflects constraints\n    data: dict[constr(min_length=3), int]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Breaking Changes and Behavior Updates\nDESCRIPTION: Highlights significant changes and behavioral modifications in Pydantic releases. This includes updates to error formatting, argument behavior, and configuration handling. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_303\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Breaking Changes and Behavior Updates:\n\nErrors Format:\n  - New errors format introduced, potentially breaking existing error handling. conint/confloat arguments:\n  - Corrected behavior for `lt` and `gt` arguments. Use `le` and `ge` for previous behavior. Config attributes:\n  - Removed `Config.min_number_size` and `Config.max_number_size`. - Renamed `.config` to `.__config__` on models. Model values:\n  - Defaults are now copied to model values, preventing shared mutable objects between models. `.values()` method:\n  - Deprecated, use `.dict()` instead. ```\n\n----------------------------------------\n\nTITLE: Support for Postponed Annotations\nDESCRIPTION: Added support for postponed annotations, allowing type hints to refer to classes defined later in the same module or file. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_281\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\nfrom pydantic import BaseModel\n\nclass Node(BaseModel):\n    next: 'Node' | None = None # Postponed annotation\n```\n\n----------------------------------------\n\nTITLE: Support Generics Model with create_model\nDESCRIPTION: Enables the use of generic types within models created dynamically using `pydantic.create_model`, expanding flexibility for dynamic model creation.",
    "chunk_length": 2090
  },
  {
    "chunk_id": 156,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_86\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import create_model\nfrom typing import List, TypeVar\n\nT = TypeVar('T')\n\n# Dynamically create a model with a generic list field\nGenericListModel = create_model('GenericListModel', items='List[T]')\n\n# Usage:\n# model_int = GenericListModel[int](items=[1, 2, 3])\n# model_str = GenericListModel[str](items=['a', 'b'])\n\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Pydantic Models\nDESCRIPTION: Demonstrates how to iterate over Pydantic models, yielding field names and values. Sub-models are not automatically converted to dictionaries during iteration. This functionality allows for easy inspection of model contents. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nfor name, value in m:\n    print(f'{name}: {value}')\n    #> banana: 3.14\n    #> foo: hello\n    #> bar: whatever=123\n```\n\nLANGUAGE: python\nCODE:\n```\nprint(dict(m))\n#> {'banana': 3.14, 'foo': 'hello', 'bar': BarModel(whatever=123)}\n```\n\n----------------------------------------\n\nTITLE: Validating Default Values\nDESCRIPTION: Demonstrates how to enable validation of default values using `validate_default=True` in `Field`, showing error handling for invalid defaults. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    age: int = Field(default='twelve', validate_default=True)\n\n\ntry:\n    user = User()\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n1 validation error for User\nage\n  Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='twelve', input_type=str]\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: ConfigDict Validation Settings\nDESCRIPTION: Details configuration options within `ConfigDict` for controlling alias usage during validation.",
    "chunk_length": 2268
  },
  {
    "chunk_id": 157,
    "source": "pydantic_llms_data",
    "content": "`validate_by_alias` (default True) and `validate_by_name` (default False) determine how Pydantic matches input data to model fields. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_10\n\nLANGUAGE: APIDOC\nCODE:\n```\nConfigDict Settings for Validation:\n  - validate_by_alias: Controls if aliases are used for validation. Defaults to True. - validate_by_name: Controls if attribute names are used for validation. Defaults to False. Note: You cannot set both `validate_by_alias` and `validate_by_name` to `False`. Doing so raises a user error. ```\n\n----------------------------------------\n\nTITLE: Automatic Pydantic Validation Instrumentation\nDESCRIPTION: Shows how to automatically instrument Pydantic models with Logfire to capture validation success and failure events. This provides detailed insights into data validation processes within your application. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/logfire.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()\nlogfire.instrument_pydantic()  # (1)! class User(BaseModel):\n    name: str\n    country_code: str\n    dob: date\n\n\nUser(name='Anne', country_code='USA', dob='2000-01-01')\nUser(name='David', country_code='GBR', dob='invalid-dob')\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Correct validator fields as arguments\nDESCRIPTION: Shows the correct method for applying a validator to multiple fields by passing each field name as a separate string argument to the `@field_validator` decorator. This avoids the 'invalid validator fields' error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    a: str\n    b: str\n\n    @field_validator('a', 'b')\n    def check_fields(cls, v):\n        return v\n```\n\n----------------------------------------\n\nTITLE: Support for Callable Type Hint\nDESCRIPTION: Introduced support for the `Callable` type hint, enhancing the library's ability to handle function signatures and callables.",
    "chunk_length": 2188
  },
  {
    "chunk_id": 158,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_268\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\ndef process_callback(callback: Callable[[int], str]):\n    # ... implementation ... ```\n\n----------------------------------------\n\nTITLE: Pydantic Model from Nested Arbitrary Instances\nDESCRIPTION: Illustrates how Pydantic models can parse nested arbitrary class instances when `from_attributes=True` is enabled. It shows parsing a person object containing a list of pet objects. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass PetCls:\n    def __init__(self, *, name: str, species: str):\n        self.name = name\n        self.species = species\n\n\nclass PersonCls:\n    def __init__(self, *, name: str, age: float = None, pets: list[PetCls]):\n        self.name = name\n        self.age = age\n        self.pets = pets\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    species: str\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    age: float = None\n    pets: list[Pet]\n\n\nbones = PetCls(name='Bones', species='dog')\norion = PetCls(name='Orion', species='cat')\nanna = PersonCls(name='Anna', age=20, pets=[bones, orion])\nanna_model = Person.model_validate(anna)\nprint(anna_model)\n# > name='Anna' age=20.0 pets=[Pet(name='Bones', species='dog'), Pet(name='Orion', species='cat')]\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Root Model in Pydantic\nDESCRIPTION: Demonstrates how to define a basic Root Model in Pydantic. Root Models are useful when you need to validate a single value, such as a list or a primitive type, rather than a dictionary-like structure. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/root_model.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import RootModel\n\nclass MyListModel(RootModel[list[int]]):\n    pass\n\n# Example usage:\nmy_list = MyListModel([1, 2, 3])\nprint(my_list.root)\n# Output: [1, 2, 3]\n\nclass MyStringModel(RootModel[str]):\n    pass\n\nmy_string = MyStringModel(\"hello\")\nprint(my_string.root)\n# Output: hello\n```\n\n----------------------------------------\n\nTITLE: Pydantic AliasPath for Nested Field Aliases\nDESCRIPTION: Demonstrates using AliasPath to specify a path to a field, including array indices, for validation.",
    "chunk_length": 2445
  },
  {
    "chunk_id": 159,
    "source": "pydantic_llms_data",
    "content": "Shows how to access nested data using aliases. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, AliasPath\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasPath('names', 0))\n    last_name: str = Field(validation_alias=AliasPath('names', 1))\n\nuser = User.model_validate({'names': ['John', 'Doe']})  # (1)! print(user)\n#> first_name='John' last_name='Doe'\n```\n\n----------------------------------------\n\nTITLE: Validate JSON with Multiple Partial Items\nDESCRIPTION: Demonstrates validating a JSON string containing multiple items, where one item is complete and valid, and another is incomplete. Partial validation correctly processes the complete item and handles the incomplete one. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict):\n    a: int\n    b: NotRequired[float]\n    c: NotRequired[Annotated[str, MinLen(5)]]\n\n\nta = TypeAdapter(list[Foobar])\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcde\"},{\"a\": ', experimental_allow_partial=True\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0, 'c': 'abcde'}]\n```\n\n----------------------------------------\n\nTITLE: MongoDB DSN Schema Support\nDESCRIPTION: Adds a schema for validating MongoDB network data source names (DSNs), enabling robust configuration for MongoDB connections. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_106\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\nfrom pydantic.networks import MongoDsn\n\nclass MongoConfig(BaseModel):\n    # Validates MongoDB connection strings\n    db_uri: MongoDsn\n\n# Example:\n# config = MongoConfig(db_uri='mongodb://user:pass@host:port/database?authSource=admin')\n# Invalid DSNs will raise a ValidationError. ```\n\n----------------------------------------\n\nTITLE: Avoid with_config on BaseModel Subclasses\nDESCRIPTION: Demonstrates the PydanticUserError raised when the `with_config` decorator is incorrectly applied to a class that already inherits from `BaseModel`.",
    "chunk_length": 2280
  },
  {
    "chunk_id": 160,
    "source": "pydantic_llms_data",
    "content": "The correct approach is to use the `model_config` attribute. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, with_config\n\ntry:\n\n    @with_config({'allow_inf_nan': True})\n    class Model(BaseModel):\n        bar: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'with-config-on-model'\n```\n\n----------------------------------------\n\nTITLE: Model Serializer - Plain Mode\nDESCRIPTION: Shows how to use the @model_serializer decorator in 'plain' mode to serialize an entire Pydantic model into a custom string format. The 'plain' mode is the default and allows returning non-dictionary values. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, model_serializer\n\n\nclass UserModel(BaseModel):\n    username: str\n    password: str\n\n    @model_serializer(mode='plain')  # (1)! def serialize_model(self) -> str:  # (2)! return f'{self.username} - {self.password}'\n\n\nprint(UserModel(username='foo', password='bar').model_dump())\n#> foo - bar\n```\n\n----------------------------------------\n\nTITLE: Pydantic Schema Generation: Pattern Type\nDESCRIPTION: Adds basic support for the `Pattern` type in schema generation, allowing regular expressions to be included in OpenAPI/JSON schemas. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_205\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\nfrom typing import Pattern\nimport re\n\nclass RegexModel(BaseModel):\n    # Using Field with Pattern type\n    uuid_string: Pattern[str] = Field(regex=r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$')\n\n# When generating schema for RegexModel, the regex pattern will be included. # Example: RegexModel(uuid_string='123e4567-e89b-12d3-a456-426614174000')\n\n```\n\n----------------------------------------\n\nTITLE: Generic Subclassing of Pydantic Models\nDESCRIPTION: Illustrates creating a generic subclass of a Pydantic model that inherits and potentially redefines type variables from its superclass.",
    "chunk_length": 2179
  },
  {
    "chunk_id": 161,
    "source": "pydantic_llms_data",
    "content": "This allows for flexible type hinting and model definition. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTypeX = TypeVar('TypeX')\nTypeY = TypeVar('TypeY')\nTypeZ = TypeVar('TypeZ')\n\n\nclass BaseClass(BaseModel, Generic[TypeX, TypeY]):\n    x: TypeX\n    y: TypeY\n\n\nclass ChildClass(BaseClass[int, TypeY], Generic[TypeY, TypeZ]):\n    z: TypeZ\n```\n\n----------------------------------------\n\nTITLE: SecretsSettingsSource Respects Case Sensitivity\nDESCRIPTION: Updates `SecretsSettingsSource` to correctly respect the `config.case_sensitive` setting, ensuring environment variable lookup is case-aware as configured. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_105\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseSettings, SettingsConfigDict\n\nclass AppSettings(BaseSettings):\n    # If case_sensitive is True, MY_VAR is different from my_var\n    my_var: str\n\n    model_config = SettingsConfigDict(env_prefix='APP_', case_sensitive=True)\n\n# Example:\n# If env var is MY_VAR='value', and case_sensitive=True, it will be loaded. # If case_sensitive=False, my_var='value' would also load MY_VAR. ```\n\n----------------------------------------\n\nTITLE: validate_call: Positional or Keyword Parameters\nDESCRIPTION: Demonstrates the `validate_call` decorator with functions accepting positional or keyword parameters, including those with default values. It shows how arguments are passed and validated against type hints. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import validate_call\n\n\n@validate_call\ndef pos_or_kw(a: int, b: int = 2) -> str:\n    return f'a={a} b={b}'\n\n\nprint(pos_or_kw(1, b=3))\n#> a=1 b=3\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Frozen Models for Hashability\nDESCRIPTION: Introduces a `frozen=True` parameter in `Config`. Setting this makes models immutable and generates a `__hash__()` method, enabling instances to be hashable if their attributes are hashable.",
    "chunk_length": 2170
  },
  {
    "chunk_id": 162,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_183\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nclass ImmutableModel(BaseModel):\n    class Config:\n        frozen = True\n\n    id: int\n    name: str\n\n# Example usage:\n# model_instance = ImmutableModel(id=1, name='Example')\n# print(hash(model_instance))\n# \n# # This would raise a TypeError:\n# # model_instance.id = 2\n```\n\n----------------------------------------\n\nTITLE: Pydantic User Model Validation\nDESCRIPTION: Defines a Pydantic BaseModel 'User' with various field types and demonstrates how to catch and print validation errors when instantiating the model with incorrect data. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/index.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom pydantic import BaseModel, PositiveInt, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime | None\n    tastes: dict[str, PositiveInt]\n\n\nexternal_data = {'id': 'not an int', 'tastes': {}}  # (1)! try:\n    User(**external_data)  # (2)! except ValidationError as e:\n    print(e.errors())\n```\n\nLANGUAGE: python\nCODE:\n```\n[\n    {\n        'type': 'int_parsing',\n        'loc': ('id',),\n        'msg': 'Input should be a valid integer, unable to parse string as an integer',\n        'input': 'not an int',\n        'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n    },\n    {\n        'type': 'missing',\n        'loc': ('signup_ts',),\n        'msg': 'Field required',\n        'input': {'id': 'not an int', 'tastes': {}},\n        'url': 'https://errors.pydantic.dev/2/v/missing',\n    },\n]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Type Handling for Standard Library\nDESCRIPTION: Provides an overview of Pydantic's validation and coercion mechanisms for core Python types like int, float, and enum.IntEnum, detailing accepted inputs and conversion processes. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_5\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Standard Library Type Support:\n\nBooleans:\n  - Accepts: bool, int (0/1), str ('true', 'false', 'yes', 'no', etc.",
    "chunk_length": 2192
  },
  {
    "chunk_id": 163,
    "source": "pydantic_llms_data",
    "content": "case-insensitive), bytes (decoded to str). - StrictBool: For only accepting True/False. Datetimes:\n  datetime:\n    - Accepts: datetime object, int/float (Unix time in seconds or milliseconds), str (ISO 8601 format, YYYY-MM-DD). - date objects are accepted in lax mode. date:\n    - Accepts: date object, int/float (Unix time), str (YYYY-MM-DD). time:\n    - Accepts: time object, str (HH:MM[:SS[.ffffff]]). timedelta:\n    - Accepts: timedelta object, int/float (seconds), str (e.g., '1d,01:02:03', ISO 8601 P...T...S format). Numbers:\n  int:\n    - Coerces using int(v). float:\n    - Coerces using float(v). Enums:\n  enum.IntEnum:\n    - Validates that the value is a valid IntEnum instance or member. ```\n\n----------------------------------------\n\nTITLE: Dataclass InitVar Serialization\nDESCRIPTION: Correction to ensure `dataclass` `InitVar` is not required during serialization, aligning with expected behavior. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n`dataclass` `InitVar` shouldn't be required on serialization\n```\n\n----------------------------------------\n\nTITLE: Comparison Method for Color Class\nDESCRIPTION: Adds a comparison method to the `Color` class, enabling direct comparison of color instances based on their properties. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_97\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nclass Color(BaseModel):\n    r: int\n    g: int\n    b: int\n\n    def __eq__(self, other):\n        if not isinstance(other, Color):\n            return NotImplemented\n        return self.r == other.r and self.g == other.g and self.b == other.b\n\n# Example:\n# color1 = Color(r=255, g=0, b=0)\n# color2 = Color(r=255, g=0, b=0)\n# print(color1 == color2) # True\n```\n\n----------------------------------------\n\nTITLE: Config.anystr_upper and constr/conbytes to_upper\nDESCRIPTION: Introduces `Config.anystr_upper` and a `to_upper` keyword argument for `constr` (constrained string) and `conbytes` (constrained bytes). These allow for automatic conversion of string or byte values to uppercase during validation.",
    "chunk_length": 2135
  },
  {
    "chunk_id": 164,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_76\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, constr\n\nclass UpperCaseModel(BaseModel):\n    class Config:\n        anystr_upper = True\n\n    name: str\n    code: constr(to_upper=True)\n\nmodel = UpperCaseModel(name=\"test\", code=\"abc\")\n\nprint(model.name) # Output: TEST\nprint(model.code) # Output: ABC\n\n```\n\n----------------------------------------\n\nTITLE: Performance: Speed up _get_all_json_refs()\nDESCRIPTION: Boosts the performance of `_get_all_json_refs()` by 34% in `pydantic/json_schema.py`, optimizing JSON schema generation. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_46\n\nLANGUAGE: python\nCODE:\n```\n# Internal optimization in pydantic/json_schema.py\n# Improves the efficiency of resolving and collecting JSON references within schemas. ```\n\n----------------------------------------\n\nTITLE: Pydantic Field Customization with typing.Annotated\nDESCRIPTION: Shows how to specify JSON schema modifications via the Field constructor using typing.Annotated. This approach allows for cleaner integration of field metadata and constraints directly within the type hint. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom typing import Annotated\nfrom uuid import uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    id: Annotated[str, Field(default_factory=lambda: uuid4().hex)]\n    name: Annotated[str, Field(max_length=256)] = Field(\n        'Bar', title='CustomName'\n    )\n\n\nprint(json.dumps(Foo.model_json_schema(), indent=2))\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"properties\": {\n    \"id\": {\n      \"title\": \"Id\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"default\": \"Bar\",\n      \"maxLength\": 256,\n      \"title\": \"CustomName\",\n      \"type\": \"string\"\n    }\n  },\n  \"title\": \"Foo\",\n  \"type\": \"object\"\n}\n```\n\n----------------------------------------\n\nTITLE: Pydantic Custom Cyclic Reference Handling\nDESCRIPTION: Provides a custom validator and context manager to gracefully handle and suppress `ValidationError` instances caused by cyclic references, allowing for controlled processing of such data structures.",
    "chunk_length": 2247
  },
  {
    "chunk_id": 165,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/forward_annotations.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom contextlib import contextmanager\nfrom dataclasses import field\nfrom typing import Iterator\n\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\ndef is_recursion_validation_error(exc: ValidationError) -> bool:\n    errors = exc.errors()\n    return len(errors) == 1 and errors[0]['type'] == 'recursion_loop'\n\n\n@contextmanager\ndef suppress_recursion_validation_error() -> Iterator[None]:\n    try:\n        yield\n    except ValidationError as exc:\n        if not is_recursion_validation_error(exc):\n            raise exc\n\n\nclass Node(BaseModel):\n    id: int\n    children: list['Node'] = field(default_factory=list)\n\n    @field_validator('children', mode='wrap')\n    @classmethod\n    def drop_cyclic_references(cls, children, h):\n        try:\n            return h(children)\n        except ValidationError as exc:\n            if not (\n                is_recursion_validation_error(exc)\n                and isinstance(children, list)\n            ):\n                raise exc\n\n            value_without_cyclic_refs = []\n            for child in children:\n                with suppress_recursion_validation_error():\n                    value_without_cyclic_refs.extend(h([child]))\n            return h(value_without_cyclic_refs)\n\n\n# Create data with cyclic references representing the graph 1 -> 2 -> 3 -> 1\nnode_data = {'id': 1, 'children': [{'id': 2, 'children': [{'id': 3}]}]}\nnode_data['children'][0]['children'][0]['children'] = [node_data]\n\nprint(Node.model_validate(node_data))\n#> id=1 children=[Node(id=2, children=[Node(id=3, children=[])])]\n```\n\n----------------------------------------\n\nTITLE: Update AnyClassMethod for typeshed changes\nDESCRIPTION: Updates the `AnyClassMethod` definition to align with recent changes in python/typeshed issue 9771. This ensures Pydantic's type hinting remains accurate and compatible. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_55\n\nLANGUAGE: python\nCODE:\n```\n# update `AnyClassMethod` for changes in [python/typeshed#9771](https://github.com/python/typeshed/issues/9771), [#5505](https://github.com/pydantic/pydantic/pull/5505) by @ITProKyle\n```\n\n----------------------------------------\n\nTITLE: Introduction of conset() Validator\nDESCRIPTION: Introduces `conset()`, a new validator analogous to `conlist()`, enabling constrained sets with specific validation rules.",
    "chunk_length": 2484
  },
  {
    "chunk_id": 166,
    "source": "pydantic_llms_data",
    "content": "This expands Pydantic's capabilities for validating collection types. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_221\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, conset\n\nclass MyModel(BaseModel):\n    my_set: conset(min_items=2, max_items=5, unique_items=True)\n\n# Example usage:\n# model = MyModel(my_set={1, 2, 3})\n# model_invalid = MyModel(my_set={1})\n# This would raise a ValidationError because min_items is 2\n```\n\n----------------------------------------\n\nTITLE: Pydantic SQLAlchemy Model Integration\nDESCRIPTION: Demonstrates integrating Pydantic models with SQLAlchemy by defining a Pydantic model that validates SQLAlchemy model instances. It highlights the use of Pydantic's `Field` with `alias` to map to SQLAlchemy columns, especially when column names conflict with Python reserved keywords or SQLAlchemy attributes. This approach helps manage database schema definitions with Pydantic's validation capabilities. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/orms.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import declarative_base\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass MyModel(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    metadata: dict[str, str] = Field(alias='metadata_')\n\n\nBase = declarative_base()\n\n\nclass MyTableModel(Base):\n    __tablename__ = 'my_table'\n    id = sa.Column('id', sa.Integer, primary_key=True)\n    # 'metadata' is reserved by SQLAlchemy, hence the '_'\n    metadata_ = sa.Column('metadata', sa.JSON)\n\n\nsql_model = MyTableModel(metadata_={'key': 'val'}, id=1)\npydantic_model = MyModel.model_validate(sql_model)\n\nprint(pydantic_model.model_dump())\n#> {'metadata': {'key': 'val'}}\nprint(pydantic_model.model_dump(by_alias=True))\n#> {'metadata_': {'key': 'val'}}\n```\n\n----------------------------------------\n\nTITLE: Hypothesis plugin for constrained floats\nDESCRIPTION: Enables the Hypothesis plugin to generate constrained floats when the `multiple_of` argument is specified.",
    "chunk_length": 2062
  },
  {
    "chunk_id": 167,
    "source": "pydantic_llms_data",
    "content": "This improves property-based testing for numerical constraints. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_136\n\nLANGUAGE: python\nCODE:\n```\nenable the Hypothesis plugin to generate a constrained float when the `multiple_of` argument is specified, [#2442](https://github.com/pydantic/pydantic/pull/2442) by @tobi-lipede-oodle\n```\n\n----------------------------------------\n\nTITLE: Pydantic TypeAdapter Partial Validation API\nDESCRIPTION: Details the 'experimental_allow_partial' flag for Pydantic's TypeAdapter validation methods (validate_json, validate_python, validate_strings). It supports 'off', 'on', and 'trailing-strings' modes for handling incomplete data, with 'trailing-strings' allowing incomplete final strings. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_4\n\nLANGUAGE: APIDOC\nCODE:\n```\nTypeAdapter.validate_json(..., experimental_allow_partial: bool | str = False)\nTypeAdapter.validate_python(..., experimental_allow_partial: bool | str = False)\nTypeAdapter.validate_strings(..., experimental_allow_partial: bool | str = False)\n\nParameters:\n  experimental_allow_partial: Controls partial validation behavior. - False or 'off': Disables partial validation (default). - True or 'on': Enables partial validation, does not support trailing strings. - 'trailing-strings': Enables partial validation and supports trailing incomplete strings. Description:\n  Enables validation of incomplete JSON or Python data structures. Useful for streaming data where the input may be truncated. The 'trailing-strings' mode specifically allows incomplete string values at the end of the input to be included in the validated output. ```\n\n----------------------------------------\n\nTITLE: Pydantic parse_raw_as Utility\nDESCRIPTION: Adds a new utility function `parse_raw_as` for parsing raw data into a specified Pydantic model or type. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_203\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import parse_raw_as, BaseModel\n\nclass User(BaseModel):\n    name: str\n    age: int\n\njson_data = '{\"name\": \"Alice\", \"age\": 30}'\n\n# Parse JSON string into a User model\nuser_instance = parse_raw_as(User, json_data)\nprint(user_instance)\n\n# Parse JSON string into a list of User models\njson_list_data = '[{\"name\": \"Bob\", \"age\": 25}, {\"name\": \"Charlie\", \"age\": 35}]'\nuser_list = parse_raw_as(list[User], json_list_data)\nprint(user_list)\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Validator (Wrap Mode)\nDESCRIPTION: Illustrates a 'wrap' model validator in Pydantic, offering the most flexibility.",
    "chunk_length": 2642
  },
  {
    "chunk_id": 168,
    "source": "pydantic_llms_data",
    "content": "It allows executing code before and after Pydantic's validation, or terminating validation early by returning data or raising an error. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nfrom typing import Any\n\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, ModelWrapValidatorHandler, ValidationError, model_validator\n\n\nclass UserModel(BaseModel):\n    username: str\n\n    @model_validator(mode='wrap')\n    @classmethod\n    def log_failed_validation(cls, data: Any, handler: ModelWrapValidatorHandler[Self]) -> Self:\n        try:\n            return handler(data)\n        except ValidationError:\n            logging.error('Model %s failed to validate with data %s', cls, data)\n            raise\n```\n\n----------------------------------------\n\nTITLE: Validate TypedDict with Pydantic\nDESCRIPTION: Explains and demonstrates using Python's TypedDict with Pydantic for dictionaries with fixed keys and value types. Requires `typing-extensions` for Python versions prior to 3.12. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nta = TypeAdapter(User)\n\nprint(ta.validate_python({'name': 'foo', 'id': 1}))\n# Expected output: {'name': 'foo', 'id': 1}\n\ntry:\n    ta.validate_python({'name': 'foo'})\nexcept ValidationError as e:\n    print(e)\n    # Expected output:\n    # 1 validation error for User\n    # id\n    #   Field required [type=missing, input_value={'name': 'foo'}, input_type=dict]\n```\n\n----------------------------------------\n\nTITLE: RootModel Extra Config Not Allowed in Pydantic\nDESCRIPTION: This error occurs when `model_config['extra']` is specified with `RootModel`. `RootModel` does not support extra fields during initialization, making this configuration invalid. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import PydanticUserError, RootModel\n\ntry:\n\n    class MyRootModel(RootModel):\n        model_config = {'extra': 'allow'}\n        root: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'root-model-extra'\n```\n\n----------------------------------------\n\nTITLE: Schema Generation and Validation\nDESCRIPTION: Improvements and additions related to schema generation, compatibility with JSON Schema and OpenAPI, and validation for string and numeric types.",
    "chunk_length": 2608
  },
  {
    "chunk_id": 169,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_293\n\nLANGUAGE: APIDOC\nCODE:\n```\nSchema Generation:\n  - Refactored schema generation for compatibility with JSON Schema and OpenAPI specs. - Added `schema` to `schema` module for generating top-level schemas from base models. - Introduced `Schema` class with additional fields for declaring validation for `str` and numeric values. - Fixed schema generation for fields defined using `typing.Any`. - Major improvements and changes to schema generation. - Model schema generation. Field Renaming:\n  - Renamed `_schema` to `schema` on fields. Validation Enhancements:\n  - Fixed issue where `int_validator` did not cast a `bool` to an `int`. - Made `list`, `tuple`, and `set` types stricter. - Fixed `list`, `set`, & `tuple` validation. - Separated `validate_model` method to allow returning errors along with valid values. ```\n\n----------------------------------------\n\nTITLE: Pydantic Forward Refs and Optional Fields\nDESCRIPTION: Fixes behavior with forward references and optional fields in nested Pydantic models. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_210\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\nfrom typing import Optional, TYPE_CHECKING\n\nif TYPE_CHECKING:\n    # Forward reference to a model defined later or in another module\n    class ParentModel(BaseModel):\n        child: Optional['ChildModel']\nelse:\n    # Actual definition for runtime\n    class ChildModel(BaseModel):\n        value: int\n\n    class ParentModel(BaseModel):\n        child: Optional[ChildModel]\n\n# This ensures that optional fields with forward references are handled correctly. ```\n\n----------------------------------------\n\nTITLE: Pydantic Handling of `typing.Annotated`\nDESCRIPTION: Details Pydantic's support for `typing.Annotated` as per PEP-593, noting that it allows arbitrary metadata but typically only processes a single call to the `Field` function, ignoring other additional metadata. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_33\n\nLANGUAGE: APIDOC\nCODE:\n```\ntyping.Annotated:\n  Description: Allows wrapping another type with arbitrary metadata, as per [PEP-593](https://www.python.org/dev/peps/pep-0593/).",
    "chunk_length": 2275
  },
  {
    "chunk_id": 170,
    "source": "pydantic_llms_data",
    "content": "Behavior: The `Annotated` hint may contain a single call to the `Field` function, but otherwise the additional metadata is ignored and the root type is used. ```\n\n----------------------------------------\n\nTITLE: Pydantic Literal with Union and ClassVar\nDESCRIPTION: Shows how typing.Literal can be combined with Union and ClassVar to create discriminated unions and define class-specific constants. Illustrates parsing different types within a union based on literal field values. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar, Literal, Union\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Cake(BaseModel):\n    kind: Literal['cake']\n    required_utensils: ClassVar[list[str]] = ['fork', 'knife']\n\n\nclass IceCream(BaseModel):\n    kind: Literal['icecream']\n    required_utensils: ClassVar[list[str]] = ['spoon']\n\n\nclass Meal(BaseModel):\n    dessert: Union[Cake, IceCream]\n\n\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\nprint(type(Meal(dessert={'kind': 'icecream'}).dessert).__name__)\ntry:\n    Meal(dessert={'kind': 'pie'})\nexcept ValidationError as e:\n    print(str(e))\n    \n```\n\n----------------------------------------\n\nTITLE: Python: Serialize Unparametrized Type Variables\nDESCRIPTION: Details serialization differences for type variables with bounds or defaults when unparametrized. Shows how Pydantic treats values as `Any` for serialization when the generic type is not explicitly parametrized. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\n\nErrorDataT = TypeVar('ErrorDataT', bound=ErrorDetails)\n\n\nclass Error(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: ErrorDataT\n\n\nclass MyErrorDetails(ErrorDetails):\n    bar: str\n\n\n# serialized as Any\nerror = Error(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='var2'),\n)\nprint(error.model_dump())\n```\n\n----------------------------------------\n\nTITLE: Validate YAML Data with Pydantic in Python\nDESCRIPTION: Validates data from a YAML file using Pydantic.",
    "chunk_length": 2276
  },
  {
    "chunk_id": 171,
    "source": "pydantic_llms_data",
    "content": "It utilizes the `yaml` library to load YAML content and then validates the data against a Pydantic model. Requires `pydantic` and `PyYAML` libraries. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport yaml\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.yaml') as f:\n    data = yaml.safe_load(f)\n\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```\n\n----------------------------------------\n\nTITLE: Inherit from Stdlib Dataclasses with Pydantic\nDESCRIPTION: Demonstrates how Pydantic automatically validates fields when inheriting from standard library dataclasses. Shows how Pydantic's dataclass decorator handles nested inheritance and type coercion. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass Z:\n    z: int\n\n\n@dataclasses.dataclass\nclass Y(Z):\n    y: int = 0\n\n\n@pydantic.dataclasses.dataclass\nclass X(Y):\n    x: int = 0\n\n\nfoo = X(x=b'1', y='2', z='3')\nprint(foo)\n#> X(z=3, y=2, x=1)\n\ntry:\n    X(z='pika')\nexcept pydantic.ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for X\n    z\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='pika', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Programmatic Title Generation\nDESCRIPTION: Enables programmatic generation of titles for Pydantic models, enhancing schema clarity and documentation. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_38\n\nLANGUAGE: APIDOC\nCODE:\n```\nBaseModel.model_json_schema(by_alias: bool = True, ...):\n  # ... schema generation logic ... # The 'title' field in the schema can be programmatically set. # Example:\n  # class MyModel(BaseModel):\n  #   class Config:\n  #     title = \"My Custom Model Title\"\n  #   field: int\n```\n\n----------------------------------------\n\nTITLE: Configure Strict Mode with TypeAdapter in Pydantic\nDESCRIPTION: Demonstrates how to use Pydantic's TypeAdapter with a ConfigDict to enable strict mode.",
    "chunk_length": 2314
  },
  {
    "chunk_id": 172,
    "source": "pydantic_llms_data",
    "content": "Strict mode enforces that input values must conform precisely to the target type, rejecting coerced values. This snippet shows how to catch validation errors when non-strict inputs are provided. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, TypeAdapter, ValidationError\n\nadapter = TypeAdapter(bool, config=ConfigDict(strict=True))\n\ntry:\n    adapter.validate_python('yes')\nexcept ValidationError as exc:\n    print(exc)\n    \n```\n\n----------------------------------------\n\nTITLE: Pydantic v2.11.1 Fixes\nDESCRIPTION: Addresses an issue in Pydantic v2.11.1 where `'definitions-ref'` schemas containing serialization schemas or metadata were not handled correctly. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Fixes in v2.11.1\n# Do not override 'definitions-ref' schemas containing serialization schemas or metadata\n```\n\n----------------------------------------\n\nTITLE: Pydantic BaseModel.model_copy API\nDESCRIPTION: API documentation for the `model_copy()` method of Pydantic's `BaseModel`. This method allows for creating a copy of a model instance, optionally updating fields or performing a deep copy. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_24\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.main.BaseModel.model_copy\n\nCopies the model instance. Parameters:\n  update (Optional[Dict[str, Any]]): A dictionary of fields to update in the new model instance. Defaults to None. deep (bool): If True, perform a deep copy of the model instance. Defaults to False. Returns:\n  BaseModel: A new model instance that is a copy of the original, with optional updates and deep copy behavior. Notes:\n  - Useful for working with frozen models. - When `deep=True`, nested models and mutable objects (like lists or dicts) are also copied recursively. - When `deep=False` (default), nested models and mutable objects are shared by reference between the original and the copied instance.",
    "chunk_length": 2076
  },
  {
    "chunk_id": 173,
    "source": "pydantic_llms_data",
    "content": "```\n\n----------------------------------------\n\nTITLE: Config Field Defaults for String Length\nDESCRIPTION: Changed default values for `BaseConfig` attributes `min_anystr_length` and `max_anystr_length` to `None`, simplifying default string validation behavior. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_280\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nclass ModelWithConfig(BaseModel):\n    class Config:\n        # min_anystr_length and max_anystr_length are None by default\n```\n\n----------------------------------------\n\nTITLE: Type Annotations and Mypy Testing\nDESCRIPTION: Enhanced code quality by adding type annotations to all functions and performing comprehensive testing with mypy, improving static analysis and maintainability. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_272\n\nLANGUAGE: python\nCODE:\n```\ndef process_data(data: dict) -> list:\n    # ... implementation ... ```\n\n----------------------------------------\n\nTITLE: Pydantic v1.0b2 API Changes\nDESCRIPTION: Details API and behavior changes introduced in Pydantic v1.0b2. This includes type checking adjustments for `StrictBool`, documentation build system migration, support for custom naming schemes in `GenericModel`, and renaming of a configuration parameter. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_256\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic API Changes (v1.0b2):\n\n- Mark `StrictBool` typecheck as `bool` to allow default values without mypy errors. - Add support for custom naming schemes for `GenericModel` subclasses. - Rename `allow_population_by_alias` to `allow_population_by_field_name`; remove related warning. ```\n\n----------------------------------------\n\nTITLE: Support arbitrary types with custom __eq__\nDESCRIPTION: Adds support for arbitrary types that define a custom `__eq__` method. Pydantic can now correctly compare and validate models containing such custom types. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_131\n\nLANGUAGE: python\nCODE:\n```\nsupport arbitrary types with custom `__eq__`, [#2483](https://github.com/pydantic/pydantic/pull/2483) by @PrettyWood\n```\n\n----------------------------------------\n\nTITLE: Pydantic Dataclass Decorator\nDESCRIPTION: The `pydantic.dataclasses.dataclass` decorator now supports built-in `dataclasses.dataclass`.",
    "chunk_length": 2381
  },
  {
    "chunk_id": 174,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_216\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\nfrom pydantic.dataclasses import dataclass\n\n# Using Pydantic's dataclass decorator which now wraps standard dataclasses\n@dataclass\nclass MyData:\n    name: str\n    value: int\n\n# This behaves like a standard dataclass but with Pydantic's validation features. # instance = MyData(name='example', value=10)\n# print(instance.name)\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic NamedTuple Validation\nDESCRIPTION: Demonstrates Pydantic's validation for `typing.NamedTuple` and `collections.namedtuple`. It shows how Pydantic creates instances of the specified namedtuple class and validates fields, including type coercion and error handling for invalid inputs. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NamedTuple\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\n\nclass Model(BaseModel):\n    p: Point\n\n\ntry:\n    Model(p=('1.3', '2'))\nexcept ValidationError as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Custom Encoding for Dotenv Files\nDESCRIPTION: Adds support for specifying custom encoding when loading configuration from `.env` files. This feature provides flexibility for projects using non-standard file encodings. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_223\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseSettings\n\nclass Settings(BaseSettings):\n    class Config:\n        env_file = '.env'\n        env_file_encoding = 'utf-8' # or 'latin-1', etc. # This allows loading .env files with specified encodings. ```\n\n----------------------------------------\n\nTITLE: Pydantic Field Customization with Field()\nDESCRIPTION: Demonstrates basic customization of Pydantic model fields using the Field() function for required fields and frozen attributes. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    name: str = Field(frozen=True)\n```\n\n----------------------------------------\n\nTITLE: Custom Validation with Annotated and AfterValidator\nDESCRIPTION: Demonstrates creating a custom validator using Pydantic's Annotated type and the `__get_pydantic_core_schema__` method.",
    "chunk_length": 2467
  },
  {
    "chunk_id": 175,
    "source": "pydantic_llms_data",
    "content": "This allows applying specific validation functions, like `str.lower`, to types within Pydantic models. It requires `pydantic` and `pydantic_core`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any, Callable\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass(frozen=True)\nclass MyAfterValidator:\n    func: Callable[[Any], Any]\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_after_validator_function(\n            self.func, handler(source_type)\n        )\n\n\nUsername = Annotated[str, MyAfterValidator(str.lower)]\n\n\nclass Model(BaseModel):\n    name: Username\n\n\nassert Model(name='ABC').name == 'abc'\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Config Options for String Handling\nDESCRIPTION: Details the `Config.anystr_lower` option and the `to_lower` kwarg for `constr` and `conbytes`. These enable automatic lowercasing of string and bytes types during validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_172\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, constr\n\nclass ModelWithLowerString(BaseModel):\n    class Config:\n        anystr_lower = True\n\n    name: str\n    code: constr(to_lower=True)\n\n# Example usage:\n# model = ModelWithLowerString(name='TesT', code='VAL')\n# print(model.name) # Output: 'test'\n# print(model.code) # Output: 'val'\n```\n\n----------------------------------------\n\nTITLE: Pydantic resolve_annotations Lenience\nDESCRIPTION: Makes the `resolve_annotations` utility more lenient by allowing it to handle cases where modules might be missing. This improves robustness when resolving type annotations in complex or incomplete environments. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_144\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic resolve_annotations Lenience:\n\n`resolve_annotations` is now more lenient, allowing for missing modules during annotation resolution.",
    "chunk_length": 2211
  },
  {
    "chunk_id": 176,
    "source": "pydantic_llms_data",
    "content": "```\n\n----------------------------------------\n\nTITLE: Pydantic Model with Custom Field Serializer\nDESCRIPTION: Demonstrates defining a Pydantic `BaseModel` with a boolean field and a custom serializer using the `@field_serializer` decorator. This custom logic is then incorporated into the model's core schema for serialization. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\nfrom pydantic.functional_serializers import field_serializer\n\n\nclass Model(BaseModel):\n    foo: bool = Field(strict=True)\n\n    @field_serializer('foo', mode='plain')\n    def serialize_foo(self, value: bool) -> int:\n        # Example serialization logic\n        return int(value) # Convert boolean to integer\n```\n\n----------------------------------------\n\nTITLE: Pydantic Error Model with Nested Details\nDESCRIPTION: Demonstrates creating a Pydantic model with nested details and serializing it using `model_dump()`. Shows how missing fields in nested models are handled during serialization. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\nclass Error(BaseModel):\n    message: str\n    details: ErrorDetails\n\nerror = Error(\n    message='We just had an error',\n    details=ErrorDetails(foo='var'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring JsonSchemaMode for Validation and Serialization\nDESCRIPTION: Illustrates how to configure the JSON schema generation mode using the `mode` parameter in `model_json_schema` and `TypeAdapter.json_schema`. It shows the difference between 'validation' mode (default) and 'serialization' mode for a Decimal field. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: Decimal = Decimal('12.34')\n\n\nprint(Model.model_json_schema(mode='validation'))\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: Decimal = Decimal('12.34')\n\n\nprint(Model.model_json_schema(mode='serialization'))\n```\n\n----------------------------------------\n\nTITLE: Pydantic Union Validation Errors Comparison\nDESCRIPTION: Illustrates the verbosity of validation errors with standard Unions in Pydantic, especially with recursion, and highlights how discriminated unions simplify these messages by only showing errors for the matching discriminator case.",
    "chunk_length": 2775
  },
  {
    "chunk_id": 177,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError\n\n\n# Errors are quite verbose with a normal Union:\nclass Model(BaseModel):\n    x: Union[str, 'Model']\n\n\ntry:\n    Model.model_validate({'x': {'x': {'x': 1}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    4 validation errors for Model\n    x.str\n      Input should be a valid string [type=string_type, input_value={'x': {'x': 1}}, input_type=dict]\n    x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={'x': 1}, input_type=dict]\n    x.Model.x.Model.x.str\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    x.Model.x.Model.x.Model\n      Input should be a valid dictionary or instance of Model [type=model_type, input_value=1, input_type=int]\n    \"\"\"\n\ntry:\n    Model.model_validate({'x': {'x': {'x': {}}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    4 validation errors for Model\n    x.str\n      Input should be a valid string [type=string_type, input_value={'x': {'x': {}}}, input_type=dict]\n    x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={'x': {}}, input_type=dict]\n    x.Model.x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={}, input_type=dict]\n    x.Model.x.Model.x.Model.x\n      Field required [type=missing, input_value={}, input_type=dict]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Class Not Fully Defined: Using model_rebuild\nDESCRIPTION: Shows the correct way to resolve 'class-not-fully-defined' errors for BaseModel subclasses by defining all types and then calling `.model_rebuild()` to update the model's internal structure. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: Optional['Bar'] = None\n\n\nclass Bar(BaseModel):\n    b: 'Foo'\n\n\nFoo.model_rebuild()\n\nfoo = Foo(a={'b': {'a': None}})\n```\n\n----------------------------------------\n\nTITLE: Pydantic ValidationError and ErrorDetails\nDESCRIPTION: API documentation for Pydantic's ValidationError object and its associated ErrorDetails structure, outlining methods for error retrieval and properties for detailed error information.",
    "chunk_length": 2462
  },
  {
    "chunk_id": 178,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/errors.md#_snippet_1\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydanticValidationError:\n  Methods:\n    errors() -> list[ErrorDetails]\n      - Returns a list of ErrorDetails objects representing all validation errors found. error_count() -> int\n      - Returns the total number of validation errors. json() -> str\n      - Returns a JSON string representation of the list of errors. str(e) -> str\n      - Returns a human-readable string representation of the validation errors. ErrorDetails:\n  Properties:\n    ctx: object | None\n      - An optional object containing values required to render the error message. input: Any\n      - The input data that caused the validation error. loc: list[str | int]\n      - The location of the error within the data structure, as a list of keys or indices. msg: str\n      - A human-readable explanation of the validation error. type: str\n      - A computer-readable identifier for the type of validation error. url: str | None\n      - A URL pointing to documentation for this specific error type. Note:\n  Validation code should raise ValueError or AssertionError, which Pydantic catches and converts into ValidationError. ```\n\n----------------------------------------\n\nTITLE: Pydantic Self-Referencing Models\nDESCRIPTION: Illustrates how Pydantic supports models with self-referencing fields, using string annotations to resolve types within the model itself. This is useful for creating linked data structures. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/forward_annotations.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    sibling: 'Optional[Foo]' = None\n\n\nprint(Foo())\n#> a=123 sibling=None\nprint(Foo(sibling={'a': '321'}))\n#> a=123 sibling=Foo(a=321, sibling=None)\n```\n\n----------------------------------------\n\nTITLE: PostgresDsn Multi-Host Validation\nDESCRIPTION: Enhances the `PostgresDsn` type to support validation of connection strings with multiple hosts, improving flexibility for PostgreSQL deployments.",
    "chunk_length": 2125
  },
  {
    "chunk_id": 179,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_103\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\nfrom pydantic.networks import PostgresDsn\n\nclass DBConfigMultiHost(BaseModel):\n    # Supports connection strings like: postgresql://user:pass@host1:port,host2:port/dbname\n    db_connection: PostgresDsn\n\n# Example:\n# config = DBConfigMultiHost(db_connection='postgresql://user:pass@host1:5432,host2:5432/mydatabase')\n# This allows Pydantic to parse and validate multi-host PostgreSQL URLs. ```\n\n----------------------------------------\n\nTITLE: Python Postponed Annotation Evaluation\nDESCRIPTION: Illustrates the use of `from __future__ import annotations` to enable postponed evaluation of type hints in Python. This feature stringifies annotations by default, allowing them to be resolved later, as shown with Pydantic's `BaseModel`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    f: MyType\n    # Given the future import above, this is equivalent to:\n    # f: 'MyType'\n\n\ntype MyType = int\n\nprint(Foo.__annotations__)\n#> {'f': 'MyType'}\n```\n\n----------------------------------------\n\nTITLE: Pydantic Validation by Alias and Name (`by_alias=True`, `by_name=True`)\nDESCRIPTION: Shows how to enable validation using both aliases and original field names. Pydantic prioritizes aliases when both `by_alias` and `by_name` are `True`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n\nm = Model.model_validate(\n    {'my_alias': 'foo'},\n    by_alias=True,\n    by_name=True\n)\nprint(repr(m))\n#> Model(my_field='foo')\n\nm = Model.model_validate(\n    {'my_field': 'foo'},\n    by_alias=True,\n    by_name=True\n)\nprint(repr(m))\n#> Model(my_field='foo')\n```\n\n----------------------------------------\n\nTITLE: Mypy Plugin: Default/Default Factory Checks\nDESCRIPTION: Adds checks within the Pydantic MyPy plugin for `default` and `default_factory` arguments, improving type safety and catching potential issues early.",
    "chunk_length": 2305
  },
  {
    "chunk_id": 180,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_100\n\nLANGUAGE: python\nCODE:\n```\n# This enhancement to the MyPy plugin helps catch type errors related to default values\n# in Pydantic models, making static analysis more effective. ```\n\n----------------------------------------\n\nTITLE: Pydantic: RedisDsn Protocol Support (rediss)\nDESCRIPTION: Extends `RedisDsn` to support the `rediss` protocol (Redis over SSL) and allows URLs without a user part. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_182\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, RedisDsn\n\nclass RedisConfig(BaseModel):\n    redis_url: RedisDsn\n\n# Example usage:\n# valid_url_ssl = RedisConfig(redis_url='rediss://user:password@host:6379/db')\n# valid_url_no_user = RedisConfig(redis_url='rediss://localhost:6379')\n# print(valid_url_ssl.redis_url)\n# print(valid_url_no_user.redis_url)\n```\n\n----------------------------------------\n\nTITLE: Default Factory Singleton Behavior\nDESCRIPTION: Refines the behavior of `default_factory` to call the factory function only once when possible and to avoid setting a default value in the schema if the factory is used. This prevents unexpected side effects and ensures correct singleton instantiation. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_229\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\nfrom typing import List\n\nclass MyModel(BaseModel):\n    items: List[int] = Field(default_factory=list)\n\n# With the fix, if default_factory is a singleton or a factory that should only be called once,\n# Pydantic handles it more predictably. ```\n\n----------------------------------------\n\nTITLE: Pydantic BaseModel Equality Changes\nDESCRIPTION: Details the updated equality comparison rules for Pydantic BaseModel instances in V2. Models are now strictly compared based on type, field values, extra values, and private attributes, disallowing comparison with dictionaries. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_11\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic BaseModel Equality Rules (V2):\n\nModels can only be equal to other `BaseModel` instances.",
    "chunk_length": 2188
  },
  {
    "chunk_id": 181,
    "source": "pydantic_llms_data",
    "content": "For two model instances to be equal, they must have the same:\n\n1. **Type**: Must be the same class or, for generic models, the same non-parametrized generic origin type. 2. **Field Values**: All defined fields must have identical values. 3. **Extra Values**: If `model_config['extra'] == 'allow'`, extra fields must match. 4. **Private Attribute Values**: Models with different private attribute values are no longer considered equal. Key Changes from V1:\n- Models are no longer equal to dictionaries containing their data. - Non-generic models of different types are never equal. - Generic models with different origin types are never equal (e.g., `MyGenericModel[Any]` vs. `MyGenericModel[int]`). Example Scenario:\n```python\nfrom pydantic import BaseModel\n\nclass UserV1(BaseModel):\n    id: int\n\nclass UserV2(BaseModel):\n    id: int\n\nuser1 = UserV2(id=1)\nuser2 = UserV2(id=1)\nuser3 = UserV1(id=1)\nuser_dict = {'id': 1}\n\n# V2 Behavior:\nprint(user1 == user2)  # True\nprint(user1 == user3)  # False (different types)\nprint(user1 == user_dict) # False (cannot compare model to dict)\n```\n```\n\n----------------------------------------\n\nTITLE: Pydantic Callable Field Validation\nDESCRIPTION: Shows how to define a Pydantic `BaseModel` with a `Callable` field and validates an instance with a lambda function. Notes that only callability is checked, not argument/return types. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_20\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import Callable\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    callback: Callable[[int], int]\n\n\nm = Foo(callback=lambda x: x)\nprint(m)\n#> callback=<function <lambda> at 0x0123456789ab>\n\n!!! warning\n    Callable fields only perform a simple check that the argument is\n    callable; no validation of arguments, their types, or the return\n    type is performed. ```\n\n----------------------------------------\n\nTITLE: Pydantic Field Customization with Ellipsis\nDESCRIPTION: Shows how to use the ellipsis (...) with Field() to explicitly mark a field as required, even when a value is assigned.",
    "chunk_length": 2113
  },
  {
    "chunk_id": 182,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Model(BaseModel):\n    name: str = Field(..., frozen=True)\n```\n\n----------------------------------------\n\nTITLE: Pydantic TypeAdapter for Union Validation\nDESCRIPTION: Shows how to use Pydantic's TypeAdapter for validating data against a union type, offering an alternative to inheriting from BaseModel when only validation is needed. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Field, TypeAdapter\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['black']\n    black_name: str\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['white']\n    white_name: str\n\n\nCat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n\ntype_adapter = TypeAdapter(Pet)\n\npet = type_adapter.validate_python(\n    {'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}\n)\nprint(repr(pet))\n#> BlackCat(pet_type='cat', color='black', black_name='felix')\n\n```\n\n----------------------------------------\n\nTITLE: Field Inclusion and Exclusion via Serialization Parameters\nDESCRIPTION: Demonstrates excluding and including specific fields during Pydantic model serialization using the `exclude` and `include` parameters in serialization methods like `model_dump()`. This allows for dynamic control over the serialized output. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    password: SecretStr\n\n\nclass Transaction(BaseModel):\n    id: str\n    private_id: str = Field(exclude=True)\n    user: User\n    value: int\n\nt = Transaction(\n    id='1234567890',\n    private_id='123',\n    user=User(id=42, username='JohnDoe', password='hashedpassword'),\n    value=9876543210,\n)\n\n# using a set:\nprint(t.model_dump(exclude={'user', 'value'}))\n\n# using a dictionary:\nprint(t.model_dump(exclude={'user': {'username', 'password'}, 'value': True}))\n```\n\n----------------------------------------\n\nTITLE: Pydantic Numeric Constraints JSON Schema\nDESCRIPTION: Shows the JSON Schema generated from Pydantic models with numeric constraints, mapping Pydantic arguments to JSON Schema keywords.",
    "chunk_length": 2598
  },
  {
    "chunk_id": 183,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"title\": \"Foo\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"positive\": {\n      \"title\": \"Positive\",\n      \"type\": \"integer\",\n      \"exclusiveMinimum\": 0\n    },\n    \"non_negative\": {\n      \"title\": \"Non Negative\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"negative\": {\n      \"title\": \"Negative\",\n      \"type\": \"integer\",\n      \"exclusiveMaximum\": 0\n    },\n    \"non_positive\": {\n      \"title\": \"Non Positive\",\n      \"type\": \"integer\",\n      \"maximum\": 0\n    },\n    \"even\": {\n      \"title\": \"Even\",\n      \"type\": \"integer\",\n      \"multipleOf\": 2\n    },\n    \"love_for_pydantic\": {\n      \"title\": \"Love For Pydantic\",\n      \"type\": \"number\"\n    }\n  },\n  \"required\": [\n    \"positive\",\n    \"non_negative\",\n    \"negative\",\n    \"non_positive\",\n    \"even\",\n    \"love_for_pydantic\"\n  ]\n}\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Wrap Serializer - Decorator\nDESCRIPTION: Demonstrates using the @field_serializer decorator with mode='wrap' to customize serialization. This approach includes a 'handler' parameter to integrate with Pydantic's default serialization process. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, SerializerFunctionWrapHandler, field_serializer\n\n\nclass Model(BaseModel):\n    number: int\n\n    @field_serializer('number', mode='wrap')\n    def ser_number(\n        self, value: Any, handler: SerializerFunctionWrapHandler\n    ) -> int:\n        return handler(value) + 1\n\n\nprint(Model(number=4).model_dump())\n#> {'number': 5}\n```\n\n----------------------------------------\n\nTITLE: Pydantic root_validator Error Handling\nDESCRIPTION: Raises a user-friendly `TypeError` when a `root_validator` fails to return a dictionary (e.g., returns `None`). This improves debugging by providing clearer error messages for validator misconfigurations. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_154\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic root_validator Error Handling:\n\nRaises a user-friendly `TypeError` if a `root_validator` does not return a `dict` (e.g., returns `None`).",
    "chunk_length": 2286
  },
  {
    "chunk_id": 184,
    "source": "pydantic_llms_data",
    "content": "```\n\n----------------------------------------\n\nTITLE: Validating Partial JSON with Pydantic Models\nDESCRIPTION: Combines `pydantic_core.from_json` with `BaseModel.model_validate` to parse and validate incomplete JSON data against a Pydantic model. This approach is useful for handling LLM outputs or other sources of potentially malformed JSON. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import from_json\nfrom pydantic import BaseModel\n\nclass Dog(BaseModel):\n    breed: str\n    name: str\n    friends: list\n\npartial_dog_json = '{\"breed\": \"lab\", \"name\": \"fluffy\", \"friends\": [\"buddy\", \"spot\", \"rufus\"], \"age'\n\ndog = Dog.model_validate(from_json(partial_dog_json, allow_partial=True))\nprint(repr(dog))\n#> Dog(breed='lab', name='fluffy', friends=['buddy', 'spot', 'rufus'])\n```\n\n----------------------------------------\n\nTITLE: Pydantic V2 Float to Integer Conversion\nDESCRIPTION: Details Pydantic V2's stricter float-to-integer conversion, allowing it only if the float has no fractional part. This prevents potential data loss that could occur in Pydantic V1 where any float was accepted for an `int` field. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\n# Valid conversion: float with zero decimal part\nprint(Model(x=10.0))\n# Expected output: x=10\n\ntry:\n    # Invalid conversion: float with non-zero decimal part\n    Model(x=10.2)\nexcept ValidationError as err:\n    print(err)\n    # Output will show validation error:\n    # 1 validation error for Model\n    # x\n    #   Input should be a valid integer, got a number with a fractional part [type=int_from_float, input_value=10.2, input_type=float]\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Allow Extra Data\nDESCRIPTION: Configures Pydantic models to allow extra data, storing it in the `__pydantic_extra__` attribute. This is controlled via the `extra` setting in `ConfigDict`.",
    "chunk_length": 2091
  },
  {
    "chunk_id": 185,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\nm = Model(x=1, y='a')  # (1)! assert m.model_dump() == {'x': 1, 'y': 'a'}\nassert m.__pydantic_extra__ == {'y': 'a'}\n```\n\n----------------------------------------\n\nTITLE: AfterValidator Annotated Pattern (Check)\nDESCRIPTION: Demonstrates using `AfterValidator` with the annotated pattern to check if an integer is even. Raises `ValueError` if the condition is not met. Requires `typing.Annotated` and `pydantic.AfterValidator`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel, ValidationError\n\n\ndef is_even(value: int) -> int:\n    if value % 2 == 1:\n        raise ValueError(f'{value} is not an even number')\n    return value  # (1)! class Model(BaseModel):\n    number: Annotated[int, AfterValidator(is_even)]\n\n\ntry:\n    Model(number=1)\nexcept ValidationError as err:\n    print(err)\n    \n```\n\n----------------------------------------\n\nTITLE: Pydantic Model `.dict()` and `.json()` Behavior\nDESCRIPTION: Addresses an issue where internal `__root__` dictionaries were not properly squashed in the `.dict()` and `.json()` methods. This change ensures consistent output for models utilizing `__root__`. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_240\n\nLANGUAGE: python\nCODE:\n```\nSquash internal `__root__` dicts in `.dict()` and `.json()`\nRelated Issue: [#1414](https://github.com/pydantic/pydantic/pull/1414)\n```\n\n----------------------------------------\n\nTITLE: Define and Validate Pydantic Forward Reference\nDESCRIPTION: This Python snippet defines 'MyInt' as an integer type, acting as a forward reference. It then rebuilds a Pydantic type adapter ('ta') to incorporate this new definition and validates an integer value against it, asserting the successful validation.",
    "chunk_length": 2097
  },
  {
    "chunk_id": 186,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/type_adapter.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# some time later, the forward reference is defined\nMyInt = int\n\nta.rebuild()\nassert ta.validate_python(1) == 1\n```\n\n----------------------------------------\n\nTITLE: Decorator Pattern for Field Serialization\nDESCRIPTION: Illustrates using the @field_serializer decorator to apply a serialization function to multiple fields. It covers options like applying to all fields ('*') and disabling field existence checks. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, field_serializer\n\n\nclass Model(BaseModel):\n    f1: str\n    f2: str\n\n    @field_serializer('f1', 'f2', mode='plain')\n    def capitalize(self, value: str) -> str:\n        return value.capitalize()\n```\n\n----------------------------------------\n\nTITLE: Pydantic Wrap Validator for Datetime Field\nDESCRIPTION: Illustrates customizing validation for a datetime field using a wrap validator in Pydantic V2. It shows how to handle a 'now' string input and ensure timezone awareness for naive datetimes by attaching UTC timezone. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime, timezone\nfrom typing import Any\n\nfrom pydantic_core.core_schema import ValidatorFunctionWrapHandler\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Meeting(BaseModel):\n    when: datetime\n\n    @field_validator('when', mode='wrap')\n    def when_now(\n        cls, input_value: Any, handler: ValidatorFunctionWrapHandler\n    ) -> datetime:\n        if input_value == 'now':\n            return datetime.now()\n        when = handler(input_value)\n        # in this specific application we know tz naive datetimes are in UTC\n        if when.tzinfo is None:\n            when = when.replace(tzinfo=timezone.utc)\n        return when\n\n\nprint(Meeting(when='2020-01-01T12:00+01:00'))\n#> when=datetime.datetime(2020, 1, 1, 12, 0, tzinfo=TzInfo(3600))\nprint(Meeting(when='now'))\n#> when=datetime.datetime(2032, 1, 2, 3, 4, 5, 6) # Example output, actual time will vary\nprint(Meeting(when='2020-01-01T12:00'))\n#> when=datetime.datetime(2020, 1, 1, 12, 0, tzinfo=datetime.timezone.utc)\n\n```\n\n----------------------------------------\n\nTITLE: Class Not Fully Defined: ForwardRef\nDESCRIPTION: Demonstrates the 'class-not-fully-defined' error when a type annotation uses ForwardRef to a class that is not yet defined.",
    "chunk_length": 2558
  },
  {
    "chunk_id": 187,
    "source": "pydantic_llms_data",
    "content": "It shows how to catch the PydanticUserError. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ForwardRef\n\nfrom pydantic import BaseModel, PydanticUserError\n\nUndefinedType = ForwardRef('UndefinedType')\n\n\nclass Foobar(BaseModel):\n    a: UndefinedType\n\n\ntry:\n    Foobar(a=1)\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'class-not-fully-defined'\n```\n\n----------------------------------------\n\nTITLE: Pydantic AliasChoices for Multiple Field Aliases\nDESCRIPTION: Illustrates using AliasChoices to define multiple possible aliases for a single field, allowing flexibility during data validation. Shows validation with different alias combinations. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, AliasChoices\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasChoices('first_name', 'fname'))\n    last_name: str = Field(validation_alias=AliasChoices('last_name', 'lname'))\n\nuser = User.model_validate({'fname': 'John', 'lname': 'Doe'})  # (1)! print(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'first_name': 'John', 'lname': 'Doe'})  # (2)! print(user)\n#> first_name='John' last_name='Doe'\n```\n\n----------------------------------------\n\nTITLE: Pydantic v0.30.1: Nested Class Initialization Fix\nDESCRIPTION: Addresses an issue where nested classes inheriting from a parent and modifying `__init__` were not correctly processed, while still allowing `self` as a parameter. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_264\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic v0.30.1 Release Notes:\n\n- Fix processing of nested classes that inherit and change `__init__`. - Ensures correct processing while allowing `self` as a parameter. - Related to issue [#644](https://github.com/pydantic/pydantic/pull/644). - Contributed by @lnaden and @dgasmith. ```\n\n----------------------------------------\n\nTITLE: Pydantic: Rebuild Model Schema with Forward Annotations\nDESCRIPTION: Demonstrates how to use `model_rebuild()` to resolve forward references in model definitions, especially when a type is used before it's defined.",
    "chunk_length": 2297
  },
  {
    "chunk_id": 188,
    "source": "pydantic_llms_data",
    "content": "This is crucial for complex or recursive structures. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    x: 'Bar'  # (1)! try:\n    Foo.model_json_schema()\nexcept PydanticUserError as e:\n    print(e)\n    \"\"\"\n    `Foo` is not fully defined; you should define `Bar`, then call `Foo.model_rebuild()`. For further information visit https://errors.pydantic.dev/2/u/class-not-fully-defined\n    \"\"\"\n\n\nclass Bar(BaseModel):\n    pass\n\n\nFoo.model_rebuild()\nprint(Foo.model_json_schema())\n\"\"\"\n{\n    '$defs': {'Bar': {'properties': {}, 'title': 'Bar', 'type': 'object'}},\n    'properties': {'x': {'$ref': '#/$defs/Bar'}},\n    'required': ['x'],\n    'title': 'Foo',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Pydantic v1.0b2 Feature Additions\nDESCRIPTION: Details new features introduced in Pydantic v1.0b2. This includes support for custom naming schemes for `GenericModel` subclasses and improvements to type checking for `StrictBool`. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_260\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Feature Additions (v1.0b2):\n\n- Add support for custom naming schemes for `GenericModel` subclasses. - Mark `StrictBool` typecheck as `bool` to allow for default values without mypy errors. ```\n\n----------------------------------------\n\nTITLE: Validate TOML Data with Pydantic in Python\nDESCRIPTION: Validates data from a TOML file using Pydantic. It uses the `tomllib` module (standard library in Python 3.11+) to load TOML data and then validates it against a Pydantic model. Requires the `pydantic` library. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport tomllib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.toml', 'rb') as f:\n    data = tomllib.load(f)\n\nperson = Person.model_validate(data)\nprint(person)\n#> name='John Doe' age=30 email='john@example.com'\n```\n\n----------------------------------------\n\nTITLE: Validate Incomplete Python Object with Partial Validation\nDESCRIPTION: Shows that partial validation also works with Python objects, mirroring the behavior of JSON validation.",
    "chunk_length": 2401
  },
  {
    "chunk_id": 189,
    "source": "pydantic_llms_data",
    "content": "Incomplete or invalid Python data is handled gracefully, omitting problematic parts. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict):\n    a: int\n    b: NotRequired[float]\n    c: NotRequired[Annotated[str, MinLen(5)]]\n\n\nta = TypeAdapter(list[Foobar])\n\nv = ta.validate_python([{'a': 1}], experimental_allow_partial=True)\nprint(v)\n#> [{'a': 1}]\n```\n\n----------------------------------------\n\nTITLE: Python: Data Loss with Unparametrized Generics\nDESCRIPTION: Illustrates potential data loss when using unparametrized generic models with specific subtypes, contrasting explicit parametrization. Shows how validation against an upper bound without explicit parametrization can lose specific type information. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nItemT = TypeVar('ItemT', bound='ItemBase')\n\n\nclass ItemBase(BaseModel):\n    pass\n\n\nclass IntItem(ItemBase):\n    value: int\n\n\nclass ItemHolder(BaseModel, Generic[ItemT]):\n    item: ItemT\n\n\nloaded_data = {'item': {'value': 1}}\n\n\nprint(ItemHolder(**loaded_data))\n\nprint(ItemHolder[IntItem](**loaded_data))\n```\n\n----------------------------------------\n\nTITLE: Strict Mode for Dataclasses and TypedDict\nDESCRIPTION: Explains how to apply strict mode to Pydantic dataclasses using the `config` argument in the `@dataclass` decorator. For vanilla dataclasses or `TypedDict` subclasses, strict mode can be enabled by annotating fields with `pydantic.types.Strict` or by setting the `__pydantic_config__` attribute. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter, ValidationError\n\n\nclass Inner(TypedDict):\n    y: int\n\n\nInner.__pydantic_config__ = ConfigDict(strict=True)\n\n\nclass Outer(TypedDict):\n    x: int\n    inner: Inner\n\n\nadapter = TypeAdapter(Outer)\nprint(adapter.validate_python({'x': '1', 'inner': {'y': 2}}))\n\ntry:\n    adapter.validate_python({'x': '1', 'inner': {'y': '2'}})\nexcept ValidationError as exc:\n    print(exc)\n    \n```\n\n----------------------------------------\n\nTITLE: Model Rebuild After Defining Forward Reference\nDESCRIPTION: Shows how to resolve a forward reference by defining the type (e.g., `type MyType = int`) and then calling `Foo.model_rebuild()`.",
    "chunk_length": 2680
  },
  {
    "chunk_id": 190,
    "source": "pydantic_llms_data",
    "content": "After rebuilding, `__pydantic_core_schema__` is correctly generated, reflecting the resolved type. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ntype MyType = int\n\nFoo.model_rebuild()\nFoo.__pydantic_core_schema__\n```\n\n----------------------------------------\n\nTITLE: Marking Fields as Deprecated\nDESCRIPTION: Shows how to use the `deprecated` parameter with a string message to mark Pydantic fields as deprecated. This generates a runtime deprecation warning upon access and sets the `deprecated` keyword in the JSON schema. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, Field(deprecated='This is deprecated')]\n\n\nprint(Model.model_json_schema()['properties']['deprecated_field'])\n#> {'deprecated': True, 'title': 'Deprecated Field', 'type': 'integer'}\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Validate arguments with validate_arguments\nDESCRIPTION: Shows how to use the `validate_arguments` decorator to automatically validate function parameters. It also highlights the addition of a `validate` method for pre-call validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_170\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import validate_arguments\n\n@validate_arguments\ndef process_data(data: dict, count: int = 1):\n    \"\"\"Processes data with validated arguments.\"\"\"\n    print(f\"Processing {count} items.\")\n    # ... processing logic ... # Example of using the bound validate method:\n# validator = process_data.validate(data={'key': 'value'}, count=5)\n# validator.execute() # This would call the actual function\n```\n\n----------------------------------------\n\nTITLE: Pydantic v1.0 Feature Additions\nDESCRIPTION: Details new features and enhancements added in Pydantic v1.0. This includes improved handling of `**kwargs` in metaclasses, better `Field` constraint support for complex types, and enhanced `BaseSettings` merging capabilities.",
    "chunk_length": 2178
  },
  {
    "chunk_id": 191,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_259\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Feature Additions (v1.0):\n\n- Add `**kwargs` to `pydantic.main.ModelMetaclass.__new__` for `__init_subclass__`. - Improve use of `Field` constraints on complex types, support `Tuple[X, ...]`, `Sequence`, `FrozenSet` in schema. - For `BaseSettings`, merge environment variables and in-code values recursively as long as they create a valid object when merged. ```\n\n----------------------------------------\n\nTITLE: Pydantic ConfigDict ser_json_inf_nan\nDESCRIPTION: Introduces a new configuration option `ser_json_inf_nan` for `ConfigDict` in Pydantic. This setting controls how infinity and NaN values are serialized to JSON. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nAdd ConfigDict.ser_json_inf_nan by @davidhewitt in [#8159](https://github.com/pydantic/pydantic/pull/8159)\n```\n\n----------------------------------------\n\nTITLE: Pydantic Parsing Helper Functions\nDESCRIPTION: Introduced in v0.4.0, these functions provide convenient ways to parse data into Pydantic models from different sources. They handle data conversion and validation according to the model's schema. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_307\n\nLANGUAGE: APIDOC\nCODE:\n```\nparse_obj(obj: Any)\n  Parses data from a Python object (e.g., dict) into a Pydantic model. Parameters:\n    obj: The Python object containing the data to parse. Returns: An instance of the Pydantic model. parse_raw(b: bytes | str, content_type: str | None = None, encoding: str | None = None)\n  Parses data from raw bytes or string, inferring content type if not provided. Parameters:\n    b: The raw bytes or string data. content_type: The content type of the data (e.g., 'application/json'). encoding: The encoding of the data. Returns: An instance of the Pydantic model. parse_file(path: str | Path, content_type: str | None = None, encoding: str | None = None)\n  Parses data from a file path, reading the file content and validating it.",
    "chunk_length": 2095
  },
  {
    "chunk_id": 192,
    "source": "pydantic_llms_data",
    "content": "Parameters:\n    path: The file path to read data from. content_type: The content type of the file. encoding: The encoding of the file. Returns: An instance of the Pydantic model. ```\n\n----------------------------------------\n\nTITLE: Support kw_only in Dataclasses\nDESCRIPTION: Adds support for the `kw_only` (keyword-only) argument in Pydantic's integration with Python dataclasses, allowing for more explicit argument passing. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_96\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom pydantic import dataclasses\n\n@dataclasses.dataclass(kw_only=True)\nclass KeywordOnlyData:\n    name: str\n    value: int\n\n# Usage:\n# instance = KeywordOnlyData(name='test', value=10) # Valid\n# instance_invalid = KeywordOnlyData('test', 10) # Raises TypeError\n```\n\n----------------------------------------\n\nTITLE: Custom Environment Variable Parsing\nDESCRIPTION: Introduces the ability to customize the parsing of environment variables through the `parse_env_var` setting within the `Config` class. This allows for more flexible handling of environment variable inputs. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_70\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass Settings(BaseModel):\n    class Config:\n        @classmethod\n        def parse_env_var(cls, field_name: str, value: str) -> object:\n            # Custom parsing logic here\n            if field_name == 'my_custom_field':\n                return int(value) * 2\n            return value\n\n    my_custom_field: int\n\n```\n\n----------------------------------------\n\nTITLE: Fix Schema from ConstrainedStr with regex\nDESCRIPTION: Fixes an issue where creating a schema from a model using `ConstrainedStr` with a regex pattern as a dictionary key would fail. This ensures correct schema generation for such cases. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_56\n\nLANGUAGE: python\nCODE:\n```\n# Fix creating schema from model using `ConstrainedStr` with `regex` as dict key, [#5223](https://github.com/pydantic/pydantic/pull/5223) by @matejetz\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Support for Plain typing.Tuple\nDESCRIPTION: Enables the use of `typing.Tuple` without specifying element types, which is useful for tuples of mixed types where the exact sequence is not critical or is handled dynamically.",
    "chunk_length": 2433
  },
  {
    "chunk_id": 193,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_173\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Tuple\nfrom pydantic import BaseModel\n\nclass ModelWithTuple(BaseModel):\n    data: Tuple\n\n# Example usage:\n# model = ModelWithTuple(data=(1, 'hello', True))\n# print(model.data) # Output: (1, 'hello', True)\n```\n\n----------------------------------------\n\nTITLE: MyPy Plugin: Prevent __init__ Override\nDESCRIPTION: Fixes the Pydantic MyPy plugin to avoid overriding pre-existing `__init__` methods in models, ensuring custom initializers are preserved. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_92\n\nLANGUAGE: python\nCODE:\n```\n# This is a fix for the Pydantic MyPy plugin. # It ensures that if a user defines a custom __init__ method,\n# the plugin does not interfere with it. ```\n\n----------------------------------------\n\nTITLE: Pydantic: Both validate_by_alias and validate_by_name False\nDESCRIPTION: Explains the Pydantic error raised when both `validate_by_alias` and `validate_by_name` are set to `False` in `ConfigDict`. This configuration is prohibited as it prevents attribute population. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        a: int = Field(alias='A')\n\n        model_config = ConfigDict(\n            validate_by_alias=False, validate_by_name=False\n        )\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-by-alias-and-name-false'\n```\n\n----------------------------------------\n\nTITLE: Pydantic BaseModel.construct() Field Order\nDESCRIPTION: Ensures that the order of fields is preserved when creating models using `BaseModel.construct()`. This is important for maintaining predictable field ordering, especially in scenarios where order matters. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_148\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic BaseModel.construct() Field Order:\n\nPreserves the order of fields when using `BaseModel.construct()`.",
    "chunk_length": 2151
  },
  {
    "chunk_id": 194,
    "source": "pydantic_llms_data",
    "content": "```\n\n----------------------------------------\n\nTITLE: Pydantic Validation Concept\nDESCRIPTION: Pydantic uses the term 'validation' to describe the process of instantiating a model or type that adheres to specified types and constraints. This process guarantees the types and constraints of the output, not the input data, and may involve parsing, coercion, and copying data without mutating the original input. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_1\n\nLANGUAGE: APIDOC\nCODE:\n```\nValidation — a *deliberate* misnomer\n\nTL;DR\nWe use the term \"validation\" to refer to the process of instantiating a model (or other type) that adheres to specified types and constraints. This task, which Pydantic is well known for, is most widely recognized as \"validation\" in colloquial terms, even though in other contexts the term \"validation\" may be more restrictive. --- \n\nThe long version\nThe potential confusion around the term \"validation\" arises from the fact that, strictly speaking, Pydantic's primary focus doesn't align precisely with the dictionary definition of \"validation\":\n\n> validation\n> _noun_\n> the action of checking or proving the validity or accuracy of something. In Pydantic, the term \"validation\" refers to the process of instantiating a model (or other type) that adheres to specified types and constraints. Pydantic guarantees the types and constraints of the output, not the input data. This distinction becomes apparent when considering that Pydantic's `ValidationError` is raised when data cannot be successfully parsed into a model instance. While this distinction may initially seem subtle, it holds practical significance. In some cases, \"validation\" goes beyond just model creation, and can include the copying and coercion of data. This can involve copying arguments passed to the constructor in order to perform coercion to a new type without mutating the original input data. For a more in-depth understanding of the implications for your usage, refer to the [Data Conversion](#data-conversion) and [Attribute Copies](#attribute-copies) sections below.",
    "chunk_length": 2120
  },
  {
    "chunk_id": 195,
    "source": "pydantic_llms_data",
    "content": "In essence, Pydantic's primary goal is to assure that the resulting structure post-processing (termed \"validation\") precisely conforms to the applied type hints. Given the widespread adoption of \"validation\" as the colloquial term for this process, we will consistently use it in our documentation. While the terms \"parse\" and \"validation\" were previously used interchangeably, moving forward, we aim to exclusively employ \"validate\", with \"parse\" reserved specifically for discussions related to [JSON parsing](../concepts/json.md). ```\n\n----------------------------------------\n\nTITLE: Pydantic: Custom Datetime TZ Constraint Validator\nDESCRIPTION: Demonstrates creating a Pydantic validator for datetime objects using Annotated metadata and __get_pydantic_core_schema__. This validator enforces a specific timezone constraint by wrapping the default validation logic. It requires pydantic, pytz, and pydantic-core. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/custom_validators.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any, Callable, Optional\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import (\n    GetCoreSchemaHandler,\n    PydanticUserError,\n    TypeAdapter,\n    ValidationError,\n)\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    tz_constraint: Optional[str] = None\n\n    def tz_constraint_validator(\n        self,\n        value: dt.datetime,\n        handler: Callable,  # (1)! ):\n        \"\"\"Validate tz_constraint and tz_info.\"\"\"\n        # handle naive datetimes\n        if self.tz_constraint is None:\n            assert (\n                value.tzinfo is None\n            ), 'tz_constraint is None, but provided value is tz-aware.'\n            return handler(value)\n\n        # validate tz_constraint and tz-aware tzinfo\n        if self.tz_constraint not in pytz.all_timezones:\n            raise PydanticUserError(\n                f'Invalid tz_constraint: {self.tz_constraint}',\n                code='unevaluable-type-annotation',\n            )\n        result = handler(value)  # (2)!",
    "chunk_length": 2169
  },
  {
    "chunk_id": 196,
    "source": "pydantic_llms_data",
    "content": "assert self.tz_constraint == str(\n            result.tzinfo\n        ), f'Invalid tzinfo: {str(result.tzinfo)}, expected: {self.tz_constraint}'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.tz_constraint_validator,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(LA)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#> 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    ta.validate_python(\n        dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n    )\nexcept ValidationError as ve:\n    pprint(ve.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Invalid tzinfo: Europe/London, expected: America/Los_Angeles')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=<DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD>),\n    'loc': (),\n    'msg': 'Assertion failed, Invalid tzinfo: Europe/London, expected: America/Los_Angeles',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: validate_call: Keyword-Only Parameters\nDESCRIPTION: Illustrates the use of `validate_call` with keyword-only parameters, which must be explicitly named when called. This ensures clarity and prevents accidental positional argument passing. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import validate_call\n\n\n@validate_call\ndef kw_only(*, a: int, b: int = 2) -> str:\n    return f'a={a} b={b}'\n\n\nprint(kw_only(a=1))\n#> a=1 b=2\nprint(kw_only(a=1, b=3))\n#> a=1 b=3\n```\n\n----------------------------------------\n\nTITLE: Define Generic Pydantic Model with Custom Schema\nDESCRIPTION: Demonstrates defining a generic class (`Owner`) and integrating it with Pydantic's core schema generation.",
    "chunk_length": 2130
  },
  {
    "chunk_id": 197,
    "source": "pydantic_llms_data",
    "content": "This allows custom validation logic for generic type arguments within Pydantic models. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import Generic, TypeVar, Any\n\nfrom pydantic_core import core_schema\nfrom pydantic import GetCoreSchemaHandler, ValidationError\nfrom pydantic.generics import GenericModel\nfrom pydantic import BaseModel\n\nItemType = TypeVar('ItemType')\n\n# This is not a pydantic model, it's an arbitrary generic class\n@dataclass\nclass Owner(Generic[ItemType]):\n    name: str\n    item: ItemType\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        origin = get_origin(source_type)\n        if origin is None:  # used as `x: Owner` without params\n            origin = source_type\n            item_tp = Any\n        else:\n            item_tp = get_args(source_type)[0]\n        \n        item_schema = handler.generate_schema(item_tp)\n\n        def val_item(v: Owner[Any], handler: core_schema.ValidatorFunctionWrapHandler) -> Owner[Any]:\n            v.item = handler(v.item)\n            return v\n\n        python_schema = core_schema.chain_schema(\n            [\n                core_schema.is_instance_schema(cls),\n                core_schema.no_info_wrap_validator_function(val_item, item_schema),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=core_schema.chain_schema(\n                [\n                    core_schema.typed_dict_schema(\n                        {\n                            'name': core_schema.typed_dict_field(\n                                core_schema.str_schema()\n                            ),\n                            'item': core_schema.typed_dict_field(item_schema),\n                        }\n                    ),\n                    core_schema.no_info_before_validator_function(\n                        lambda data: Owner(\n                            name=data['name'], item=data['item']\n                        ),\n                        python_schema,\n                    ),\n                ]\n            ),\n            python_schema=python_schema,\n        )\n\n# Helper functions for __get_pydantic_core_schema__\ndef get_origin(tp: Any) -> Any:\n    return getattr(tp, '__origin__', None)\n\ndef get_args(tp: Any) -> tuple[Any, ...]:\n    return getattr(tp, '__args__', ())\n\n```\n\n----------------------------------------\n\nTITLE: Core Schema with Custom Serialization\nDESCRIPTION: Shows a core schema definition that includes custom serialization logic for a field.",
    "chunk_length": 2664
  },
  {
    "chunk_id": 198,
    "source": "pydantic_llms_data",
    "content": "The `serialization` key specifies a function-based serializer, indicating how the Python value should be transformed during the serialization process. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n{\n    'type': 'function-plain',\n    'function': '<function Model.serialize_foo at 0x111>',\n    'is_field_serializer': True,\n    'info_arg': False,\n    'return_schema': {'type': 'int'},\n}\n```\n\n----------------------------------------\n\nTITLE: FileUrl type and host_required parameter\nDESCRIPTION: Introduces a new `FileUrl` type that conforms to RFC 8089 for file URLs. It also adds the `host_required` parameter, defaulting to `True` for `AnyUrl` and `False` for `RedisDsn` and `FileUrl`. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_122\n\nLANGUAGE: python\nCODE:\n```\nCreate `FileUrl` type that allows URLs that conform to [RFC 8089](https://tools.ietf.org/html/rfc8089#section-2). Add `host_required` parameter, which is `True` by default (`AnyUrl` and subclasses), `False` in `RedisDsn`, `FileUrl`, [#1983](https://github.com/pydantic/pydantic/pull/1983) by @vgerak\n```\n\n----------------------------------------\n\nTITLE: Validate JSON Lines Data with Pydantic\nDESCRIPTION: Demonstrates validating data from a JSON Lines (`.jsonl`) file, where each line is a separate JSON object. It reads the file line by line and validates each JSON object against a Pydantic model. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_lines = pathlib.Path('people.jsonl').read_text().splitlines()\npeople = [Person.model_validate_json(line) for line in json_lines]\nprint(people)\n#> [Person(name='John Doe', age=30, email='john@example.com'), Person(name='Jane Doe', age=25, email='jane@example.com')]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Runtime Serialization Methods API\nDESCRIPTION: API documentation for Pydantic methods that support runtime alias control during serialization.",
    "chunk_length": 2218
  },
  {
    "chunk_id": 199,
    "source": "pydantic_llms_data",
    "content": "These methods allow specifying whether to serialize using aliases via the `by_alias` flag. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_18\n\nLANGUAGE: APIDOC\nCODE:\n```\nBaseModel.model_dump(*, by_alias: bool = False, ...)\nBaseModel.model_dump_json(*, by_alias: bool = False, ...)\nTypeAdapter.dump_python(obj: Any, *, by_alias: bool = False, ...)\nTypeAdapter.dump_json(obj: Any, *, by_alias: bool = False, ...)\n\nParameters:\n  by_alias: bool (default: False) - If True, serialize using field aliases. ```\n\n----------------------------------------\n\nTITLE: Performance: Improve Model __setattr__\nDESCRIPTION: Enhances the performance of the `__setattr__` method on Pydantic models by implementing caching for setter functions, leading to faster attribute assignments. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nclass MyModel:\n    def __setattr__(self, name, value):\n        # Optimized setter logic with caching\n        super().__setattr__(name, value)\n\n# This speeds up operations involving attribute modification on model instances. ```\n\n----------------------------------------\n\nTITLE: Annotated Pattern for Field Serialization\nDESCRIPTION: Demonstrates using Annotated with PlainSerializer to apply custom serialization logic to fields. This pattern allows for reusable serializers defined directly within type annotations. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, PlainSerializer\n\nDoubleNumber = Annotated[int, PlainSerializer(lambda v: v * 2)]\n\n\nclass Model1(BaseModel):\n    my_number: DoubleNumber\n\n\nclass Model2(BaseModel):\n    other_number: Annotated[DoubleNumber, Field(description='My other number')]\n\n\nclass Model3(BaseModel):\n    list_of_even_numbers: list[DoubleNumber]  # (1)! ```\n\n----------------------------------------\n\nTITLE: Pydantic V2 Union Type Preservation\nDESCRIPTION: Demonstrates how Pydantic V2 unions preserve the input type when possible, even if it's not the first type in the union.",
    "chunk_length": 2167
  },
  {
    "chunk_id": 200,
    "source": "pydantic_llms_data",
    "content": "It contrasts this with Pydantic V1's behavior and mentions the `union_mode` setting to revert to V1's left-to-right validation. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: Union[int, str]\n\n\nprint(Model(x='1'))\n# Expected output in Pydantic V2: x='1'\n# Note: In Pydantic V1, this would output x=1. ```\n\n----------------------------------------\n\nTITLE: Custom Type: CompressedString with __get_pydantic_core_schema__\nDESCRIPTION: Demonstrates creating a custom type, CompressedString, that overrides Pydantic's schema generation using __get_pydantic_core_schema__. It includes custom validation and serialization logic for a compressed string format. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass\nclass CompressedString:\n    dictionary: dict[int, str]\n    text: list[int]\n\n    def build(self) -> str:\n        return ' '.join([self.dictionary[key] for key in self.text])\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        assert source is CompressedString\n        return core_schema.no_info_after_validator_function(\n            cls._validate,\n            core_schema.str_schema(),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                cls._serialize,\n                info_arg=False,\n                return_schema=core_schema.str_schema(),\n            ),\n        )\n\n    @staticmethod\n    def _validate(value: str) -> 'CompressedString':\n        inverse_dictionary: dict[str, int] = {}\n        text: list[int] = []\n        for word in value.split(' '):\n            if word not in inverse_dictionary:\n                inverse_dictionary[word] = len(inverse_dictionary)\n            text.append(inverse_dictionary[word])\n        return CompressedString(\n            {v: k for k, v in inverse_dictionary.items()}, text\n        )\n\n    @staticmethod\n    def _serialize(value: 'CompressedString') -> str:\n        return value.build()\n\n\nclass MyModel(BaseModel):\n    value: CompressedString\n\n\n# Example Usage:\n# print(MyModel.model_json_schema())\n# print(MyModel(value='fox fox fox dog fox'))\n# print(MyModel(value='fox fox fox dog fox').model_dump(mode='json'))\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Custom Root Type from_orm() Support\nDESCRIPTION: Adds support for custom root types (aka `__root__`) when using `from_orm()`.",
    "chunk_length": 2785
  },
  {
    "chunk_id": 201,
    "source": "pydantic_llms_data",
    "content": "This allows Pydantic models to be created from ORM objects where the root data structure is custom. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_163\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Custom Root Type from_orm() Support:\n\nSupports custom root type (`__root__`) with `from_orm()`. ```\n\n----------------------------------------\n\nTITLE: Pydantic PlainValidator with Decorator\nDESCRIPTION: Presents the decorator-based approach for `PlainValidator`. This method allows modifying input values directly and bypassing Pydantic's internal type validation, as demonstrated by doubling an integer or accepting a string input. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    number: int\n\n    @field_validator('number', mode='plain')\n    @classmethod\n    def val_number(cls, value: Any) -> Any:\n        if isinstance(value, int):\n            return value * 2\n        else:\n            return value\n\n\nprint(Model(number=4))\n#> number=8\nprint(Model(number='invalid'))  # (1)! #> number='invalid'\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic Python Version Requirement\nDESCRIPTION: Updates the `python_requires` metadata to specify a minimum requirement of Python 3.6.1. This ensures compatibility with the features and syntax used in the library. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_157\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic Python Version Requirement:\n\n`python_requires` metadata updated to require Python >= 3.6.1. ```\n\n----------------------------------------\n\nTITLE: Pydantic TypedDict Validation\nDESCRIPTION: Demonstrates validating Python dictionaries against Pydantic `TypedDict` definitions, including cases with optional fields (`total=False`) and error handling for invalid types or extra fields. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#_snippet_19\n\nLANGUAGE: Python\nCODE:\n```\nfrom typing import TypedDict, Optional\nfrom pydantic import ConfigDict, TypeAdapter, ValidationError\n\n\n# `total=False` means keys are non-required\nclass UserIdentity(TypedDict, total=False):\n    name: Optional[str]\n    surname: str\n\n\nclass User(TypedDict):\n    __pydantic_config__ = ConfigDict(extra='forbid')\n\n    identity: UserIdentity\n    age: int\n\n\nta = TypeAdapter(User)\n\nprint(\n    ta.validate_python(\n        {'identity': {'name': 'Smith', 'surname': 'John'}, 'age': 37}\n    )\n)\n#> {'identity': {'name': 'Smith', 'surname': 'John'}, 'age': 37}\n\nprint(\n    ta.validate_python(\n        {'identity': {'name': None, 'surname': 'John'}, 'age': 37}\n    )\n)\n#> {'identity': {'name': None, 'surname': 'John'}, 'age': 37}\n\nprint(ta.validate_python({'identity': {}, 'age': 37}))\n#> {'identity': {}, 'age': 37}\n\n\ntry:\n    ta.validate_python(\n        {'identity': {'name': ['Smith'], 'surname': 'John'}, 'age': 24}\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    identity.name\n      Input should be a valid string [type=string_type, input_value=['Smith'], input_type=list]\n    \"\"\"\n\ntry:\n    ta.validate_python(\n        {\n            'identity': {'name': 'Smith', 'surname': 'John'},\n            'age': '37',\n            'email': 'john.smith@me.com',\n        }\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    email\n      Extra inputs are not permitted [type=extra_forbidden, input_value='john.smith@me.com', input_type=str]\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Performance: Optimize _typing_extra Module\nDESCRIPTION: Refactors and optimizes the `_typing_extra` module, leading to performance gains in handling various typing constructs.",
    "chunk_length": 3832
  },
  {
    "chunk_id": 202,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n# Internal module optimization for enhanced performance. ```\n\n----------------------------------------\n\nTITLE: Pydantic AliasChoices with AliasPath\nDESCRIPTION: Combines AliasChoices and AliasPath to provide flexible validation paths for fields, allowing either direct aliases or nested paths. Demonstrates validation with mixed alias strategies. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, AliasPath, AliasChoices\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasChoices('first_name', AliasPath('names', 0)))\n    last_name: str = Field(validation_alias=AliasChoices('last_name', AliasPath('names', 1)))\n\n\nuser = User.model_validate({'first_name': 'John', 'last_name': 'Doe'})\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'names': ['John', 'Doe']})\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'names': ['John'], 'last_name': 'Doe'})\nprint(user)\n#> first_name='John' last_name='Doe'\n```\n\n----------------------------------------\n\nTITLE: Schema Generation for Dict, List, Tuple, Set\nDESCRIPTION: Improved schema generation for fields annotated with generic collection types like `dict`, `list`, `tuple`, and `set`, ensuring correct schema output. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_285\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\nfrom typing import List, Dict, Tuple, Set\n\nclass CollectionModel(BaseModel):\n    items_list: List[int]\n    data_dict: Dict[str, float]\n    coordinates: Tuple[int, int]\n    unique_ids: Set[str]\n```\n\n----------------------------------------\n\nTITLE: Send Validated Data to RabbitMQ Queue (Python)\nDESCRIPTION: This sender script utilizes Pydantic to define a data structure for users and serializes instances of this model into JSON. The JSON data is then published as messages to a specified RabbitMQ queue using the pika library.",
    "chunk_length": 2120
  },
  {
    "chunk_id": 203,
    "source": "pydantic_llms_data",
    "content": "SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/queues.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pika\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\nQUEUE_NAME = 'user_queue'\nchannel.queue_declare(queue=QUEUE_NAME)\n\n\ndef push_to_queue(user_data: User) -> None:\n    serialized_data = user_data.model_dump_json()\n    channel.basic_publish(\n        exchange='',\n        routing_key=QUEUE_NAME,\n        body=serialized_data,\n    )\n    print(f'Added to queue: {serialized_data}')\n\n\nuser1 = User(id=1, name='John Doe', email='john@example.com')\nuser2 = User(id=2, name='Jane Doe', email='jane@example.com')\n\npush_to_queue(user1)\n# > Added to queue: {\"id\":1,\"name\":\"John Doe\",\"email\":\"john@example.com\"}\n\npush_to_queue(user2)\n# > Added to queue: {\"id\":2,\"name\":\"Jane Doe\",\"email\":\"jane@example.com\"}\n\nconnection.close()\n```\n\n----------------------------------------\n\nTITLE: NameEmail Equality Comparison\nDESCRIPTION: Implements the `__eq__` method for `NameEmail` (likely a custom Pydantic type or model), allowing duplicate instances to be evaluated as equal. This is important for comparisons and set operations involving `NameEmail` objects. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_230\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nclass NameEmail(BaseModel):\n    name: str\n    email: str\n\n    # The __eq__ method is now implemented to compare NameEmail instances\n    # def __eq__(self, other):\n    #     if not isinstance(other, NameEmail):\n    #         return NotImplemented\n    #     return self.name == other.name and self.email == other.email\n\n# Example:\n# email1 = NameEmail(name='Alice', email='alice@example.com')\n# email2 = NameEmail(name='Alice', email='alice@example.com')\n# print(email1 == email2) # Should print True\n```\n\n----------------------------------------\n\nTITLE: Unpack Used Without TypedDict\nDESCRIPTION: Shows the PydanticUserError raised when `typing.Unpack` is used with a type hint that is not a `typing.TypedDict` for variadic keyword parameters.",
    "chunk_length": 2223
  },
  {
    "chunk_id": 204,
    "source": "pydantic_llms_data",
    "content": "This ensures correct usage with PEP 692. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(**kwargs: Unpack[int]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'unpack-typed-dict'\n```\n\n----------------------------------------\n\nTITLE: Pydantic computed_field with Property for Volume Calculation\nDESCRIPTION: Demonstrates using the computed_field decorator with a property to calculate the volume of a Box model. Includes JSON schema generation and model dumping. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property  # (1)! def volume(self) -> float:\n        return self.width * self.height * self.depth\n\n\nprint(Box.model_json_schema(mode='serialization'))\n```\n\nLANGUAGE: json\nCODE:\n```\n{\n    'properties': {\n        'width': {'title': 'Width', 'type': 'number'},\n        'height': {'title': 'Height', 'type': 'number'},\n        'depth': {'title': 'Depth', 'type': 'number'},\n        'volume': {'readOnly': True, 'title': 'Volume', 'type': 'number'},\n    },\n    'required': ['width', 'height', 'depth', 'volume'],\n    'title': 'Box',\n    'type': 'object',\n}\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n\n\nb = Box(width=1, height=2, depth=3)\nprint(b.model_dump())\n```\n\n----------------------------------------\n\nTITLE: Mypy Plugin: Detect Required Fields\nDESCRIPTION: Enhances the Pydantic mypy plugin's ability to accurately detect and report required fields within models.",
    "chunk_length": 2064
  },
  {
    "chunk_id": 205,
    "source": "pydantic_llms_data",
    "content": "This leads to better static type checking and fewer runtime errors. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_79\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int # Mypy plugin should correctly identify 'id' as required\n    name: str = \"Guest\" # Mypy plugin should identify 'name' as optional\n\n# Mypy check would flag missing 'id' if not provided:\n# user = User(name=\"Alice\") # This should raise a mypy error\n\n```\n\n----------------------------------------\n\nTITLE: Performance: Optimize get_type_ref Calls\nDESCRIPTION: Improves the performance of calls to `get_type_ref` by optimizing its internal implementation, contributing to faster schema building. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n# Internal optimization for type referencing during schema generation. ```\n\n----------------------------------------\n\nTITLE: Support for re.Pattern Type\nDESCRIPTION: Adds native support for the `re.Pattern` type, allowing Pydantic models to directly validate and handle compiled regular expression objects. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_73\n\nLANGUAGE: python\nCODE:\n```\nimport re\nfrom pydantic import BaseModel\n\nclass RegexModel(BaseModel):\n    pattern: re.Pattern\n\ncompiled_regex = re.compile(r'^\\d+$')\nmodel = RegexModel(pattern=compiled_regex)\n\nprint(model.pattern)\n\n```\n\n----------------------------------------\n\nTITLE: Pydantic v0.32.2: Dataclass Inheritance and GenericModels\nDESCRIPTION: Fixes related to `__post_init__` usage with dataclass inheritance and validation of required fields on GenericModels classes. Also addresses custom `Schema` definition on `GenericModel` fields. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_261\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic v0.32.2 Release Notes:\n\n- Fix `__post_init__` usage with dataclass inheritance. - Related to issue [#739](https://github.com/pydantic/pydantic/pull/739). - Fix required fields validation on GenericModels classes.",
    "chunk_length": 2097
  },
  {
    "chunk_id": 206,
    "source": "pydantic_llms_data",
    "content": "- Related to issue [#742](https://github.com/pydantic/pydantic/pull/742). - Fix defining custom `Schema` on `GenericModel` fields. - Related to issue [#754](https://github.com/pydantic/pydantic/pull/754). ```\n\n----------------------------------------\n\nTITLE: Pydantic Serialization by Alias (Runtime Flag)\nDESCRIPTION: Enables serialization of model fields using their defined aliases on a per-call basis using the `by_alias=True` flag in `model_dump()` or `model_dump_json()`. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(serialization_alias='my_alias')\n\n\nm = Model(my_field='foo')\nprint(m.model_dump(by_alias=True))\n#> {'my_alias': 'foo'}\n```\n\n----------------------------------------\n\nTITLE: Define Pydantic Model with Nested Types\nDESCRIPTION: Demonstrates defining a Pydantic BaseModel that inherits from another class (Base) and uses various type annotations, including local types and forward references. Shows how Pydantic handles complex type resolution. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\nfrom module1 import Base\n\ntype MyType = str\n\n\ndef inner() -> None:\n    type InnerType = bool\n\n    class Model(BaseModel, Base):\n        type LocalType = bytes\n\n        f2: 'MyType'\n        f3: 'InnerType'\n        f4: 'LocalType'\n        f5: 'UnknownType'\n\n    type InnerType2 = complex\n```\n\n----------------------------------------\n\nTITLE: Address Mypy Plugin Bugs\nDESCRIPTION: Resolves bugs within the Pydantic mypy plugin, specifically addressing issues caused by `explicit_package_bases=True` and ensuring implicit defaults are added for Fields without default arguments. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_57\n\nLANGUAGE: python\nCODE:\n```\n# Address bug in mypy plugin caused by explicit_package_bases=True, [#5191](https://github.com/pydantic/pydantic/pull/5191) by @dmontagu\n# Add implicit defaults in the mypy plugin for Field with no default argument, [#5190](https://github.com/pydantic/pydantic/pull/5190) by @dmontagu\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Ignore Extra Data\nDESCRIPTION: Demonstrates Pydantic's default behavior of ignoring extra fields provided during model instantiation.",
    "chunk_length": 2456
  },
  {
    "chunk_id": 207,
    "source": "pydantic_llms_data",
    "content": "Extra data is simply discarded. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: int\n\n\nm = Model(x=1, y='a')\nassert m.model_dump() == {'x': 1}\n```\n\n----------------------------------------\n\nTITLE: Avoid Primitive Subclasses\nDESCRIPTION: Subclassing primitive types like `str` to add custom behavior can complicate Pydantic's validation and serialization. It's often cleaner and more performant to use Pydantic models to represent structured data with custom attributes. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/performance.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Don't do this: Subclassing str for custom attributes\nclass CompletedStr(str):\n    def __init__(self, s: str):\n        self.s = s\n        self.done = False\n\n\n# Do this: Use a Pydantic model for structured data\nfrom pydantic import BaseModel\n\n\nclass CompletedModel(BaseModel):\n    s: str\n    done: bool = False\n\n\n# Example usage:\n# completed_model = CompletedModel(s='task', done=True)\n```\n\n----------------------------------------\n\nTITLE: Pydantic Field Customization API\nDESCRIPTION: Provides an overview of the pydantic.fields.Field function for customizing Pydantic model fields, including default values, JSON Schema metadata, and constraints. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#_snippet_5\n\nLANGUAGE: APIDOC\nCODE:\n```\npydantic.fields.Field\n\nUsed to customize Pydantic model fields, providing mechanisms for default values, JSON Schema metadata, constraints, and more. It behaves similarly to dataclasses.field. Usage:\n```python\nfrom pydantic import BaseModel, Field\n\nclass Model(BaseModel):\n    name: str = Field(frozen=True)\n    # Or to explicitly mark as required:\n    # name: str = Field(..., frozen=True)\n```\n\nKey Parameters and Concepts:\n- `default`: Sets a default value for the field. If not provided and the field is not marked with `...` (ellipsis), it's considered optional.",
    "chunk_length": 2060
  },
  {
    "chunk_id": 208,
    "source": "pydantic_llms_data",
    "content": "- `default_factory`: A callable that returns a default value. Useful for mutable defaults like lists or dictionaries. - `alias`: Specifies a different name for the field when parsing JSON. - `frozen`: If True, the field cannot be changed after initialization. - `...` (Ellipsis): Used to explicitly mark a field as required, even if a default value is assigned. - `Annotated`: Can be used with `Field` to attach metadata to a field's type, allowing for more complex validation and customization. Example with Annotated:\n```python\nfrom typing import Annotated\nfrom pydantic import BaseModel, Field, WithJsonSchema\n\nclass Model(BaseModel):\n    name: Annotated[str, Field(strict=True), WithJsonSchema({'extra': 'data'})]\n```\n\nConsiderations:\n- Arguments like `default`, `default_factory`, and `alias` are recognized by static type checkers for `__init__` synthesis. - The `Annotated` pattern is not directly understood by static type checkers for `__init__` synthesis, so use the normal assignment form when type checker compatibility is critical for these arguments. - Metadata applied via `Annotated` can be specific to the type or the field. Ensure correct placement to achieve the desired effect (e.g., `deprecated` flag applies to the field when applied to the top-level type). ```\n\n----------------------------------------\n\nTITLE: Pydantic v2.11.0 Fixes\nDESCRIPTION: Details fixes in Pydantic v2.11.0, including handling generic typed dictionaries for unpacked variadic keyword parameters, resolving runtime errors with model string representations involving cached properties, preserving pipeline steps with ellipsis, and fixing deferred discriminator application logic. SOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Fixes in v2.11.0\n# Allow generic typed dictionaries to be used for unpacked variadic keyword parameters\n# Fix runtime error when computing model string representation involving cached properties and self-referenced models\n# Preserve other steps when using the ellipsis in the pipeline API\n# Fix deferred discriminator application logic\n```\n\n----------------------------------------\n\nTITLE: Pydantic Custom Root Types with RootModel\nDESCRIPTION: Introduces `RootModel` in Pydantic V2 as the successor to the `__root__` field for defining custom root types.",
    "chunk_length": 2338
  },
  {
    "chunk_id": 209,
    "source": "pydantic_llms_data",
    "content": "This provides a more explicit and robust way to handle models that wrap a single value. SOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#_snippet_12\n\nLANGUAGE: APIDOC\nCODE:\n```\nPydantic V2 Custom Root Types:\n\n- `RootModel` replaces the `__root__` field from Pydantic V1. - Purpose: To define models that wrap a single value or a collection. - Usage: Inherit from `RootModel` and specify the root type as a generic parameter. - Configuration Note: `RootModel` types no longer support the `arbitrary_types_allowed` config setting. Example Usage:\n```python\nfrom pydantic import BaseModel, RootModel\nfrom typing import List\n\n# V1 style (deprecated)\n# class MyRootModelV1(BaseModel):\n#     __root__: List[int]\n\n# V2 style using RootModel\nclass MyRootModelV2(RootModel[List[int]]):\n    pass\n\n# Validation and usage\nroot_instance = MyRootModelV2([1, 2, 3])\nprint(root_instance.root_value) # Access the wrapped value\nprint(root_instance.model_dump())\n# Expected output: {'root': [1, 2, 3]}\n\n# Validation with different types\n# invalid_instance = MyRootModelV2([1, 'a', 3]) # This would raise a ValidationError\n```\n```",
    "chunk_length": 1133
  }
]